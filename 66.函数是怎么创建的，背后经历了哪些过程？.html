<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>66. 函数是怎么创建的，背后经历了哪些过程？ - CPython3.8 源码探秘</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/custom.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="0.序言.html">0. 序言</a></li><li class="chapter-item expanded "><a href="1.CPython源码长什么样子？.html">1. CPython 源码长什么样子？</a></li><li class="chapter-item expanded "><a href="2.变量和对象，它们之间有什么区别和联系呢？.html">2. 变量和对象，它们之间有什么区别和联系呢？</a></li><li class="chapter-item expanded "><a href="3.Python对象有哪几种，我们可以从哪些角度进行分类呢？.html">3. Python 对象有哪几种，我们可以从哪些角度进行分类呢？</a></li><li class="chapter-item expanded "><a href="4.万丈高楼平地起，一切从PyObject开始.html">4. 万丈高楼平地起，一切从 PyObject 开始</a></li><li class="chapter-item expanded "><a href="5.详解PyTypeObject，Python类型对象的载体.html">5. 详解 PyTypeObject，Python 类型对象的载体</a></li><li class="chapter-item expanded "><a href="6.通过type和object之间的关联，进一步分析类型对象.html">6. 通过 type 和 object 之间的关联，进一步分析类型对象</a></li><li class="chapter-item expanded "><a href="7.当创建一个Python对象时，背后都经历了哪些过程？.html">7. 当创建一个 Python 对象时，背后都经历了哪些过程？</a></li><li class="chapter-item expanded "><a href="8.当调用一个Python对象时，背后都经历了哪些过程？.html">8. 当调用一个 Python 对象时，背后都经历了哪些过程？</a></li><li class="chapter-item expanded "><a href="9.再探泛型API，感受Python对象的设计哲学.html">9. 再探泛型 API，感受 Python 对象的设计哲学</a></li><li class="chapter-item expanded "><a href="10.Python对象的行为是怎么区分的？.html">10. Python 对象的行为是怎么区分的？</a></li><li class="chapter-item expanded "><a href="11.一个Python对象会在何时被销毁？.html">11. 一个 Python 对象会在何时被销毁？</a></li><li class="chapter-item expanded "><a href="12.深度解密Python的浮点数是怎么实现的？.html">12. 深度解密 Python 的浮点数是怎么实现的？</a></li><li class="chapter-item expanded "><a href="13.对象被销毁之后所占的内存一定会释放吗？解密浮点数的缓存池机制.html">13. 对象被销毁之后所占的内存一定会释放吗？解密浮点数的缓存池机制</a></li><li class="chapter-item expanded "><a href="14.浮点数支持的操作是怎么实现的？.html">14. 浮点数支持的操作是怎么实现的？</a></li><li class="chapter-item expanded "><a href="15.解密Python的复数是怎么实现的？它有什么用途呢？.html">15. 解密 Python 的复数是怎么实现的？它有什么用途呢？</a></li><li class="chapter-item expanded "><a href="16.Python的整数是怎么设计的，为什么它不会溢出？.html">16. Python 的整数是怎么设计的，为什么它不会溢出？</a></li><li class="chapter-item expanded "><a href="17.解密Python的小整数对象池.html">17. 解密 Python 的小整数对象池</a></li><li class="chapter-item expanded "><a href="18.两个Python整数之间是如何进行大小比较的？过程并不像我们想的那样简单.html">18. 两个 Python 整数之间是如何进行大小比较的？过程并不像我们想的那样简单</a></li><li class="chapter-item expanded "><a href="19.探究Python整数的加减法，感受大整数的运算哲学与魅力.html">19. 探究 Python 整数的加减法，感受大整数的运算哲学与魅力</a></li><li class="chapter-item expanded "><a href="20.Python的布尔值是怎么实现的，你对它的了解有多深呢？.html">20. Python 的布尔值是怎么实现的，你对它的了解有多深呢？</a></li><li class="chapter-item expanded "><a href="21.Python的None是怎么实现的？.html">21. Python 的 None 是怎么实现的？</a></li><li class="chapter-item expanded "><a href="22.深度解密Python切片的实现原理.html">22.深度解密 Python 切片的实现原理</a></li><li class="chapter-item expanded "><a href="23.bytes对象（字节串）是怎么实现的？解密它的内部原理.html">23. bytes 对象（字节串）是怎么实现的？解密它的内部原理</a></li><li class="chapter-item expanded "><a href="24.bytes对象都支持哪些操作，它们是怎么实现的？.html">24. bytes 对象都支持哪些操作，它们是怎么实现的？</a></li><li class="chapter-item expanded "><a href="25.通过bytes对象的合并，探究缓冲区的奥秘.html">25. 通过 bytes 对象的合并，探究缓冲区的奥秘</a></li><li class="chapter-item expanded "><a href="26.解密bytes对象的缓存池.html">26. 解密 bytes 对象的缓存池</a></li><li class="chapter-item expanded "><a href="27.详解bytearray对象的底层实现.html">27. 详解 bytearray 对象的底层实现</a></li><li class="chapter-item expanded "><a href="28.字符集和字符编码.html">28. 字符集和字符编码</a></li><li class="chapter-item expanded "><a href="29.Python是怎么存储字符串的？.html">29. Python 是怎么存储字符串的？</a></li><li class="chapter-item expanded "><a href="30.解密字符串的底层结构，它是怎么实现的？.html">30. 解密字符串的底层结构，它是怎么实现的？</a></li><li class="chapter-item expanded "><a href="31.字符串的intern机制是怎么一回事？.html">31. 字符串的 intern 机制是怎么一回事？</a></li><li class="chapter-item expanded "><a href="32.聊一聊字符串常见操作的源码实现.html">32. 聊一聊字符串常见操作的源码实现</a></li><li class="chapter-item expanded "><a href="33.列表是怎么实现的？解密列表的数据结构.html">33. 列表是怎么实现的？解密列表的数据结构</a></li><li class="chapter-item expanded "><a href="34.列表是怎么扩容的？.html">34. 列表是怎么扩容的？</a></li><li class="chapter-item expanded "><a href="35.解密列表的创建与销毁，以及缓存池长什么样子？.html">35. 解密列表的创建与销毁，以及缓存池长什么样子？</a></li><li class="chapter-item expanded "><a href="36.列表作为序列型对象都支持哪些操作，它们在底层是怎么实现的？.html">36. 列表作为序列型对象都支持哪些操作，它们在底层是怎么实现的？</a></li><li class="chapter-item expanded "><a href="37.列表都有哪些自定义方法，它们是怎么实现的？.html">37. 列表都有哪些自定义方法，它们是怎么实现的？</a></li><li class="chapter-item expanded "><a href="38.解密元组的实现原理.html">38. 解密元组的实现原理</a></li><li class="chapter-item expanded "><a href="39.聊一聊喜闻乐见的哈希表.html">39. 聊一聊喜闻乐见的哈希表</a></li><li class="chapter-item expanded "><a href="40.字典是怎么实现的，它的底层结构长什么样子？.html">40. 字典是怎么实现的，它的底层结构长什么样子？</a></li><li class="chapter-item expanded "><a href="41.什么是可哈希对象，它的哈希值是怎么计算的？.html">41. 什么是可哈希对象，它的哈希值是怎么计算的？</a></li><li class="chapter-item expanded "><a href="42.字典的key是怎么映射成索引的，索引冲突了又该怎么办？.html">42. 字典的 key 是怎么映射成索引的，索引冲突了又该怎么办？</a></li><li class="chapter-item expanded "><a href="43.哈希表是怎么删除元素的，能直接删除吗？.html">43. 哈希表是怎么删除元素的，能直接删除吗？</a></li><li class="chapter-item expanded "><a href="44.字典是怎么创建的，支持的操作又是如何实现的？.html">44. 字典是怎么创建的，支持的操作又是如何实现的？</a></li><li class="chapter-item expanded "><a href="45.字典的自定义方法是怎么实现的？.html">45. 字典的自定义方法是怎么实现的？</a></li><li class="chapter-item expanded "><a href="46.字典是怎么扩容的？它会经历哪些过程？.html">46. 字典是怎么扩容的？它会经历哪些过程？</a></li><li class="chapter-item expanded "><a href="47.身虽死，道未消，解密字典的缓存池.html">47. 身虽死，道未消，解密字典的缓存池</a></li><li class="chapter-item expanded "><a href="48.解密集合的实现原理.html">48. 解密集合的实现原理</a></li><li class="chapter-item expanded "><a href="49.集合支持的操作有哪些，它们是怎么实现的？.html">49. 集合支持的操作有哪些，它们是怎么实现的？</a></li><li class="chapter-item expanded "><a href="50.迭代器是怎么实现的？.html">50. 迭代器是怎么实现的？</a></li><li class="chapter-item expanded "><a href="51.Python源文件编译之后会得到什么，它的结构是怎样的？和字节码又有什么联系？.html">51. Python 源文件编译之后会得到什么，它的结构是怎样的？和字节码又有什么联系？</a></li><li class="chapter-item expanded "><a href="52.PyCodeObject拾遗.html">52. PyCodeObject 拾遗</a></li><li class="chapter-item expanded "><a href="53.一文让你搞懂pyc文件.html">53. 一文让你搞懂 pyc 文件</a></li><li class="chapter-item expanded "><a href="54.深度解密虚拟机的执行环境：栈帧对象.html">54. 深度解密虚拟机的执行环境：栈帧对象</a></li><li class="chapter-item expanded "><a href="55.名字空间：变量的容身之所.html">55. 名字空间：变量的容身之所</a></li><li class="chapter-item expanded "><a href="56.当查找一个变量时，虚拟机会进行哪些动作？.html">56. 当查找一个变量时，虚拟机会进行哪些动作？</a></li><li class="chapter-item expanded "><a href="57.虚拟机是怎么执行字节码的？背后都经历了哪些过程.html">57. 虚拟机是怎么执行字节码的？背后都经历了哪些过程</a></li><li class="chapter-item expanded "><a href="58.深入源码，进一步考察字节码的执行流程.html">58. 深入源码，进一步考察字节码的执行流程</a></li><li class="chapter-item expanded "><a href="59.局部变量是怎么实现静态查找的，它和local名字空间又有什么联系呢？.html">59. 局部变量是怎么实现静态查找的，它和 local 名字空间又有什么联系呢？</a></li><li class="chapter-item expanded "><a href="60.剖析字节码指令，以及Python赋值语句的原理.html">60. 剖析字节码指令，以及 Python 赋值语句的原理</a></li><li class="chapter-item expanded "><a href="61.流程控制语句if是怎么实现的？.html">61. 流程控制语句 if 是怎么实现的？</a></li><li class="chapter-item expanded "><a href="62.流程控制语句for、while是怎么实现的？.html">62. 流程控制语句 for、while 是怎么实现的？</a></li><li class="chapter-item expanded "><a href="63.异常是怎么实现的？虚拟机是如何将异常抛出去的？.html">63. 异常是怎么实现的？虚拟机是如何将异常抛出去的？</a></li><li class="chapter-item expanded "><a href="64.虚拟机是如何捕获异常的？.html">64. 虚拟机是如何捕获异常的？</a></li><li class="chapter-item expanded "><a href="65.函数在底层长什么样子？.html">65. 函数在底层长什么样子？</a></li><li class="chapter-item expanded "><a href="66.函数是怎么创建的，背后经历了哪些过程？.html" class="active">66. 函数是怎么创建的，背后经历了哪些过程？</a></li><li class="chapter-item expanded "><a href="67.函数在底层是如何调用的？.html">67. 函数在底层是如何调用的？</a></li><li class="chapter-item expanded "><a href="68.函数是如何解析位置参数的？.html">68. 函数是如何解析位置参数的？</a></li><li class="chapter-item expanded "><a href="69.函数是如何解析关键字参数的？.html">69. 函数是如何解析关键字参数的？</a></li><li class="chapter-item expanded "><a href="70.扩展位置参数和扩展关键字参数是如何解析的？.html">70. 扩展位置参数和扩展关键字参数是如何解析的？</a></li><li class="chapter-item expanded "><a href="71.闭包是怎么实现的？.html">71. 闭包是怎么实现的？</a></li><li class="chapter-item expanded "><a href="72.生成器是做什么的，为什么会有生成器？.html">72. 生成器是做什么的，为什么会有生成器？</a></li><li class="chapter-item expanded "><a href="73.源码解密生成器的实现原理.html">73. 源码解密生成器的实现原理</a></li><li class="chapter-item expanded "><a href="74.回顾Python的对象模型.html">74. 回顾 Python 的对象模型</a></li><li class="chapter-item expanded "><a href="75.class概念解析.html">75. class 概念解析</a></li><li class="chapter-item expanded "><a href="76.类型对象的初始化.html">76. 类型对象的初始化</a></li><li class="chapter-item expanded "><a href="77.自定义类对象的底层实现与metaclass.html">77. 自定义类对象的底层实现与 metaclass</a></li><li class="chapter-item expanded "><a href="78.彻底搞懂描述符.html">78. 彻底搞懂描述符</a></li><li class="chapter-item expanded "><a href="79.实例对象是如何创建的？.html">79. 实例对象是如何创建的？</a></li><li class="chapter-item expanded "><a href="80.实例对象的属性访问.html">80. 实例对象的属性访问</a></li><li class="chapter-item expanded "><a href="81.为什么实例在调用方法时会将自身传给self参数.html">81. 为什么实例在调用方法时会将自身传给 self 参数</a></li><li class="chapter-item expanded "><a href="82.模块是如何导入的？.html">82. 模块是如何导入的？</a></li><li class="chapter-item expanded "><a href="83.import机制的黑盒探测.html">83. import 机制的黑盒探测</a></li><li class="chapter-item expanded "><a href="84.import机制是怎么实现的？.html">84. import 机制是怎么实现的？</a></li><li class="chapter-item expanded "><a href="85.Python运行时环境的初始化，解释器在启动时都做了什么？.html">85. Python 运行时环境的初始化，解释器在启动时都做了什么？</a></li><li class="chapter-item expanded "><a href="86.激活Python虚拟机.html">86. 激活 Python 虚拟机</a></li><li class="chapter-item expanded "><a href="87.初识GIL、以及多个线程之间的调度机制.html">87. 初识 GIL、以及多个线程之间的调度机制</a></li><li class="chapter-item expanded "><a href="88.线程的创建、销毁、调度，以及GIL的实现原理.html">88. 线程的创建、销毁、调度，以及 GIL 的实现原理</a></li><li class="chapter-item expanded "><a href="89.解密map、filter、zip底层实现，对比列表解析式.html">89. 解密 map、filter、zip 底层实现，对比列表解析式</a></li><li class="chapter-item expanded "><a href="90.为什么要有协程，协程是如何实现的？.html">90. 为什么要有协程，协程是如何实现的？</a></li><li class="chapter-item expanded "><a href="91.什么是asyncio？如何基于单线程实现并发？事件循环又是怎么工作的？.html">91. 什么是 asyncio？如何基于单线程实现并发？事件循环又是怎么工作的？</a></li><li class="chapter-item expanded "><a href="92.协程、任务、future，以及事件循环.html">92. 协程、任务、future，以及事件循环</a></li><li class="chapter-item expanded "><a href="93.在asyncio中使用Socket.html">93. 在 asyncio 中使用 Socket</a></li><li class="chapter-item expanded "><a href="94.解密asyncio的Future和Task.html">94. 解密 asyncio 的 Future 和 Task</a></li><li class="chapter-item expanded "><a href="95.如何精确控制asyncio中并发运行的多个任务.html">95. 如何精确控制 asyncio 中并发运行的多个任务</a></li><li class="chapter-item expanded "><a href="96.详解asyncio的同步原语.html">96. 详解 asyncio 的同步原语</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">CPython3.8 源码探秘</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/satori1995/cpython-internal" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="楔子"><a class="header" href="#楔子">楔子</a></h2>
<p>前面我们介绍了函数的基本结构，它在底层由 PyFunctionObject 结构体表示，那么本篇文章来看看函数的创建过程。</p>
<h2 id="函数是何时创建的"><a class="header" href="#函数是何时创建的">函数是何时创建的</a></h2>
<p>介绍函数结构时，我们看到内部有一个 func_code 字段，指向一个 PyCodeObject 对象，而函数就是根据 PyCodeObject 对象创建的。</p>
<p>因为一个 PyCodeObject 是对一段代码的静态表示，Python 编译器将源代码编译之后，针对里面的每一个代码块（code block）都会生成相应的 PyCodeObject 对象，该对象包含了这个代码块的一些静态信息，也就是可以从源代码中看到的信息。</p>
<p>比如某个函数对应的代码块里面有一个 <font color="blue">a = 1</font> 这样的表达式，那么<font color="blue">符号 a</font> 和<font color="blue">整数 1</font>、以及它们之间的联系就是静态信息。这些信息会被静态存储起来，符号 a 被存在符号表 co_varnames 中，整数 1 被存在常量池 co_consts 中。然后 a = 1 是一条赋值语句，因此会有两条指令 LOAD_CONST 和 STORE_FAST 存在字节码指令序列 co_code 中。</p>
<p>这些信息是在编译的时候就可以得到的，因此 PyCodeObject 对象是编译之后的结果。</p>
<p>但 PyFunctionObject 对象是何时产生的呢？显然它是 Python 代码在运行时动态产生的，更准确的说，是在执行一个 def 语句的时候创建的。当虚拟机发现了 def 语句，那么就代表发现了新的 PyCodeObject 对象，因为它们是可以层层嵌套的。</p>
<p>然后虚拟机会根据这个 PyCodeObject 对象创建对应的 PyFunctionObject 对象，并将变量名和 PyFunctionObject 对象（函数体）组成键值对放在当前的 local 空间中。而在 PyFunctionObject 对象中，也需要拿到相关的静态信息，因此会有一个 func_code 字段指向 PyCodeObject。</p>
<p>除此之外，PyFunctionObject 对象还包含了一些函数在执行时所必需的动态信息，即上下文信息。比如 func_globals，就是函数在执行时关联的 global 名字空间，如果没有这个空间的话，函数就无法访问全局变量了。</p>
<p>由于 global 作用域中的符号和值必须在运行时才能确定，所以这部分必须在运行时动态创建，无法静态存储在 PyCodeObject 中。因此要基于 PyCodeObject 对象和 global 名字空间来创建 PyFunctionObject 对象，相当于一个封装。总之一切的目的，都是为了更好地执行字节码。</p>
<p>我们举个例子：</p>
<pre><code class="language-python"># 首先虚拟机从上到下执行字节码
name = &quot;古明地觉&quot;
age = 17

# 啪，很快啊，出现了一个 def
def foo():
    pass

# 出现了 def，虚拟机就知道源代码进入了一个新的作用域了
# 也就是遇到一个新的 PyCodeObject 对象了
# 而通过 def 关键字知道这是一个函数，于是会进行封装
# 将 PyCodeObject 封装成 PyFunctionObject，同时包含了全局名字空间
# 所以当执行完 def 语句之后，一个函数就被创建了
# 然后将变量名 foo 和函数体（PyFunctionObject）组成键值对存放在当前的 local 空间中
# 当然对于模块而言，local 空间也是 global 空间
print({k: v for k, v in locals().items() if k == &quot;foo&quot;})
&quot;&quot;&quot;
{'foo': &lt;function foo at 0x7f3f43b135e0&gt;}
&quot;&quot;&quot;

# 函数内部也保存了 global 空间
print(foo.__globals__ is globals() is locals())
&quot;&quot;&quot;
True
&quot;&quot;&quot;
print(foo.__globals__[&quot;foo&quot;] is foo is locals()[&quot;foo&quot;])
&quot;&quot;&quot;
True
&quot;&quot;&quot;
</code></pre>
<p>调用的时候，会从 local 空间中取出符号 foo 对应的 PyFunctionObject 对象（函数对象）。然后根据函数对象创建栈帧对象，也就是为函数创建一个栈帧，随后将执行权交给新创建的栈帧，并在新创建的栈帧中执行字节码。</p>
<h2 id="函数是怎么创建的"><a class="header" href="#函数是怎么创建的">函数是怎么创建的</a></h2>
<p>经过分析我们知道，当执行到 def 语句时会创建函数，并保存在 local 空间中。而通过<font color="blue">函数名()</font> 进行调用时，会从 local 空间取出和函数名绑定的函数对象，然后执行。</p>
<p>那么问题来了，函数（对象）是怎么创建的呢？或者说虚拟机是如何完成 PyCodeObject 对象到 PyFunctionObject 对象之间的转变呢？显然想了解这其中的奥秘，就必须从字节码入手。</p>
<pre><code class="language-python">import dis

code_string = &quot;&quot;&quot;
name = &quot;satori&quot;

def foo(a, b):
    print(a, b)

foo(1, 2)
&quot;&quot;&quot;

dis.dis(compile(code_string, &quot;&lt;func&gt;&quot;, &quot;exec&quot;))
</code></pre>
<p>源代码很简单，定义一个变量 name 和一个函数 foo，然后调用函数。显然这里面会产生两个 PyCodeObject，我们来看一下。</p>
<pre><code class="language-C">     // name = &quot;satori&quot;
   0 LOAD_CONST               0 ('satori')
   2 STORE_NAME               0 (name)
     
     // 我们看到 PyCodeObject 也会作为常量被静态收集
     // 这里是将常量池中索引为 1 的 PyCodeObject 压入运行时栈
   4 LOAD_CONST               1 (&lt;code object foo at 0x7f3f43b12c90...&gt;)
     // 加载字符串常量 &quot;foo&quot;，也就是函数名
   6 LOAD_CONST               2 ('foo')
     // 从栈中弹出函数名和 PyCodeObject，构建函数对象
     // 然后将函数对象（的指针）再压入运行时栈
   8 MAKE_FUNCTION            0
     // 从栈中弹出函数对象，并用符号 foo 绑定起来，到此函数就创建完毕了
  10 STORE_NAME               1 (foo)
    
     // 以下是 foo(1, 2) 对应的字节码
     // 加载全局变量 foo 并入栈
  12 LOAD_NAME                1 (foo)
     // 加载常量 1 和 2 并入栈
  14 LOAD_CONST               3 (1)
  16 LOAD_CONST               4 (2)
     // 从栈中弹出函数和参数，然后调用，并将调用结果、即函数的返回值压入栈中
  18 CALL_FUNCTION            2
     // 从栈顶弹出返回值，因为我们没有使用变量保存，所以会直接丢弃
     // 如果使用变量保存了，比如 res = foo(1, 2)，那么这里的字节码就是 STORE_NAME
  20 POP_TOP
  22 LOAD_CONST               5 (None)
  24 RETURN_VALUE
     
     // 以上是模块对应的字节码指令，下面是函数对应的字节码指令
Disassembly of &lt;code object foo at 0x7f3f43b12c90, file &quot;&lt;func&gt;&quot;, line 4&gt;:
     // 比较简单，就是 print(a, b) 对应的字节码
   0 LOAD_GLOBAL              0 (print)
   2 LOAD_FAST                0 (a)
   4 LOAD_FAST                1 (b)
   6 CALL_FUNCTION            2
   8 POP_TOP
  10 LOAD_CONST               0 (None)
  12 RETURN_VALUE
</code></pre>
<p>通过字节码我们看到，def 关键字实际上还是在定义变量，正所谓<font color="blue">函数即变量</font>，我们可以把函数当成普通的变量来处理。函数名就是变量名，它位于模块对应的 PyCodeObject 的符号表中。函数体就是变量指向的值，它是基于一个独立的 PyCodeObject 构建的。</p>
<p>至此，函数的结构就已经非常清晰了。</p>
<p><img src="./images/212.png" alt="" /></p>
<p>分析完结构之后，重点就要落在 MAKE_FUNCTION 指令上了，我们说当遇到 def 关键字的时候，就知道要创建函数了。在语法上这是函数的声明语句，但从虚拟机的角度来看，这其实是函数对象的创建语句。</p>
<p>所以函数是怎么创建的，就是执行 MAKE_FUNCTION 指令创建的，该指令执行完毕后，一个函数对象就被压入了运行时栈。等到 STORE_NAME 执行时，再将它从栈中弹出，然后和变量（函数名）绑定起来。</p>
<h2 id="make_function-指令"><a class="header" href="#make_function-指令">MAKE_FUNCTION 指令</a></h2>
<p>下面我们就来分析一下 MAKE_FUNCTION 指令，看看它是怎么将一个 PyCodeObject 对象变成一个 PyFunctionObject 对象的。</p>
<pre><code class="language-c">case TARGET(MAKE_FUNCTION): {
    // 弹出函数的全限定名
    PyObject *qualname = POP();
    // 弹出 PyCodeObject 对象
    PyObject *codeobj = POP();
    // 创建 PyFunctionObject 对象，接收三个参数
    // 分别是 PyCodeObject 对象、global 名字空间、函数的全限定名
    PyFunctionObject *func = (PyFunctionObject *)
        PyFunction_NewWithQualName(codeobj, f-&gt;f_globals, qualname);
    
    Py_DECREF(codeobj);
    Py_DECREF(qualname);
    // 如果函数创建失败会返回 NULL，那么跳转至 error 标签
    if (func == NULL) {
        goto error;
    }
  
    // 编译时，解释器能够静态检测出函数有没有闭包变量、类型注解等属性，并体现在 oparg 中
    // 构建函数时，通过 oparg 和一系列标志位做按位与，来判断函数是否包含指定属性
    // 由于 oparg 是指令参数，所以这些属性是否存在、以及如何访问，在编译阶段就已经确定了
    if (oparg &amp; 0x08) {
        assert(PyTuple_CheckExact(TOP()));
        func -&gt;func_closure = POP();
    }
    if (oparg &amp; 0x04) {
        assert(PyDict_CheckExact(TOP()));
        func-&gt;func_annotations = POP();
    }
    if (oparg &amp; 0x02) {
        assert(PyDict_CheckExact(TOP()));
        func-&gt;func_kwdefaults = POP();
    }
    if (oparg &amp; 0x01) {
        assert(PyTuple_CheckExact(TOP()));
        func-&gt;func_defaults = POP();
    }
    // 函数创建之后，压入运行时栈
    PUSH((PyObject *)func);
    DISPATCH();
}
</code></pre>
<p>整个步骤很好理解，先通过 LOAD_CONST 将 PyCodeObject 对象和符号 foo 压入栈中。然后执行 MAKE_FUNCTION，将两者从栈中弹出，再加上当前栈帧对象中维护的 global 名字空间，三者作为参数传入 PyFunction_NewWithQualName 函数中，从而构建出相应的 PyFunctionObject 对象。</p>
<p>下面来看看 PyFunction_NewWithQualName 是如何构造出一个 Python 函数的。</p>
<pre><code class="language-C">// Objects/funcobject.c

PyObject *
PyFunction_NewWithQualName(PyObject *code, PyObject *globals, PyObject *qualname)
{
    // 要返回的 PyFunctionObject 对象的指针 
    PyFunctionObject *op;
    // 函数的 doc、常量池、函数所在的模块
    PyObject *doc, *consts, *module;
    static PyObject *__name__ = NULL;
    // 将变量 __name__ 赋值为 &quot;__main__&quot;
    // 另外由于 __name__ 是静态变量，所以只会初始化一次
    if (__name__ == NULL) {
        __name__ = PyUnicode_InternFromString(&quot;__name__&quot;);
        if (__name__ == NULL)
            return NULL;
    }
    // 从 global 空间中获取 __name__ 的值
    // 如果创建 Python 函数时所在的文件是被导入的，那么它的值就是对应的模块名
    // 如果创建 Python 函数时所在的文件是直接执行的，那么它的值就是 __main__
    module = PyDict_GetItemWithError(globals, __name__);
    if (module) {
        Py_INCREF(module);
    }
    else if (PyErr_Occurred()) {
        return NULL;
    }
    // 通过 PyObject_GC_New 为函数对象申请空间，这里我们看到了 gc
    // 因为函数是可以发生循环引用的，因此需要被 GC 跟踪
    // 而想被 GC 跟踪，则需要有一个 PyGC_Head
    // 所以此处使用 PyObject_GC_New，同时也会为 PyGC_Head 申请内存
    op = PyObject_GC_New(PyFunctionObject, &amp;PyFunction_Type);
    if (op == NULL) {
        Py_XDECREF(module);
        return NULL;
    }
    // 下面就是设置 PyFunctionObject 对象的字段属性了
    op-&gt;func_weakreflist = NULL;
    Py_INCREF(code);
    op-&gt;func_code = code;
    Py_INCREF(globals);
    op-&gt;func_globals = globals;
    op-&gt;func_name = ((PyCodeObject *)code)-&gt;co_name;
    Py_INCREF(op-&gt;func_name);
    op-&gt;func_defaults = NULL;
    op-&gt;func_kwdefaults = NULL;
    op-&gt;func_closure = NULL;
    // 以后会通过 _PyFunction_Vectorcall 来实现函数的调用
    op-&gt;vectorcall = _PyFunction_Vectorcall;
    op-&gt;func_module = module;
    // 通过 PyCodeObject 对象获取常量池
    consts = ((PyCodeObject *)code)-&gt;co_consts;
    // 函数的 docstring 其实就是一个字符串，显然它也是常量池的一个常量，并且是常量池的第一个常量
    // 如果函数没有 docstring，那么常量池里的第一个元素会是 None，而不是字符串
    if (PyTuple_Size(consts) &gt;= 1) {
        // 所以如果 consts 的长度 &gt;=1，并且第一个元素是字符串，那么它就是函数的 docstring
        doc = PyTuple_GetItem(consts, 0);
        if (!PyUnicode_Check(doc))
            doc = Py_None;
    }
    else
        doc = Py_None;
    Py_INCREF(doc);
    // 下面也是设置 PyFunctionObject 对象的字段
    op-&gt;func_doc = doc;
    op-&gt;func_dict = NULL;
    op-&gt;func_annotations = NULL;
    if (qualname)
        op-&gt;func_qualname = qualname;
    else
        op-&gt;func_qualname = op-&gt;func_name;
    Py_INCREF(op-&gt;func_qualname);
    // 让函数对象被 GC 跟踪
    _PyObject_GC_TRACK(op);
    // 返回其泛型指针
    return (PyObject *)op;
}
</code></pre>
<p>以上就是函数对象的创建过程，说白了就是对 PyCodeObject 进行了一个封装。等函数对象创建完毕后会回到 MAKE_FUNCTION，然后设置闭包、注解等属性，并将函数对象压入栈中。接着执行 STORE_NAME 从符号表中加载符号（函数名），并从栈顶弹出函数对象，然后将两者组成键值对存储在当前栈帧的 local 名字空间中，整体还是比较简单的。</p>
<p>但如果再加上类型注解、以及默认值，会有什么效果呢？</p>
<pre><code class="language-python">import dis

code_string = &quot;&quot;&quot;
name = &quot;satori&quot;
def foo(a: int = 1, b: int = 2):
    print(a, b)
&quot;&quot;&quot;

dis.dis(compile(code_string, &quot;&lt;func&gt;&quot;, &quot;exec&quot;))
</code></pre>
<p>我们看看加上了类型注解和默认值之后，它的字节码指令会有什么变化？</p>
<pre><code class="language-C"> 0 LOAD_CONST               0 ('satori')
 2 STORE_NAME               0 (name)

 4 LOAD_CONST               7 ((1, 2))
 6 LOAD_NAME                1 (int)
 8 LOAD_NAME                1 (int)
10 LOAD_CONST               3 (('a', 'b'))
12 BUILD_CONST_KEY_MAP      2
14 LOAD_CONST               4 (&lt;code object foo at 0x7f3f4...&gt;)
16 LOAD_CONST               5 ('foo')
18 MAKE_FUNCTION            5 (defaults, annotations)
20 STORE_NAME               2 (foo)
// ......
</code></pre>
<p>不难发现，在构建函数时会先将默认值以元组的形式压入运行时栈；然后再将使用了类型注解的<font color="blue">参数</font>和<font color="blue">类型</font>也组成一个元组，并压入运行时栈。后续创建函数的时候，会将默认值保存在 func_defaults 字段中，类型注解对应的字典会保存在 func_annotations 字段中。</p>
<p><img src="./images/213.png" alt="" /></p>
<p>验证一下：</p>
<pre><code class="language-python">def foo(a: int = 1, b: int = 2):
    print(a, b)

print(foo.__defaults__)
&quot;&quot;&quot;
(1, 2)
&quot;&quot;&quot;
print(foo.__annotations__)
&quot;&quot;&quot;
{'a': &lt;class 'int'&gt;, 'b': &lt;class 'int'&gt;}
&quot;&quot;&quot;
</code></pre>
<p>基于类型注解，我们便可以额外施加一些手段，让 Python 像静态语言一样，实现函数参数的类型约束。</p>
<h2 id="聊一聊函数名"><a class="header" href="#聊一聊函数名">聊一聊函数名</a></h2>
<p>这里再说一下函数名，举个例子。</p>
<pre><code class="language-python">def foo():
    pass

print(foo.__name__)  # foo

bar = foo
print(bar.__name__)  # foo
</code></pre>
<p>我们定义了一个函数 foo，那么函数名就是 foo，这是没问题的，但怎么理解 bar 呢？</p>
<p>所以严格意义上讲，代码中的 foo 应该是一个变量。之前说过，定义函数、类、导入模块，其实都是创建了一个变量。所以代码中的 foo 也是一个变量，它指向了函数对象，而函数的名字是保存在函数对象里面的。</p>
<pre><code class="language-python">code_string = &quot;&quot;&quot;
def foo():
    pass
&quot;&quot;&quot;

code_obj = compile(code_string, &quot;&lt;func&gt;&quot;, &quot;exec&quot;)
# 我们是以模块的形式编译的，它里面只有一个变量 foo
# 所以符号表就是 ('foo',)
print(code_obj.co_names)  # ('foo',)

# 然后常量池里面存在一个 PyCodeObject
# 这个 PyCodeObject 便是函数对应的 PyCodeObject
print(code_obj.co_consts[0])  # &lt;code object foo ...&gt;
print(code_obj.co_consts[0].co_name)  # foo

# 构建函数时，PyCodeObject 的 co_name 会被赋值给函数的 func_name
# 所以严格意义上讲，def foo() 中的 foo 只能算做是变量名
# 而真正的函数名是函数对象的 func_name，它来自于 co_name
# 只不过在编译成 PyCodeObject 对象时，会进行词法分析
# 因为 def 后面是 foo，所以编译之后的 PyCodeObject 的 co_name 也是 foo

# 当然其它对象也是如此
class A:
    pass

# 这里的 A 指向了类型对象，但类型对象的名称是保存在类型对象里面的
print(A.__name__)  # A
# A.__name__ 才是类名，class 后面的 A 只是一个变量名

# 这里同样创建了一个类
B = type(&quot;B1&quot;, (object,), {})
print(B.__name__)  # B1
# 但是我们看到类名不是 B，而是 B1
# 所以我们需要明白，不管是变量赋值、还是定义函数、类、方法，导入模块
# 我们得到的只是一个变量，这个变量指向了具体的对象（它们是字典中的一个键值对）
# 而对象的名称、类型等信息，都保存在对象里面，和变量无关
# 因为变量只是一个符号，或者理解为代号，每个对象都可以有不同的代号

def foo():
    pass

# 名称也可以自由更改
foo.__name__ = &quot;foo1&quot;
# 在更改过后，函数的名字就变成了 foo1
print(foo.__name__)  # foo1

# bar = foo 之后，这个函数对象就有了两个代号，你通过 foo 和 bar 都可以找到它
# 但函数对象的名字是不变的，还是 foo1，因为它的 __name__ 属性的值是 foo1
bar = foo
print(bar.__name__)  # foo1
</code></pre>
<p>我们之前说变量只是一个和对象绑定的符号，或者说代号，运行时会和某个对象（的地址）组成键值对保存在字典中。虚拟机通过变量可以找到它代表的对象，本质上就是将变量名作为 key，去字典中检索 value。至于获取到的对象叫什么名字，是保存在对象里面的。</p>
<p>如果变量指向的是整数、字符串等，那么该对象就没有名字。如果指向的是函数、类、模块，那么对象的 __name__ 就是对象的名字。只不过在默认情况下，定义函数（以及类）时，变量名默认和函数名是一样的，所以我们会把指向函数对象的变量的名称也叫做函数名。</p>
<p>关于这一点，大家一定要清晰。</p>
<pre><code class="language-python">name = &quot;古明地觉&quot;

def foo():
    pass

class A:
    pass

import os

print(&quot;name&quot; in locals())  # True
print(&quot;foo&quot; in locals())  # True
print(&quot;A&quot; in locals())  # True
print(&quot;os&quot; in locals())  # True
</code></pre>
<p>这里的 name、foo、A、os 都是变量，站在虚拟机的角度，它们没有任何的不同，只不过指向的对象不同罢了。而站在 Python 的角度，它们也是一样的，其名称都是字典里的一个 key，只不过关联的 value 不同罢了。</p>
<p><img src="./images/214.png" alt="" /></p>
<p>比如 name 指向的是字符串对象，foo 指向的是函数对象，A 指向的是类对象，os 指向的是模块对象。但我们也可以改变指向，比如让 foo 指向类对象，A 指向字符串对像等等，都是可以的。</p>
<p>总结：变量只是一个指针，可以保存任意对象的地址，也就是可以指向任意的对象。而对象的名字、类型等一切信息，都保存在对象中，和变量无关。</p>
<p>当然这些都是之前说过的内容，再来回顾一下，总之一定要了解 Python 变量的本质。</p>
<h2 id="函数的一些骚操作"><a class="header" href="#函数的一些骚操作">函数的一些骚操作</a></h2>
<p>我们通过一些骚操作，来更好地理解一下函数。之前说 &lt;class 'function'&gt; 是函数的类型对象，而这个类底层没有暴露给我们，但我们依旧可以通过曲线救国的方式进行获取。</p>
<pre><code class="language-python">def foo():
    pass

print(type(foo))  # &lt;class 'function'&gt;
# lambda 匿名函数的类型也是 function
print(type(lambda: None))  # &lt;class 'function'&gt;
</code></pre>
<p>那么下面就来创建函数：</p>
<pre><code class="language-python">gender = &quot;female&quot;

def foo(name, age):
    return f&quot;name: {name}, age: {age}, gender: {gender}&quot;

# 得到 PyCodeObject 对象
code = foo.__code__
# 根据 class function 创建函数对象
# 接收三个参数：PyCodeObject 对象、global 名字空间、函数名
new_foo = type(foo)(code, globals(), &quot;根据 foo 创建的 new_foo&quot;)

# 打印函数名
print(new_foo.__name__)
&quot;&quot;&quot;
根据 foo 创建的 new_foo
&quot;&quot;&quot;

# 调用函数
print(new_foo(&quot;古明地觉&quot;, 17))
&quot;&quot;&quot;
name: 古明地觉, age: 17, gender: female
&quot;&quot;&quot;
</code></pre>
<p>是不是很神奇呢？另外函数之所以能访问全局变量，是因为在创建函数的时候将 global 名字空间传进去了，如果我们不传递呢？</p>
<pre><code class="language-python">gender = &quot;female&quot;

def foo(name, age):
    return f&quot;name: {name}, age: {age}, gender: {gender}&quot;

code = foo.__code__
# 第二个参数必须是一个字典，不能传 None
new_foo = type(foo)(code, {}, &quot;根据 foo 创建的 new_foo&quot;)

try:
    print(new_foo(&quot;古明地觉&quot;, 17))
except NameError as e:
    print(e)  # name 'gender' is not defined
</code></pre>
<p>因此现在我们又从 Python 的角度理解了一遍，为什么在函数内部能够访问全局变量。原因就在于构建函数的时候，将 global 名字空间交给了函数，使得函数可以在 global 空间中进行变量查找，所以它才能够找到全局变量。而我们这里给了一个空字典，那么显然就找不到 gender 这个变量了。</p>
<pre><code class="language-python">gender = &quot;female&quot;

def foo(name, age):
    return f&quot;name: {name}, age: {age}, gender: {gender}&quot;

code = foo.__code__
new_foo = type(foo)(code, {&quot;gender&quot;: &quot;萌妹子&quot;}, &quot;根据 foo 创建的 new_foo&quot;)

# 我们可以手动传递一个字典进去
# 此时传递的字典对于函数来说就是 global 名字空间
print(new_foo(&quot;古明地觉&quot;, 17))
&quot;&quot;&quot;
name: 古明地觉, age: 17, gender: 萌妹子
&quot;&quot;&quot;
# 所以此时的 gender 不再是外部的 &quot;female&quot;, 而是我们指定的 &quot;萌妹子&quot;
</code></pre>
<p>此外也可以为函数指定默认值：</p>
<pre><code class="language-python">def foo(name, age, gender):
    return f&quot;name: {name}, age: {age}, gender: {gender}&quot;

# 必须接收一个 PyTupleObject 对象
foo.__defaults__ = (&quot;古明地觉&quot;, 17, &quot;female&quot;)
print(foo())
&quot;&quot;&quot;
name: 古明地觉, age: 17, gender: female
&quot;&quot;&quot;
</code></pre>
<p>我们看到函数 foo 明明接收三个参数，但是调用时不传递居然也不会报错，原因就在于我们指定了默认值。而默认值可以在定义函数的时候指定，也可以通过 __defaults__ 指定，但很明显我们应该通过前者来指定。</p>
<p>如果你使用的是 PyCharm，那么会在 foo() 这个位置给你加波浪线，提示你参数没有传递。但我们知道，由于通过 __defaults__ 设置了默认值，所以这里是不会报错的。只不过 PyCharm 没有检测到，当然基本上所有的 IDE 都无法做到这一点，毕竟动态语言。</p>
<p>另外如果 __defaults__ 接收的元组里面的元素个数和参数个数不匹配怎么办？</p>
<pre><code class="language-python">def foo(name, age, gender):
    return f&quot;name: {name}, age: {age}, gender: {gender}&quot;

foo.__defaults__ = (15, &quot;female&quot;)
print(foo(&quot;古明地恋&quot;))
&quot;&quot;&quot;
name: 古明地恋, age: 15, gender: female
&quot;&quot;&quot;
</code></pre>
<p>由于元组里面只有两个元素，意味着我们在调用时需要至少传递一个参数，而这个参数会赋值给 name。原因就是在设置默认值的时候是从后往前设置的，也就是 &quot;female&quot; 会赋值给 gender，15 会赋值给 age。而 name 没有得到默认值，那么它就需要调用者显式传递了。</p>
<p>如果返回值从前往后设置的话，会出现什么后果？显然 15 会赋值给 name，&quot;female&quot; 会赋值给 age，此时函数就等价于如下：</p>
<pre><code class="language-python">def foo(name=15, age=&quot;female&quot;, gender):
    return f&quot;name: {name}, age: {age}, gender: {gender}&quot;
</code></pre>
<p>这样的函数显然无法通过编译，因为默认参数必须在非默认参数的后面。所以 Python 的这个做法是完全正确的，必须要从后往前进行设置。</p>
<p>另外我们知道默认值的个数是小于等于参数个数的，如果大于会怎么样呢？</p>
<pre><code class="language-python">def foo(name, age, gender):
    return f&quot;name: {name}, age: {age}, gender: {gender}&quot;

foo.__defaults__ = (&quot;古明地觉&quot;, &quot;古明地恋&quot;, 15, &quot;female&quot;)
print(foo())
&quot;&quot;&quot;
name: 古明地恋, age: 15, gender: female
&quot;&quot;&quot;
</code></pre>
<p>依旧是从后往前进行设置，当所有参数都有默认值时，就结束了，多余的默认值会丢弃。当然，如果不使用 __defaults__，是不可能出现默认值个数大于参数个数的。可要是 __defaults__ 指向的元组先结束，那么没有得到默认值的参数就必须由调用者显式传递了。</p>
<p>最后，再来说一下如何深拷贝一个函数。首先如果是你的话，你会怎么拷贝一个函数呢？不出意外的话，你应该会使用 copy 模块。</p>
<pre><code class="language-python">import copy

def foo(a, b):
    return [a, b]

# 但是问题来了，这样能否实现深度拷贝呢？
new_foo = copy.deepcopy(foo)
# 修改 foo 的默认值
foo.__defaults__ = (2, 3)
# 但是 new_foo 也会受到影响
print(new_foo())  # [2, 3]
</code></pre>
<p>打印结果提示我们并没有实现函数的深度拷贝，事实上 copy 模块无法对函数、方法、回溯栈、栈帧、模块、文件、套接字等类型的数据实现深度拷贝。那我们应该怎么做呢？</p>
<pre><code class="language-python">from types import FunctionType

def foo(a, b):
    return &quot;result&quot;

# FunctionType 就是函数的类型对象，它也是通过 type 得到的
new_foo = FunctionType(foo.__code__,
                       foo.__globals__,
                       foo.__name__,
                       foo.__defaults__,
                       foo.__closure__)
# 显然 function 还可以接收第四个参数和第五个参数
# 分别是函数的默认值和闭包

# 然后别忘记将属性字典也拷贝一份
new_foo.__dict__ = {**foo.__dict__}

foo.__defaults__ = (2, 3)
print(foo.__defaults__)  # (2, 3)
print(new_foo.__defaults__)  # None
</code></pre>
<p>此时修改 foo 不会影响 new_foo，当然在拷贝的时候也可以自定义属性。</p>
<p>其实上面实现的深拷贝，本质上就是定义了一个新的函数。由于是两个不同的函数，那么自然就没有联系了。</p>
<h2 id="判断函数都有哪些参数"><a class="header" href="#判断函数都有哪些参数">判断函数都有哪些参数</a></h2>
<p>最后再来看看如何检测一个函数有哪些参数，首先函数的局部变量（包括参数）在编译时就已经确定，会存在符号表 co_varnames 中。</p>
<pre><code class="language-python">def foo(a, b, /, c, d, *args, e, f, **kwargs):
    g = 1
    h = 2

print(foo.__code__.co_varnames)
&quot;&quot;&quot;
('a', 'b', 'c', 'd', 'e', 'f', 'args', 'kwargs', 'g', 'h')
&quot;&quot;&quot;
</code></pre>
<p>在定义函数的时候，* 和 ** 最多只能出现一次。然后这里的 a 和 b 必须通过位置参数传递，c 和 d 可以通过位置参数或者关键字参数传递，e 和 f 必须通过关键字参数传递。</p>
<p>而从打印的符号表来看，里面的符号是有顺序的。参数永远在函数内部定义的局部变量的前面，比如 g 和 h 就是函数内部定义的局部变量，所以它在所有参数的后面。而对于参数，* 和 ** 会位于最后面，其它参数位置不变。所以除了 g 和 h，最后面的就是 args 和 kwargs。</p>
<p>有了这些信息，我们就可以进行检测了。</p>
<pre><code class="language-python">def foo(a, b, /, c, d, *args, e, f, **kwargs):
    g = 1
    h = 2

varnames = foo.__code__.co_varnames
# 1. 寻找必须通过位置参数传递的参数
posonlyargcount = foo.__code__.co_posonlyargcount
print(posonlyargcount)  # 2
print(varnames[: posonlyargcount])  # ('a', 'b')

# 2. 寻找可以通过位置参数（或关键字参数）传递的参数
argcount = foo.__code__.co_argcount
# 注：co_argcount 里面包含了 co_posonlyargcount
print(argcount)  # 4
print(varnames[: argcount])  # ('a', 'b', 'c', 'd')
print(varnames[posonlyargcount: argcount])  # ('c', 'd')

# 3. 寻找必须通过关键字参数传递的参数
kwonlyargcount = foo.__code__.co_kwonlyargcount
print(kwonlyargcount)  # 2
print(varnames[argcount: argcount + kwonlyargcount])  # ('e', 'f')

# 4. 寻找 *args 和 **kwargs
flags = foo.__code__.co_flags
# 在介绍 PyCodeObject 的时候，我们说里面有一个 co_flags 字段
# 它是函数的标识，可以对函数类型和参数进行检测
# 如果 co_flags 和 4 按位与的结果为真，那么就代表有 *args，否则没有
# 如果 co_flags 和 8 按位与的结果为真，那么就代表有 **kwargs，否则没有
step = argcount + kwonlyargcount
if flags &amp; 0x04:
    print(varnames[step])  # args
    step += 1

if flags &amp; 0x08:
    print(varnames[step])  # kwargs
</code></pre>
<p>以上我们就检测出了函数都有哪些参数，你也可以自己试一试。另外还要注意一点，如果定义的时候，指定的不是 *args，而只是一个 *，那么它就不是参数了。</p>
<pre><code class="language-python">def f(a, b, *, c):
    pass


# 符号表里面只有 a、b、c
print(f.__code__.co_varnames)  # ('a', 'b', 'c')

# 显然此时也都为假
print(f.__code__.co_flags &amp; 0x04)  # 0
print(f.__code__.co_flags &amp; 0x08)  # 0
</code></pre>
<p>单独的一个 * 只是为了强制要求后面的参数必须通过关键字参数的方式传递。</p>
<h2 id="小结"><a class="header" href="#小结">小结</a></h2>
<p>这一次我们简单地分析了一下函数是如何创建的，并且还在 Python 的层面上做了一些小 trick。最后我们也分析了如何通过 PyCodeObject 对象来检索函数的参数，以及相关种类，标准库中的 inspect 模块也是这么做的。准确的说，是我们模仿人家的思路做的。</p>
<p>现在你是不是对函数有了一个更深刻的认识了呢？当然目前介绍的只是函数的一部分内容，还有更多内容等待我们挖掘，比如：</p>
<ul>
<li>函数如何调用。</li>
<li>位置参数和关键字参数如何解析。</li>
<li>对于有默认值的参数，如何在不传参的时候使用默认值、在传参的时候使用我们传递的值。</li>
<li>*args 和 **kwargs 如何解析。</li>
<li>闭包怎么实现。</li>
<li>装饰器怎么实现</li>
<li>......</li>
</ul>
<p>这些内容我们接下来慢慢说。</p>
<hr />
<p> </p>
<p><strong>欢迎大家关注我的公众号：古明地觉的编程教室。</strong></p>
<p><img src="./images/qrcode_for_gh.jpg" alt="" /></p>
<p><strong>如果觉得文章对你有所帮助，也可以请作者吃个馒头，Thanks♪(･ω･)ﾉ。</strong></p>
<p><img src="./images/supports.png" alt="" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="65.函数在底层长什么样子？.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="67.函数在底层是如何调用的？.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="65.函数在底层长什么样子？.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="67.函数在底层是如何调用的？.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="theme/custom.js"></script>
    </body>
</html>
