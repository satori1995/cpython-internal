<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>77. 自定义类对象的底层实现与 metaclass - CPython3.8 源码探秘</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/custom.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="0.序言.html">0. 序言</a></li><li class="chapter-item expanded "><a href="1.CPython源码长什么样子？.html">1. CPython 源码长什么样子？</a></li><li class="chapter-item expanded "><a href="2.变量和对象，它们之间有什么区别和联系呢？.html">2. 变量和对象，它们之间有什么区别和联系呢？</a></li><li class="chapter-item expanded "><a href="3.Python对象有哪几种，我们可以从哪些角度进行分类呢？.html">3. Python 对象有哪几种，我们可以从哪些角度进行分类呢？</a></li><li class="chapter-item expanded "><a href="4.万丈高楼平地起，一切从PyObject开始.html">4. 万丈高楼平地起，一切从 PyObject 开始</a></li><li class="chapter-item expanded "><a href="5.详解PyTypeObject，Python类型对象的载体.html">5. 详解 PyTypeObject，Python 类型对象的载体</a></li><li class="chapter-item expanded "><a href="6.通过type和object之间的关联，进一步分析类型对象.html">6. 通过 type 和 object 之间的关联，进一步分析类型对象</a></li><li class="chapter-item expanded "><a href="7.当创建一个Python对象时，背后都经历了哪些过程？.html">7. 当创建一个 Python 对象时，背后都经历了哪些过程？</a></li><li class="chapter-item expanded "><a href="8.当调用一个Python对象时，背后都经历了哪些过程？.html">8. 当调用一个 Python 对象时，背后都经历了哪些过程？</a></li><li class="chapter-item expanded "><a href="9.再探泛型API，感受Python对象的设计哲学.html">9. 再探泛型 API，感受 Python 对象的设计哲学</a></li><li class="chapter-item expanded "><a href="10.Python对象的行为是怎么区分的？.html">10. Python 对象的行为是怎么区分的？</a></li><li class="chapter-item expanded "><a href="11.一个Python对象会在何时被销毁？.html">11. 一个 Python 对象会在何时被销毁？</a></li><li class="chapter-item expanded "><a href="12.深度解密Python的浮点数是怎么实现的？.html">12. 深度解密 Python 的浮点数是怎么实现的？</a></li><li class="chapter-item expanded "><a href="13.对象被销毁之后所占的内存一定会释放吗？解密浮点数的缓存池机制.html">13. 对象被销毁之后所占的内存一定会释放吗？解密浮点数的缓存池机制</a></li><li class="chapter-item expanded "><a href="14.浮点数支持的操作是怎么实现的？.html">14. 浮点数支持的操作是怎么实现的？</a></li><li class="chapter-item expanded "><a href="15.解密Python的复数是怎么实现的？它有什么用途呢？.html">15. 解密 Python 的复数是怎么实现的？它有什么用途呢？</a></li><li class="chapter-item expanded "><a href="16.Python的整数是怎么设计的，为什么它不会溢出？.html">16. Python 的整数是怎么设计的，为什么它不会溢出？</a></li><li class="chapter-item expanded "><a href="17.解密Python的小整数对象池.html">17. 解密 Python 的小整数对象池</a></li><li class="chapter-item expanded "><a href="18.两个Python整数之间是如何进行大小比较的？过程并不像我们想的那样简单.html">18. 两个 Python 整数之间是如何进行大小比较的？过程并不像我们想的那样简单</a></li><li class="chapter-item expanded "><a href="19.探究Python整数的加减法，感受大整数的运算哲学与魅力.html">19. 探究 Python 整数的加减法，感受大整数的运算哲学与魅力</a></li><li class="chapter-item expanded "><a href="20.Python的布尔值是怎么实现的，你对它的了解有多深呢？.html">20. Python 的布尔值是怎么实现的，你对它的了解有多深呢？</a></li><li class="chapter-item expanded "><a href="21.Python的None是怎么实现的？.html">21. Python 的 None 是怎么实现的？</a></li><li class="chapter-item expanded "><a href="22.深度解密Python切片的实现原理.html">22.深度解密 Python 切片的实现原理</a></li><li class="chapter-item expanded "><a href="23.bytes对象（字节串）是怎么实现的？解密它的内部原理.html">23. bytes 对象（字节串）是怎么实现的？解密它的内部原理</a></li><li class="chapter-item expanded "><a href="24.bytes对象都支持哪些操作，它们是怎么实现的？.html">24. bytes 对象都支持哪些操作，它们是怎么实现的？</a></li><li class="chapter-item expanded "><a href="25.通过bytes对象的合并，探究缓冲区的奥秘.html">25. 通过 bytes 对象的合并，探究缓冲区的奥秘</a></li><li class="chapter-item expanded "><a href="26.解密bytes对象的缓存池.html">26. 解密 bytes 对象的缓存池</a></li><li class="chapter-item expanded "><a href="27.详解bytearray对象的底层实现.html">27. 详解 bytearray 对象的底层实现</a></li><li class="chapter-item expanded "><a href="28.字符集和字符编码.html">28. 字符集和字符编码</a></li><li class="chapter-item expanded "><a href="29.Python是怎么存储字符串的？.html">29. Python 是怎么存储字符串的？</a></li><li class="chapter-item expanded "><a href="30.解密字符串的底层结构，它是怎么实现的？.html">30. 解密字符串的底层结构，它是怎么实现的？</a></li><li class="chapter-item expanded "><a href="31.字符串的intern机制是怎么一回事？.html">31. 字符串的 intern 机制是怎么一回事？</a></li><li class="chapter-item expanded "><a href="32.聊一聊字符串常见操作的源码实现.html">32. 聊一聊字符串常见操作的源码实现</a></li><li class="chapter-item expanded "><a href="33.列表是怎么实现的？解密列表的数据结构.html">33. 列表是怎么实现的？解密列表的数据结构</a></li><li class="chapter-item expanded "><a href="34.列表是怎么扩容的？.html">34. 列表是怎么扩容的？</a></li><li class="chapter-item expanded "><a href="35.解密列表的创建与销毁，以及缓存池长什么样子？.html">35. 解密列表的创建与销毁，以及缓存池长什么样子？</a></li><li class="chapter-item expanded "><a href="36.列表作为序列型对象都支持哪些操作，它们在底层是怎么实现的？.html">36. 列表作为序列型对象都支持哪些操作，它们在底层是怎么实现的？</a></li><li class="chapter-item expanded "><a href="37.列表都有哪些自定义方法，它们是怎么实现的？.html">37. 列表都有哪些自定义方法，它们是怎么实现的？</a></li><li class="chapter-item expanded "><a href="38.解密元组的实现原理.html">38. 解密元组的实现原理</a></li><li class="chapter-item expanded "><a href="39.聊一聊喜闻乐见的哈希表.html">39. 聊一聊喜闻乐见的哈希表</a></li><li class="chapter-item expanded "><a href="40.字典是怎么实现的，它的底层结构长什么样子？.html">40. 字典是怎么实现的，它的底层结构长什么样子？</a></li><li class="chapter-item expanded "><a href="41.什么是可哈希对象，它的哈希值是怎么计算的？.html">41. 什么是可哈希对象，它的哈希值是怎么计算的？</a></li><li class="chapter-item expanded "><a href="42.字典的key是怎么映射成索引的，索引冲突了又该怎么办？.html">42. 字典的 key 是怎么映射成索引的，索引冲突了又该怎么办？</a></li><li class="chapter-item expanded "><a href="43.哈希表是怎么删除元素的，能直接删除吗？.html">43. 哈希表是怎么删除元素的，能直接删除吗？</a></li><li class="chapter-item expanded "><a href="44.字典是怎么创建的，支持的操作又是如何实现的？.html">44. 字典是怎么创建的，支持的操作又是如何实现的？</a></li><li class="chapter-item expanded "><a href="45.字典的自定义方法是怎么实现的？.html">45. 字典的自定义方法是怎么实现的？</a></li><li class="chapter-item expanded "><a href="46.字典是怎么扩容的？它会经历哪些过程？.html">46. 字典是怎么扩容的？它会经历哪些过程？</a></li><li class="chapter-item expanded "><a href="47.身虽死，道未消，解密字典的缓存池.html">47. 身虽死，道未消，解密字典的缓存池</a></li><li class="chapter-item expanded "><a href="48.解密集合的实现原理.html">48. 解密集合的实现原理</a></li><li class="chapter-item expanded "><a href="49.集合支持的操作有哪些，它们是怎么实现的？.html">49. 集合支持的操作有哪些，它们是怎么实现的？</a></li><li class="chapter-item expanded "><a href="50.迭代器是怎么实现的？.html">50. 迭代器是怎么实现的？</a></li><li class="chapter-item expanded "><a href="51.Python源文件编译之后会得到什么，它的结构是怎样的？和字节码又有什么联系？.html">51. Python 源文件编译之后会得到什么，它的结构是怎样的？和字节码又有什么联系？</a></li><li class="chapter-item expanded "><a href="52.PyCodeObject拾遗.html">52. PyCodeObject 拾遗</a></li><li class="chapter-item expanded "><a href="53.一文让你搞懂pyc文件.html">53. 一文让你搞懂 pyc 文件</a></li><li class="chapter-item expanded "><a href="54.深度解密虚拟机的执行环境：栈帧对象.html">54. 深度解密虚拟机的执行环境：栈帧对象</a></li><li class="chapter-item expanded "><a href="55.名字空间：变量的容身之所.html">55. 名字空间：变量的容身之所</a></li><li class="chapter-item expanded "><a href="56.当查找一个变量时，虚拟机会进行哪些动作？.html">56. 当查找一个变量时，虚拟机会进行哪些动作？</a></li><li class="chapter-item expanded "><a href="57.虚拟机是怎么执行字节码的？背后都经历了哪些过程.html">57. 虚拟机是怎么执行字节码的？背后都经历了哪些过程</a></li><li class="chapter-item expanded "><a href="58.深入源码，进一步考察字节码的执行流程.html">58. 深入源码，进一步考察字节码的执行流程</a></li><li class="chapter-item expanded "><a href="59.局部变量是怎么实现静态查找的，它和local名字空间又有什么联系呢？.html">59. 局部变量是怎么实现静态查找的，它和 local 名字空间又有什么联系呢？</a></li><li class="chapter-item expanded "><a href="60.剖析字节码指令，以及Python赋值语句的原理.html">60. 剖析字节码指令，以及 Python 赋值语句的原理</a></li><li class="chapter-item expanded "><a href="61.流程控制语句if是怎么实现的？.html">61. 流程控制语句 if 是怎么实现的？</a></li><li class="chapter-item expanded "><a href="62.流程控制语句for、while是怎么实现的？.html">62. 流程控制语句 for、while 是怎么实现的？</a></li><li class="chapter-item expanded "><a href="63.异常是怎么实现的？虚拟机是如何将异常抛出去的？.html">63. 异常是怎么实现的？虚拟机是如何将异常抛出去的？</a></li><li class="chapter-item expanded "><a href="64.虚拟机是如何捕获异常的？.html">64. 虚拟机是如何捕获异常的？</a></li><li class="chapter-item expanded "><a href="65.函数在底层长什么样子？.html">65. 函数在底层长什么样子？</a></li><li class="chapter-item expanded "><a href="66.函数是怎么创建的，背后经历了哪些过程？.html">66. 函数是怎么创建的，背后经历了哪些过程？</a></li><li class="chapter-item expanded "><a href="67.函数在底层是如何调用的？.html">67. 函数在底层是如何调用的？</a></li><li class="chapter-item expanded "><a href="68.函数是如何解析位置参数的？.html">68. 函数是如何解析位置参数的？</a></li><li class="chapter-item expanded "><a href="69.函数是如何解析关键字参数的？.html">69. 函数是如何解析关键字参数的？</a></li><li class="chapter-item expanded "><a href="70.扩展位置参数和扩展关键字参数是如何解析的？.html">70. 扩展位置参数和扩展关键字参数是如何解析的？</a></li><li class="chapter-item expanded "><a href="71.闭包是怎么实现的？.html">71. 闭包是怎么实现的？</a></li><li class="chapter-item expanded "><a href="72.生成器是做什么的，为什么会有生成器？.html">72. 生成器是做什么的，为什么会有生成器？</a></li><li class="chapter-item expanded "><a href="73.源码解密生成器的实现原理.html">73. 源码解密生成器的实现原理</a></li><li class="chapter-item expanded "><a href="74.回顾Python的对象模型.html">74. 回顾 Python 的对象模型</a></li><li class="chapter-item expanded "><a href="75.class概念解析.html">75. class 概念解析</a></li><li class="chapter-item expanded "><a href="76.类型对象的初始化.html">76. 类型对象的初始化</a></li><li class="chapter-item expanded "><a href="77.自定义类对象的底层实现与metaclass.html" class="active">77. 自定义类对象的底层实现与 metaclass</a></li><li class="chapter-item expanded "><a href="78.彻底搞懂描述符.html">78. 彻底搞懂描述符</a></li><li class="chapter-item expanded "><a href="79.实例对象是如何创建的？.html">79. 实例对象是如何创建的？</a></li><li class="chapter-item expanded "><a href="80.实例对象的属性访问.html">80. 实例对象的属性访问</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">CPython3.8 源码探秘</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/satori1995/cpython-internal" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="楔子"><a class="header" href="#楔子">楔子</a></h2>
<p>Python 除了提供很多内置的类之外，还支持我们定义属于自己的类，那么底层是如何做的呢？下面就来看看。</p>
<p>老规矩，如果想知道底层是怎么做的，那么就必须要通过观察字节码来实现。这里我们随便定义一个类，然后反编译一下：</p>
<pre><code class="language-Python">class Girl:
    name = &quot;古明地觉&quot;

    def __init__(self):
        print(f&quot;__init__: {self.name}&quot;)

    def foo(self):
        print(&quot;foo&quot;)

    def bar(self, name):
        self.name = name
        print(self.name)

girl = Girl()
girl.foo()
girl.bar(&quot;古明地恋&quot;)
&quot;&quot;&quot;
__init__: 古明地觉
foo
古明地恋
&quot;&quot;&quot;
</code></pre>
<p>通过之前对函数机制的分析，我们知道对于一个包含函数定义的 Python 源文件，在编译之后会得到一个和源文件对应的 PyCodeObject 对象，其内部的常量池中存储了和函数对应的 PyCodeObject 对象。那么对于包含类的 Python 源文件，编译之后的结果又是怎么样的呢？</p>
<p>显然可以照葫芦画瓢，根据以前的经验我们可以猜测模块对应的 PyCodeObject 对象的常量池中肯定存储了类对应的 PyCodeObject 对象，类对应的 PyCodeObject 对象的常量池中则存储了 __init__、foo、bar 三个函数对应的 PyCodeObject 对象。然而事实也确实如此。</p>
<p><img src="./images/252.png" alt="" /></p>
<p>在介绍函数的时候，我们看到函数的声明（def 语句）和函数的实现虽然在逻辑上是一个整体，但它们的字节码指令却是分离在两个 PyCodeObject 对象中的。</p>
<p>在类中，同样存在这样的分离现象。声明类的 class 语句，编译后的字节码指令存储在模块对应的 PyCodeObject 中；而类的实现、也就是类里面的逻辑，编译后的字节码指令则存储在类对应的 PyCodeObject 中。所以我们在模块级别中只能找到类，无法直接找到类里面的属性。</p>
<p>另外还可以看到，类的成员函数和一般的函数相同，也会有这种声明和实现分离的现象。正所谓函数即变量，类也是如此，def、class 本质上都是定义一个变量，该变量指向具体的 PyFunctionObject 或者 PyTypeObject。</p>
<pre><code class="language-python">code_string = &quot;&quot;&quot;
class Girl:
    name = &quot;古明地觉&quot;

    def __init__(self):
        print(f&quot;__init__: {self.name}&quot;)

    def foo(self):
        print(&quot;foo&quot;)

    def bar(self, name):
        self.name = name
        print(self.name)
&quot;&quot;&quot;
# 模块对应的 PyCodeObject 对象
code = compile(code_string, &quot;&lt;file&gt;&quot;, &quot;exec&quot;)

# 常量池里面存储了 Girl 对应的 PyCodeObject 对象
print(code.co_consts[0])  # &lt;code object Girl at 0x1029d80e0, ...&gt;

# Girl 对应的 PyCodeObject 对象的常量池里面存储了几个函数对应的 PyCodeObject 对象
print(code.co_consts[0].co_consts[2])  # &lt;code object __init__ at 0x102905580, ...&gt;
print(code.co_consts[0].co_consts[4])  # &lt;code object foo at 0x102906290, ...&gt;
print(code.co_consts[0].co_consts[6])  # &lt;code object bar at 0x1029d8030, ...&gt;
</code></pre>
<p>相信这些内容已经没有什么难度了，总之函数、类在编译之后都会对应一个 PyCodeObject。由于函数、类可以嵌套，那么 PyCodeObject 也是可以嵌套的，并且也会作为一个常量被收集起来，存储在外层的 PyCodeObject 的常量池当中。</p>
<h2 id="自定义类对象的动态元信息"><a class="header" href="#自定义类对象的动态元信息">自定义类对象的动态元信息</a></h2>
<p>自定义类对象的元信息指的就是关于这个类的信息描述，比如名称、所拥有的属性、方法，该类实例化时要为实例对象申请的内存空间大小等。有了这些元信息，才能创建自定义类对象，否则我们是没办法创建的。</p>
<p>注意：元信息是一个非常重要的概念，在很多框架中都会出现。比如说 Hive，数据的元信息就是存储在 MySQL 里面。而在编程语言中，也正是通过元信息才实现了反射等动态特性，尤其是 Python，将元信息的概念发挥地淋漓尽致，因此 Python 也提供了其它编程语言所不具备的高度灵活的动态特征。</p>
<p>我们将类简化一下，看看它的字节码长什么样子。</p>
<pre><code class="language-Python">code_string = &quot;&quot;&quot;
class Girl:

    def foo(self):
        print(&quot;Hi foo&quot;)

    def bar(self):
        print(&quot;Hi bar&quot;)
&quot;&quot;&quot;
code = compile(code_string, &quot;&lt;file&gt;&quot;, &quot;exec&quot;)

for const in code.co_consts:
    print(const)
&quot;&quot;&quot;
&lt;code object Girl at 0x10643e290, ...&gt;
Girl
None
&quot;&quot;&quot;
for const in code.co_consts[0].co_consts:
    print(const)
&quot;&quot;&quot;
Girl
&lt;code object foo at 0x1033d23f0, ...&gt;
Girl.foo
&lt;code object bar at 0x1033d1580, ...&gt;
Girl.bar
None
&quot;&quot;&quot;
</code></pre>
<p>观察一下类的常量池，第一个元素显然是类名，一个字符串；第二和第三个元素则是函数 foo 对应的 PyCodeObject 以及全限定名；第四和第五个元素则是函数 bar 对应的 PyCodeObject 以及全限定名；最后一个是 None，而 None 是一定会有的。</p>
<p>然后是字节码如下：</p>
<pre><code class="language-C">  // 模块对应的字节码
  0 LOAD_BUILD_CLASS
  2 LOAD_CONST               0 (&lt;code object Girl at 0x7f1...&gt;)
  4 LOAD_CONST               1 ('Girl')
  6 MAKE_FUNCTION            0
  8 LOAD_CONST               1 ('Girl')
 10 CALL_FUNCTION            2
 12 STORE_NAME               0 (Girl)
 14 LOAD_CONST               2 (None)
 16 RETURN_VALUE

  // class Girl 对应的字节码
Disassembly of &lt;code object Girl at 0x7f1...&gt;:
  0 LOAD_NAME                0 (__name__)
  2 STORE_NAME               1 (__module__)
  4 LOAD_CONST               0 ('Girl')
  6 STORE_NAME               2 (__qualname__)

  8 LOAD_CONST               1 (&lt;code object foo at 0x7f1...&gt;)
 10 LOAD_CONST               2 ('Girl.foo')
 12 MAKE_FUNCTION            0
 14 STORE_NAME               3 (foo)

 16 LOAD_CONST               3 (&lt;code object bar at 0x7f1...&gt;)
 18 LOAD_CONST               4 ('Girl.bar')
 20 MAKE_FUNCTION            0
 22 STORE_NAME               4 (bar)
 24 LOAD_CONST               5 (None)
 26 RETURN_VALUE

  // Girl.foo 对应的字节码
Disassembly of &lt;code object foo at 0x7f1...&gt;:
  0 LOAD_GLOBAL              0 (print)
  2 LOAD_CONST               1 ('Hi foo')
  4 CALL_FUNCTION            1
  6 POP_TOP
  8 LOAD_CONST               0 (None)
 10 RETURN_VALUE
  
  // Girl.bar 对应的字节码
Disassembly of &lt;code object bar at 0x7f1...&gt;:
  0 LOAD_GLOBAL              0 (print)
  2 LOAD_CONST               1 ('Hi bar')
  4 CALL_FUNCTION            1
  6 POP_TOP
  8 LOAD_CONST               0 (None)
 10 RETURN_VALUE
</code></pre>
<p>结构很清晰，总共 4 个 PyCodeObject，分别对应模块、类 Girl、函数 Girl.foo、函数 Girl.bar。</p>
<p><img src="./images/253.png" alt="" /></p>
<p>下面我们来对字节码逐一分析，首先是模块的字节码：</p>
<pre><code class="language-C">  // 一条新指令，会将内置函数 __build_class__ 压入栈中
  // 至于这个 __build_class__ 是干啥的，一会说
  0 LOAD_BUILD_CLASS
  // 加载 Girl 对应的 PyCodeObject 对象
  2 LOAD_CONST               0 (&lt;code object Girl at 0x7f1...&gt;)
  // 加载字符串 &quot;Girl&quot;
  4 LOAD_CONST               1 ('Girl')
  // 问题来了，我们看到是 MAKE_FUNCTION
  // 不是说要构建类吗？为什么是 MAKE_FUNCTION 呢？
  6 MAKE_FUNCTION            0
  // 再次加载字符串 &quot;Girl&quot;
  8 LOAD_CONST               1 ('Girl')
  // 以构建的 PyFunctionObject 和字符串 &quot;Girl&quot; 为参数
  // 调用 __build_class__，创建一个类
 10 CALL_FUNCTION            2
  // 将创建的类使用变量 Girl 进行保存
 12 STORE_NAME               0 (Girl)
  // 隐式地 return None
 14 LOAD_CONST               2 (None)
 16 RETURN_VALUE
</code></pre>
<p>关键指令是 LOAD_BUILD_CLASS，它的逻辑很简单，就是将内置函数 __build_class__ 压入运行时栈。紧接着通过两个 LOAD_CONST 将 Girl 对应的 PyCodeObject 对象和字符串 &quot;Girl&quot; 压入栈中，再用 MAKE_FUNCTION 将其弹出，构造一个 PyFunctionObject 并入栈。</p>
<p>所以此时栈里面还剩下两个元素，也就是<font color="blue">刚入栈的函数</font>和<font color="blue">内置函数 __build_class__</font>。而这个刚入栈的函数指针，就是基于 Girl 的 PyCodeObject 构建的。不过还是那个问题，Girl 明明是个类，为啥要 MAKE_FUNCTION 呢？接下来的两条指令会告诉你答案。</p>
<p>构建完函数之后又通过 LOAD_CONST 将字符串 &quot;Girl&quot; 压入栈中，显然它代表类名。而此时栈里面有三个元素：</p>
<p><img src="./images/254.png" alt="" /></p>
<p>然后接着执行 CALL_FUNCTION，指令参数是 2。不用想，肯定是以<font color="blue">构建的函数</font>和<font color="blue">字符串&quot;Girl&quot;</font> 为参数，调用 __build_class__。而 __build_class__ 会创建一个类并返回，然后压入运行时栈，最后再通过 STORE_NAME 将创建的类对象使用变量 Girl 保存。</p>
<p>所以类不是上来就构建的，根据 PyCodeObject 和名称构造出来的实际上是一个 PyFunctionObject，尽管使用的是类的 PyCodeObject。当 PyFunctionObject 构造完毕时，再在其之上构造 PyTypeObject，而这一步由 __build_class__ 负责。</p>
<p><img src="./images/255.png" alt="" /></p>
<p>所以，可以得出如下结论：</p>
<pre><code class="language-Python">class A:
    pass

# 在底层将会被翻译成
A = __build_class__(&lt;PyFunctionObject A&gt;, &quot;A&quot;)


# 如果是
class A(int):
    pass
  
# 在底层将会被翻译成
A = __build_class__(&lt;PyFunctionObject A&gt;, &quot;A&quot;, int)
</code></pre>
<p>我们实际操作一下：</p>
<pre><code class="language-python">MyInt = __build_class__(lambda: None, &quot;MyInt&quot;, int)

print(MyInt)  # &lt;class '__main__.MyInt'&gt;
print(MyInt.__base__)  # &lt;class 'int'&gt;
print(MyInt(3) + 5)  # 8
</code></pre>
<p>有点意思。</p>
<p><img src="./images/256.png" alt="" /></p>
<p>如果参数类型不正确的话，会报出如下错误：</p>
<pre><code class="language-python">try:
    __build_class__()
except TypeError as e:
    print(e)
&quot;&quot;&quot;
__build_class__: not enough arguments
&quot;&quot;&quot;

try:
    # 第一个参数 func 必须是函数
    __build_class__(&quot;&quot;, &quot;&quot;)
except TypeError as e:
    print(e)    
&quot;&quot;&quot;
__build_class__: func must be a function
&quot;&quot;&quot;

try:
    # 第二个参数 name 必须是字符串
    __build_class__(lambda: None, 123)
except TypeError as e:
    print(e)

&quot;&quot;&quot;
__build_class__: name is not a string
&quot;&quot;&quot;
</code></pre>
<p>记住这几个报错信息，后面会看到。此外我们也能看出，__build_class__ 的第一个参数叫 func、第二个参数叫 name。总之 __build_class__ 的作用就是将一个函数对象变成一个类对象。</p>
<p>再来看看类对象的字节码：</p>
<pre><code class="language-c">Disassembly of &lt;code object Girl at 0x7f1...&gt;:
  // 将 __name__、即模块的名字压入栈中
  0 LOAD_NAME                0 (__name__)
  // 使用类的 __module__ 进行保存
  // 所以通过类的 __module__，能找到该类属于哪一个模块
  2 STORE_NAME               1 (__module__)
  // 加载字符串 &quot;Girl&quot;
  4 LOAD_CONST               0 ('Girl')
  // 作为类的全限定名
  6 STORE_NAME               2 (__qualname__)
  
  // 加载 Girl.foo 函数的 PyCodeObject 和字符串 &quot;Girl.foo&quot;
  8 LOAD_CONST               1 (&lt;code object foo at 0x7f1...&gt;)
 10 LOAD_CONST               2 ('Girl.foo')
  // 构造函数
 12 MAKE_FUNCTION            0
  // 使用变量 foo 保存
 14 STORE_NAME               3 (foo)
  
  // 和上面构造 foo 类似
 16 LOAD_CONST               3 (&lt;code object bar at 0x7f1...&gt;)
 18 LOAD_CONST               4 ('Girl.bar')
 20 MAKE_FUNCTION            0
 22 STORE_NAME               4 (bar)
 24 LOAD_CONST               5 (None)
 26 RETURN_VALUE
</code></pre>
<p>我们在介绍函数的时候提过：&quot;函数的局部变量是不可变的，在编译的时候就已经确定了，以一种静态的方式存放在 f_localsplus 中。而 f_locals 初始为 NULL，函数里面的局部变量是通过静态的方式来访问的&quot;。</p>
<p>但是类则不一样，类是可以动态修改的，可以随时增加属性、方法，这就意味着类是不可能通过静态方式来查找属性的。事实上也确实如此，类有一个属性字典，而对于类来说，变量是从属性字典中查找的。</p>
<pre><code class="language-python">class Girl:

    def foo(self):
        print(&quot;Hi foo&quot;)

    def bar(self):
        print(&quot;Hi bar&quot;)

print(__name__)  # __main__
print(Girl.__module__)  # __main__
print(Girl.__qualname__)  # Girl
print(Girl.foo is Girl.__dict__[&quot;foo&quot;])  # True
</code></pre>
<p>所以整体过程就是：先将 PyCodeObject 构建成函数，再通过 __build_class__ 将函数变成一个类，当 __build_class__ 结束之后我们的自定义类就破茧而出了。</p>
<p>因此剩下的问题就是 __build_class__ 是如何将一个函数变成类的，想要知道答案，那么只能去源码中一探究竟了。不过在看源码之前，我们还需要了解一样东西：metaclass。</p>
<h2 id="metaclass"><a class="header" href="#metaclass">metaclass</a></h2>
<p>元类，被誉为是深度的魔法，但是个人觉得有点夸张了。首先元类是做什么的，它是用来控制我们自定义类的生成过程的，默认情况下，自定义的类都是由 type 创建的。但是我们可以手动指定某个类的元类，不过在介绍元类之前，我们还需要看一下 Python 的两个特殊的魔法方法：__new__ 和 __init__。</p>
<h3 id="__new__-和-__init__"><a class="header" href="#__new__-和-__init__">__new__ 和 __init__</a></h3>
<p>类在实例化的时候会自动调用 __init__，但其实在调用 __init__ 之前会先调用 __new__。</p>
<ul>
<li>__new__：为实例对象申请一片内存；</li>
<li>__init__：为实例对象设置属性；</li>
</ul>
<pre><code class="language-Python">class A:

    def __new__(cls, *args, **kwargs):
        print(&quot;__new__&quot;)

    def __init__(self):
        print(&quot;__init__&quot;)

A()
&quot;&quot;&quot;
__new__
&quot;&quot;&quot;
</code></pre>
<p>然而我们看到只有 __new__ 被调用了，__init__ 则没有。原因就在于 __new__ 里面必须将 A 的实例对象返回，才会执行 __init__，并且执行的时候会自动将 __new__ 的返回值作为参数传给 __init__ 当中的 self。</p>
<pre><code class="language-Python">class A:

    def __new__(cls, *args, **kwargs):
        print(&quot;__new__&quot;)
        # 这里的参数 cls 就表示 A 这个类本身
        # object.__new__(cls) 便是根据 cls 创建 cls 的实例对象
        return object.__new__(cls)

    def __init__(self):
        # 然后执行 __init__，里面的 self 指的就是实例对象
        # 执行 __init__ 时，__new__ 的返回值会自动作为参数传递给 self
        print(&quot;__init__&quot;)

A()
&quot;&quot;&quot;
__new__
__init__
&quot;&quot;&quot;
</code></pre>
<p>所以一个对象是什么，取决于其类型对象的 __new__ 返回了什么。</p>
<pre><code class="language-Python">class A:

    def __new__(cls, *args, **kwargs):
        print(&quot;__new__&quot;)
        # 这里必须返回 A 的实例对象，否则 __init__ 函数是不会执行的
        return 123

    def __init__(self):
        print(&quot;__init__&quot;)

a = A()
print(a + 1)
&quot;&quot;&quot;
__new__
124
&quot;&quot;&quot;
</code></pre>
<p>我们看到 A 在实例化之后得到的是一个整数，原因就是 __new__ 返回了 123。</p>
<h3 id="创建类的另一种方式"><a class="header" href="#创建类的另一种方式">创建类的另一种方式</a></h3>
<p>创建类的时候除了通过 class 关键字之外，我们还可以使用 type 这个古老却又强大的类来创建。</p>
<pre><code class="language-python"># type 这个类里面可以接收一个参数或者三个参数
# 如果接收一个参数，那么表示查看类型
# 如果接收三个参数，那么表示创建一个类
try:
    A = type(&quot;A&quot;, &quot;&quot;)
except Exception as e:
    print(e)  # type() takes 1 or 3 arguments
</code></pre>
<p>查看类型就不说了，下面看看如何用 type 创建一个类：</p>
<pre><code class="language-Python"># type 接收三个参数：类名、继承的基类、属性
class A(list):
    name = &quot;古明地觉&quot;

# 上面这个类翻译过来就是
A = type(&quot;A&quot;, (list,), {&quot;name&quot;: &quot;古明地觉&quot;})
print(A)  # &lt;class '__main__.A'&gt;
print(A.__name__)  # A
print(A.__base__)  # &lt;class 'list'&gt;
print(A.name)  # 古明地觉
</code></pre>
<p>所以还是很简单的，我们还可以自定义一个类继承 type。</p>
<pre><code class="language-Python">class MyType(type):
    def __new__(mcs, name, bases, attr):
        print(name)
        print(bases)
        print(attr)

# 指定 metaclass，表示 A 这个类由 MyType 创建
# 我们说 __new__ 是为实例对象开辟内存的
# 那么 MyType 的实例对象是谁呢？显然就是这里的 A
# 因为 A 指定了 metaclass 为 MyType，所以 A 的类型就是 MyType
class A(int, object, metaclass=MyType):
    name = &quot;古明地觉&quot;
&quot;&quot;&quot;
A
(&lt;class 'int'&gt;, &lt;class 'object'&gt;)
{'__module__': '__main__', '__qualname__': 'A', 'name': '古明地觉'}
&quot;&quot;&quot;
# 我们看到一个类在创建的时候会向元类的 __new__ 中传递三个值
# 分别是类名、继承的基类、类的属性
# 但此时 A 并没有被创建出来
print(A)  # None
</code></pre>
<p>我们说 __new__ 一定要将创建的实例对象返回才可以，这里的 MyType 是元类，所以类对象 A 就是 MyType 的实例对象，MyType 的 __new__ 就负责为类对象 A 分配空间。但是显然这里并没有分配，而且返回的还是一个 None，如果我们返回的是 123，那么 print(A) 就是 123。</p>
<pre><code class="language-python">class MyType(type):
    def __new__(mcs, name, bases, attr):
        return []

class A(metaclass=MyType):
    pass

# A 是由 MyType 生成的，MyType 返回的是 []
# 因此 A 就是 []
print(A)  # []
</code></pre>
<p>所以<font color="blue">元类和类的关系</font>与<font color="blue">类和实例对象的关系</font>，之间是很相似的，因为完全可以把类对象看成是元类的实例对象。因此 A 既然指定了 metaclass 为 MyType，就表示 A 这个类由 MyType 创建，那么 MyType 的 __new__ 函数返回了什么，A 就是什么。</p>
<pre><code class="language-Python">class MyType(type):

    def __new__(mcs, name, bases, attr):
        return &quot;嘿嘿嘿&quot;

class A(metaclass=MyType):
    pass

print(A + &quot;哟哟哟&quot;)  # 嘿嘿嘿哟哟哟
</code></pre>
<p>这便是 Python 语言具备的高度动态特性，那么问题来了，如果我想把 A 创建出来、像普通的类一样使用的话，该咋办呢？因为默认情况下类由 type 创建，底层帮你做好了，但现在则需要我们来手动指定。</p>
<p>显然，这里创建还是要依赖于 type，只不过需要我们手动指定，而且在手动指定的同时还可以增加一些我们自己的操作。</p>
<pre><code class="language-python">class MyType(type):

    def __new__(mcs, name, bases, attr):
        name = name * 2
        bases = (list,)
        attr.update({&quot;name&quot;: &quot;古明地觉&quot;, &quot;nickname&quot;: &quot;小五萝莉&quot;})

        # 这里直接交给 type 即可，然后 type 来负责创建
        # 所以 super().__new__ 实际上会调用 type.__new__
        return super().__new__(mcs, name, bases, attr)
        # 但是我们将第一个参数换成了 mcs，就是这里的 MyType
        # 等价于 type.__new__(mcs, name, bases, attr)，表示将元类指定为 MyType
        # 注意：不能写 type(name, bases, attr)，因为这样的话类还是由 type 创建的
        # type(name, bases, attr) 等价于 type.__new__(type, name, bases, attr)

class Girl(metaclass=MyType):
    pass

# 我们看到类的名字变了，默认情况下是 &quot;Girl&quot;
# 但创建的时候将 name 乘了个 2
print(Girl.__name__)  # GirlGirl

# 显然 Girl 也继承 list
print(Girl(&quot;你好呀&quot;))  # ['你', '好', '呀']

# 同理 Girl 还有两个属性
print(Girl.name, Girl.nickname)  # 古明地觉 小五萝莉
</code></pre>
<p>记得前面说过，一个类在没有指定 metaclass 的时候，如果它的父类指定了，那么这个类的 metaclass 等于父类的 metaclass。</p>
<pre><code class="language-python">class MyType(type):

    def __new__(mcs, name, bases, attr):
        name = name * 2
        bases = (list,)
        attr.update({&quot;name&quot;: &quot;古明地觉&quot;, &quot;nickname&quot;: &quot;小五萝莉&quot;})
        return super().__new__(mcs, name, bases, attr)

class Girl(metaclass=MyType):
    pass

class A(Girl):
    pass
 
print(A.__class__)  # &lt;class '__main__.MyType'&gt;
print(A.__name__)  # AA
</code></pre>
<p>并且当时还举了个 flask 的例子，提到了一种更加优雅的写法。</p>
<pre><code class="language-Python">class MyType(type):

    def __new__(mcs, name, bases, attr):
        return super().__new__(mcs, name, bases, attr)

def with_metaclass(meta, bases):
    return meta(&quot;tmp&quot;, bases, {&quot;gender&quot;: &quot;female&quot;})


# with_metaclass(MyType, (list,)) 会返回一个类
# 这个类由 MyType 创建，并且继承自 list
# 那么 Girl 再继承这个类，等价于 Girl 也由 MyType 创建
class Girl(with_metaclass(MyType, (list,))):
    pass

print(Girl.__class__)  # &lt;class '__main__.MyType'&gt;
# 所以 with_metaclass(meta, bases) 本身没有太大意义，只是为了帮助我们找到元类和继承的类
# 但毕竟继承它了，就意味着也可以找到它的属性
print(Girl.gender)  # female
</code></pre>
<p>注意：我们说负责创建类对象的是元类，而元类要么是 type、要么是继承自 type 的子类。</p>
<pre><code class="language-Python">class MyType(type):

    def __new__(mcs, name, bases, attr):
        return super().__new__(mcs, name, bases, attr)

# type 直接加括号表示由 type 创建，所以需要通过 __new__ 手动指定
# 并且将 __new__ 的第一个参数换成 MyType
Girl = type.__new__(MyType,
                    &quot;GirlGirlGirl&quot;,
                    (list,),
                    {&quot;add&quot;: lambda self, value: value + 123})

print(Girl.__name__)  # GirlGirlGirl

g = Girl()
print(g.add(123))  # 246

try:
    type.__new__(int, &quot;A&quot;, (object,), {})
except TypeError as e:
    # 指定为 int 则报错，告诉我们 int 不是 type 的子类
    # 因为只有两种情况：要么是 type、要么是 type 的子类
    print(e)  # type.__new__(int): int is not a subtype of type
</code></pre>
<p>怎么样，是不是觉得元类很简单呢？其实元类没有什么复杂的，只需要把元类和类对象之间的关系，想象成类对象和实例对象即可。类对象的 __new__ 里面返回了啥，实例就是啥。那么同理，元类的 __new__ 里面返回了啥，类对象就是啥。</p>
<p>为了更好地理解这一点，我们再举个栗子：</p>
<pre><code class="language-Python">class MyType(type):
    def __new__(mcs, name, bases, attr):
        if &quot;foo&quot; in attr:
            attr.pop(&quot;foo&quot;)
        return super().__new__(mcs, name, bases, attr)


class Girl(metaclass=MyType):

    def foo(self):
        return &quot;foo&quot;

    def bar(self):
        return &quot;bar&quot;

print(Girl().bar())  # bar

try:
    print(Girl().foo())
except AttributeError as e:
    print(e)  # 'Girl' object has no attribute 'foo'
</code></pre>
<p>惊了，我们看到居然没有 foo 这个属性，我们明显定义了啊，显然原因就是我们在创建类的时候将其 pop 掉了。首先创建一个类需要三个元素：类名、继承的基类、类的一些属性（以字典的形式），然后会将这三个元素交给元类进行创建。但是我们在创建的时候偷偷地将 foo 从 attr 里面给 pop 掉了，因此创建出来的类是没有 foo 这个成员函数的。</p>
<p>元类确实蛮有趣的，而且也没有想象中的那么难，可以多了解一下。基于元类，我们可以实现很多高级操作，可以让代码逻辑变得更加优雅。</p>
<h3 id="特殊的魔法函数"><a class="header" href="#特殊的魔法函数">特殊的魔法函数</a></h3>
<p>此外我们再来看两个和元类有关的魔法函数，分别是 __prepared__ 和 __init_sublcass__，先来看第一个。</p>
<pre><code class="language-Python">class MyType(type):

    @classmethod
    def __prepare__(mcs, name, bases):
        print(&quot;__prepared__&quot;)
        # 必须返回一个 mapping，至于它是干什么的我们后面说
        return {}

    def __new__(mcs, name, bases, attr):
        print(&quot;__new__&quot;)
        return super().__new__(mcs, name, bases, attr)


class Girl(metaclass=MyType):
    pass

&quot;&quot;&quot;
__prepared__
__new__
&quot;&quot;&quot;
</code></pre>
<p>我们看到 __prepare__ 会在 __new__ 之前被调用，那么它是做什么的呢？答案是添加属性，我们解释一下。</p>
<pre><code class="language-Python">class MyType(type):

    @classmethod
    def __prepare__(mcs, name, bases):
        return {&quot;name&quot;: &quot;古明地觉&quot;}

    def __new__(mcs, name, bases, attr):
        return super().__new__(mcs, name, bases, attr)


class Girl(metaclass=MyType):
    pass

print(Girl.name)  # 古明地觉
</code></pre>
<p>现在应该知道 __prepare__ 是干什么的了，它接收一个 name、一个 bases，返回一个 mapping。我们知道 name、bases、attr 会传递给 __new__，但是在 __new__ 之前会先经过 __prepared__。而 __prepared__ 会返回一个映射，假设叫 m，那么会将 attr 和 m 合并，相当于执行了 attr.update(m)，然后再将 name、bases、attr 交给 __new__。</p>
<p>此外 __prepared__ 这个方法是被 @classmethod 装饰的，并且里面一定要返回一个 mapping，否则报错：TypeError: MyType.__prepared__() must return a mapping, not xxx。</p>
<p>说完了 __prepare__ 之后，再来看看 __init_sublcass__，它类似于一个钩子函数，在一些简单的场景下可以代替元类。</p>
<pre><code class="language-Python">class Base:

    def __init_subclass__(cls, **kwargs):
        print(cls)
        print(kwargs)

# 当类被创建的时候，会触发其父类的__init_subclass__
class A(Base):
    pass
&quot;&quot;&quot;
&lt;class '__main__.A'&gt; 
{}
&quot;&quot;&quot;

class B(Base, name=&quot;古明地觉&quot;, age=16):
    pass

&quot;&quot;&quot;
&lt;class '__main__.B'&gt; 
{'name': '古明地觉', 'age': 16}
&quot;&quot;&quot;
</code></pre>
<p>所以父类的 __init_sublcass__ 里面的 cls 并不是父类本身，而是继承它的类。kwargs 就是额外设置的一些属性，因此我们可以实现一个属性添加器。</p>
<pre><code class="language-Python">class Base:

    def __init_subclass__(cls, **kwargs):
        for k, v in kwargs.items():
            setattr(cls, k, v)

class A(Base, name=&quot;古明地觉&quot;, age=16,
        __str__=lambda self: &quot;hello world&quot;):
    pass


print(A.name, A.age)  # 古明地觉 16
print(A())  # hello world
</code></pre>
<p>当然除了属性添加器，我们还可以实现一个属性拦截器。</p>
<pre><code class="language-Python">class Base:

    def __init_subclass__(cls, **kwargs):
        if hasattr(cls, &quot;shit&quot;) and hasattr(cls.shit, &quot;__code__&quot;):
            raise Exception(f&quot;{cls.__name__} 不允许定义 'shit' 函数&quot;)

class A(Base):
    def shit(self):
        pass
&quot;&quot;&quot;
Traceback (most recent call last):
  File &quot;...&quot;, line 9, in &lt;module&gt;
    class A(Base):
  File &quot;...&quot;, line 5, in __init_subclass__
    raise Exception(f&quot;{cls.__name__} 不允许定义 'shit' 函数&quot;)
Exception: A 不允许定义 'shit' 函数
&quot;&quot;&quot;
</code></pre>
<p>以上就是元类相关的知识，记得在前面的文章中已经说过了，这里再啰嗦一遍，这样一会儿看源码的时候会轻松一些。</p>
<h2 id="源码解密类的创建过程"><a class="header" href="#源码解密类的创建过程">源码解密类的创建过程</a></h2>
<p>回顾一下类是怎么创建的，首先会通过指令 LOAD_BUILD_CLASS 将内置函数 __build_class__ 压入运行时栈，然后将类对应的 PyCodeObject 包装成一个 PyFunctionObject，最后再调用 __build_class__ 将 PyFunctionObject 变成 PyTypeObject，也就是我们使用的类对象。</p>
<pre><code class="language-python">class A: pass
class B: pass
class C: pass
class D: pass
class E: pass
class F: pass

MyClass = __build_class__(lambda: None, &quot;MyClass&quot;, A, B, C, D, E, F)
print(MyClass)  # &lt;class '__main__.MyClass'&gt;

for cls in MyClass.__mro__:
    print(cls)
    &quot;&quot;&quot;
    &lt;class '__main__.MyClass'&gt;
    &lt;class '__main__.A'&gt;
    &lt;class '__main__.B'&gt;
    &lt;class '__main__.C'&gt;
    &lt;class '__main__.D'&gt;
    &lt;class '__main__.E'&gt;
    &lt;class '__main__.F'&gt;
    &lt;class 'object'&gt;
    &quot;&quot;&quot;
</code></pre>
<p>我们以运行时栈的变化，来描述一下上述过程：</p>
<p><img src="./images/257.png" alt="" /></p>
<p>那么接下来的重点就是 __build_class__，它是如何将一个函数变成类的，我们来看一下。内置函数的相关实现，位于 Python/bitinmodule.c 中。</p>
<p><img src="./images/258.png" alt="" /></p>
<p>builtins 是一个模块，__build_class__ 是该模块里的一个函数，所以它位于 PyModuleDef 的 m_methods 字段中。关于模块的相关细节后续聊，总之我们看到 __build_class__ 在底层对应 builtin__build_class__。</p>
<pre><code class="language-C">static PyObject *
builtin___build_class__(PyObject *self, PyObject *const *args, Py_ssize_t nargs,
                        PyObject *kwnames)
{
    PyObject *func, *name, *bases, *mkw, *meta, *winner, *prep, *ns, *orig_bases;
    PyObject *cls = NULL, *cell = NULL;
    int isclass = 0;   /* initialize to prevent gcc warning */
    // class A: 会被翻译成 builtin.__build_class__(PyFunctionObject, &quot;A&quot;)
    // 所以这个函数至少需要两个参数
    if (nargs &lt; 2) {
        // 参数不足，报错，还记得这个报错信息吗？之前测试过的
        PyErr_SetString(PyExc_TypeError,
                        &quot;__build_class__: not enough arguments&quot;);
        return NULL;
    }
    // 类对应的 PyFunctionObject
    func = args[0];   /* Better be callable */
    if (!PyFunction_Check(func)) {
        // 如果不是 PyFunctionObject，报错
        PyErr_SetString(PyExc_TypeError,
                        &quot;__build_class__: func must be a function&quot;);
        return NULL;
    }
    // 类对应的名字，__build_class__ 的时候，类肯定要有名字
    name = args[1];
    if (!PyUnicode_Check(name)) {
        // 必须是一个 PyUnicodeObject，否则报错
        PyErr_SetString(PyExc_TypeError,
                        &quot;__build_class__: name is not a string&quot;);
        return NULL;
    }
    // args[0]表示 PyFunctionObject *，args[1] 表示 class name
    // 从 args + 2 开始是继承的基类，至于个数显然是 nargs - 2，所以这里是拿到所有的基类
    orig_bases = _PyTuple_FromArray(args + 2, nargs - 2);
    if (orig_bases == NULL)
        return NULL;
    // 这个 update_bases 比较有趣，我们一会儿单独说
    bases = update_bases(orig_bases, args + 2, nargs - 2);
    if (bases == NULL) {
        Py_DECREF(orig_bases);
        return NULL;
    }
    // 获取 metaclass
    if (kwnames == NULL) {
        meta = NULL;
        mkw = NULL;
    }
    else {
        mkw = _PyStack_AsDict(args + nargs, kwnames);
        if (mkw == NULL) {
            Py_DECREF(bases);
            return NULL;
        }

        meta = _PyDict_GetItemIdWithError(mkw, &amp;PyId_metaclass);
        if (meta != NULL) {
            Py_INCREF(meta);
            if (_PyDict_DelItemId(mkw, &amp;PyId_metaclass) &lt; 0) {
                Py_DECREF(meta);
                Py_DECREF(mkw);
                Py_DECREF(bases);
                return NULL;
            }
            /* metaclass is explicitly given, check if it's indeed a class */
            isclass = PyType_Check(meta);
        }
        else if (PyErr_Occurred()) {
            Py_DECREF(mkw);
            Py_DECREF(bases);
            return NULL;
        }
    }
    // 如果 meta 为 NULL，这意味着没有指定 metaclass
    if (meta == NULL) {
        // 然后尝试获取基类，如果没有基类，那么元类就是 &amp;PyType_Type
        if (PyTuple_GET_SIZE(bases) == 0) {
            meta = (PyObject *) (&amp;PyType_Type);
        }
        // 否则获取第一个继承的基类的 metaclass
        else {
            // 拿到第一个基类
            PyObject *base0 = PyTuple_GET_ITEM(bases, 0);
            // 拿到第一个基类的 __class__
            meta = (PyObject *) (base0-&gt;ob_type);
        }
        // meta 也是一个类
        Py_INCREF(meta);
        isclass = 1;
    }
  
    // 如果设置了元类，那么 isclass 为 1，if 为真
    if (isclass) {
        // 选择出了元类，下面这一步就要解决元类冲突
        // 假设有两个继承 type 的元类 MyType1 和 MyType2
        // 然后 Base1 的元类是 MyType1，而 Base2 的元类是 MyType2
        // 那么如果 class A(Base1, Base2) 的话，就会报错
        // 因为在 Python 中有一个要求，假设 class A(Base1, Base2, ..., BaseN)
        // Base1 的元类叫 MyType1、...、BaseN 的元类叫 MyTypeN
        // 那么必须满足：
        /*
        MyType1 是 MyType2 的子类或者父类;
        MyType1 是 MyType3 的子类或者父类;
        MyType1 是 MyType4 的子类或者父类;
        ....
        MyType1 是 MyTypeN 的子类或者父类;
        */
        // 而之所以存在这一限制，原因是为了避免属性冲突
        winner = (PyObject *)_PyType_CalculateMetaclass((PyTypeObject *)meta,
                                                        bases);
        if (winner == NULL) {
            Py_DECREF(meta);
            Py_XDECREF(mkw);
            Py_DECREF(bases);
            return NULL;
        }
        if (winner != meta) {
            Py_DECREF(meta);
            meta = winner;
            Py_INCREF(meta);
        }
    }
    // 寻找 __prepare__
    if (_PyObject_LookupAttrId(meta, &amp;PyId___prepare__, &amp;prep) &lt; 0) {
        ns = NULL;
    }
    // 如果 __prepare__ 为 NULL，那么等价于返回一个空字典
    else if (prep == NULL) {
        ns = PyDict_New();
    }
    else {
        // 否则调用 __prepare__，将字典返回
        PyObject *pargs[2] = {name, bases};
        ns = _PyObject_FastCallDict(prep, pargs, 2, mkw);
        Py_DECREF(prep);
    }
    if (ns == NULL) {
        Py_DECREF(meta);
        Py_XDECREF(mkw);
        Py_DECREF(bases);
        return NULL;
    }
    // 如果 __prepare__ 返回的不是一个字典，那么报错，这个错误信息我们也见过了
    if (!PyMapping_Check(ns)) {
        PyErr_Format(PyExc_TypeError,
                     &quot;%.200s.__prepare__() must return a mapping, not %.200s&quot;,
                     isclass ? ((PyTypeObject *)meta)-&gt;tp_name : &quot;&lt;metaclass&gt;&quot;,
                     Py_TYPE(ns)-&gt;tp_name);
        goto error;
    }
    // ...
    return cls;
}
</code></pre>
<p>可以看到，一个简单的类定义，虚拟机究竟做了多少事情啊，不过显然这还没完。自定义类对象的元信息分为两部分，分别是动态元信息和静态元信息。虚拟机在获得了属性表（动态元信息）之后，就知道了所有的属性。</p>
<p>但对于自定义类对象的类型是什么，应该如何创建、要分配多少内存，却没有任何的头绪，因为这部分隐藏在 metaclass 里面。</p>
<p>而在 builtin___build_class__中，metaclass 正是关于自定义类对象的另一部分元信息，我们称之为静态元信息。在静态元信息中，隐藏着所有的类对象应该如何创建的信息，注意：是所有的类对象。从源码中我们可以看到，如果指定了 metaclass，那么会选择指定的 metaclass；如果没有指定，那么会使用第一个继承的基类的 metaclass 作为该 class 的 metaclass。</p>
<p>对于实例对象，所有的元信息都存储在对应的类对象中。但是对于类对象来说，其元信息的静态元信息存储在对应的元类中，动态元信息则存储在本身的 local 名字空间中。</p>
<p>可为什么这么做呢？为什么对于类对象来说，其元信息要游离成两部分呢？都存在 metaclass 里面不香吗？这是因为用户在 .py 文件中可以定义不同的 class，这个元信息必须、且只能是动态的，所以它不适合保存在 metaclass 中。而存储在 metaclass 里面的，一定是诸如类对象的创建策略等所有 class 都会共用的元信息。</p>
<p>注意：我们说元信息游离成两部分指的是自定义类对象，内置类对象的元信息都存储在 metaclass 中。</p>
<p>因为内置类对象是静态提供的，它们都具备相同的接口集合（底层都是 PyTypeObject 结构体实例），支持什么操作一开始就定义好了。只不过有的可以用，有的不能用。比如 PyLongObject 可以使用 nb_add，但是 PyDictObject 不能，而 PyDictObject 可以使用 mp_subscript，但是 PyLongObject 不可以。</p>
<p>尽管如此，但这不影响它们的所有元信息都存储在元类中。而用户自定义的类对象，接口是动态的，不可能在 metaclass 中静态指定。</p>
<h3 id="update_bases"><a class="header" href="#update_bases">update_bases</a></h3>
<p>然后再来说一说源码中的 update_bases，它比较有意思。</p>
<pre><code class="language-Python">class Foo:
    name = &quot;古明地觉&quot;

class Bar:
    def __mro_entries__(self, bases):
        return Foo, tuple

class MyClass(Bar()):
    pass

print(MyClass(&quot;123&quot;))  # ('1', '2', '3')
print(MyClass.name)  # 古明地觉
</code></pre>
<p>我们在继承的时候，都是继承一个类，但是这里的 MyClass 居然继承了一个实例对象。相信结果你已经猜出来了，如果继承的是实例，那么会去调用实例的 <code>__mro_entries__</code>。因此 MyClass 继承的其实是 Foo、tuple，并且 <code>__mro_entries__</code> 必须返回一个元组，否则报错。</p>
<p>另外，如果一个类继承了一个拥有 <code>__mro_entries__</code> 的实例，那么该类会多出一个属性叫 <code>__orig_bases__</code>。我们回顾一下 builtin___build_class__ 里面的几行关键代码：</p>
<p><img src="./images/259.png" alt="" /></p>
<p>里面有两个变量 orig_bases 和 bases，我们知道 Python 的类都有 __bases__ 属性，对应这里的 bases；但鲜为人知的是，它还有一个属性叫 __orig_bases__，对应这里的 orig_bases。</p>
<pre><code class="language-Python">class Foo:
    name = &quot;古明地觉&quot;

class Bar:

    def __mro_entries__(self, bases):
        return Foo, tuple

class MyClass(Bar()):
    pass

print(MyClass.__orig_bases__)
print(MyClass.__bases__)
&quot;&quot;&quot;
(&lt;__main__.Bar object at 0x0000014FCC387E80&gt;,)
(&lt;class '__main__.Foo'&gt;, &lt;class 'tuple'&gt;)
&quot;&quot;&quot;
</code></pre>
<p>__orig_bases__ 和 __bases__ 的区别显而易见，__orig_bases__ 在经过 update_bases 函数处理之后，得到的就是 __bases__。</p>
<p>__orig_bases__ 表示继承的对象，该对象可以是一个类对象，也可以是一个实例对象；如果是实例对象，那么在 update_bases 函数中，会调用它的 <code>__mro_entries__</code> 方法，该方法返回一个包含类对象的元组，然后设置到 __bases__ 中。</p>
<p>以上就是函数 update_bases 的作用，但有两点需要注意。</p>
<ul>
<li>1）只有继承了拥有 <code>__mro_entries__</code> 方法的实例的类，才有 __orig_bases__ 属性；</li>
<li>2）这样的类，在 Python 里面不能手动调用 type 来创建；</li>
</ul>
<p>我们来解释一下，首先是第一点：</p>
<pre><code class="language-python">print(hasattr(MyClass, &quot;__orig_bases__&quot;))
print(hasattr(Foo, &quot;__orig_bases__&quot;))
print(hasattr(Bar, &quot;__orig_bases__&quot;))
&quot;&quot;&quot;
True
False
False
&quot;&quot;&quot;
</code></pre>
<p>我们看到只有 MyClass 有 __orig_bases__ 属性，因为它继承了拥有 <code>__mro_entries__</code> 方法的实例，而 Foo 和 Bar 则没有。</p>
<p>然后是第二点，这样的类不可以手动调用 type 来创建。</p>
<pre><code class="language-Python">class Foo:
    name = &quot;古明地觉&quot;

class Bar:
    def __mro_entries__(self, bases):
        return Foo, tuple

try:
    MyClass = type(&quot;MyClass&quot;, (Bar(),), {})
except TypeError as e:
    print(e)  # type() doesn't support MRO entry resolution; use types.new_class()

# 所以这样的类应该通过 class 关键字创建
# 如果必须手动创建的话，那么可以使用 types.new_class
import types
MyClass = types.new_class(&quot;MyClass&quot;, (Bar(),), {})
print(MyClass.name)  # 古明地觉
print(MyClass(&quot;123&quot;))  # ('1', '2', '3')
</code></pre>
<p>以上就是 update_bases 函数所干的事情，但是问题来了，如果继承的实例对象没有 <code>__mro_entries__</code> 方法怎么办？</p>
<pre><code class="language-Python">class Base:

    def __init__(self, *args):
        if len(args) == 0:
            return
        elif len(args) == 3:
            name, bases, attrs = args
        else:
            raise ValueError(&quot;args 的长度必须是 0 或 3&quot;)
        self.name = name
        self.bases = bases
        self.attrs = attrs

base = Base()

class MyClass(base):
    pass

print(type(MyClass) is Base)  # True
print(MyClass.name)  # MyClass
print(MyClass.bases == (base,))  # True
print(MyClass.attrs)  # {'__module__': '__main__', '__qualname__': 'MyClass'}
</code></pre>
<p>显然 MyClass 继承的是 Base 的实例对象，并且 Base 里面也没有定义 <code>__mro_entries__</code>，那么虚拟机就不会再使用 type 来创建 MyClass 了。而是会使用 Base 来创建，所以得到的 MyClass 就是一个 Base 的实例对象。</p>
<p>现在算是彻底理解 update_bases 的作用了，因为不能保证继承的都是类，所以还需要进行检测，如果不是类，那么就执行上面的逻辑。但是说实话，这个特性几乎不用，因为既然要继承，那么就应该继承类。虽然通过 <code>__mro_entries__</code> 可以整一些花活，甚至也能简化逻辑，但最好还是不要用，因为它会让代码变得难以理解。</p>
<h3 id="type_call"><a class="header" href="#type_call">type_call</a></h3>
<p>builtin___build_class__ 的逻辑我们上面省略了一部分，至于省略部分的逻辑也很简单，既然元类以及相关参数都准备好了，那么接下来就是对类进行创建了。</p>
<p>我们知道调用一个对象，本质上会执行其类对象的 __call__。所以调用类对象创建实例对象，会执行 type.__call__(cls, ...)。调用元类创建类对象，会执行 type.__call__(type, ...)，因为元类的类对象还是它本身。所以不管调用的是元类、还是类对象，都会执行元类的 __call__，在底层对应 &amp;PyType_Type 的 tp_call 字段，它指向了 type_call 函数。</p>
<pre><code class="language-C">// Objects/typeobject.c
static PyObject *
type_call(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyObject *obj;
    // tp_new 负责创建实例，所以它不能为空
    if (type-&gt;tp_new == NULL) {
        PyErr_Format(PyExc_TypeError,
                     &quot;cannot create '%.100s' instances&quot;,
                     type-&gt;tp_name);
        return NULL;
    }
    // 调用 tp_new 为实例对象申请内存
    obj = type-&gt;tp_new(type, args, kwds);
    // 确保返回值符合 Python 的调用约定
    obj = _Py_CheckFunctionResult((PyObject*)type, obj, NULL);
    if (obj == NULL)
        return NULL;
    // 如果调用的是 &amp;PyType_Type，并且只接收了一个位置参数
    // 那么显然是查看对象类型，执行完 __new__ 之后直接返回
    if (type == &amp;PyType_Type &amp;&amp;
        PyTuple_Check(args) &amp;&amp; PyTuple_GET_SIZE(args) == 1 &amp;&amp;
        (kwds == NULL ||
         (PyDict_Check(kwds) &amp;&amp; PyDict_GET_SIZE(kwds) == 0)))
        return obj;

    // 记得我们之前说过，__new__ 里面一定要返回类的实例对象
    // 否则是不会执行 __init__ 函数的，从这里我们也看到了
    // 如果 obj 的类型不是对应的类、或者其子类，那么直接返回
    if (!PyType_IsSubtype(Py_TYPE(obj), type))
        return obj;
    //然后获取 obj 的类型
    type = Py_TYPE(obj);
    // 如果内部存在 __init__ 函数，那么执行
    if (type-&gt;tp_init != NULL) {
        int res = type-&gt;tp_init(obj, args, kwds);
        if (res &lt; 0) {
            assert(PyErr_Occurred());
            Py_DECREF(obj);
            obj = NULL;
        }
        else {
            assert(!PyErr_Occurred());
        }
    }
    // 执行完构造函数之后，再将对象返回
    // 返回的 obj 可以是类对象、也可以是实例对象
    return obj;
}
</code></pre>
<p>type_call 里面的逻辑非常简单，就是先调用对象的 tp_new 创建实例，然后执行 tp_init（如果有）。至于返回的是类对象还是实例对象，则取决于 type_call 的第一个参数，如果第一个参数是元类，那么返回的就是类对象，否则是实例对象。因此创建的核心逻辑就隐藏在对象的 tp_new 中，不同对象的 tp_new 指向的函数不同。但对于创建类对象而言，显然执行的是 &amp;PyType_Type 的 tp_new，它指向的是 type_new 函数。</p>
<p>这个 type_new 就是我们创建自定义类对象的第一案发现场，源码位于 typeobject.c 中。这个函数的代码比较长，我们会有删减，像那些检测的代码就省略掉了。</p>
<pre><code class="language-C">static PyObject *
type_new(PyTypeObject *metatype, PyObject *args, PyObject *kwds)
{
    // 都是类的一些动态元信息
    PyObject *name, *bases = NULL, *orig_dict, *dict = NULL;
    PyObject *qualname, *slots = NULL, *tmp, *newslots, *cell;
    PyTypeObject *type = NULL, *base, *tmptype, *winner;
    PyHeapTypeObject *et;
    PyMemberDef *mp;
    Py_ssize_t i, nbases, nslots, slotoffset, name_size;
    int j, may_add_dict, may_add_weak, add_dict, add_weak;
    _Py_IDENTIFIER(__qualname__);
    _Py_IDENTIFIER(__slots__);
    _Py_IDENTIFIER(__classcell__);

    //如果 metatype 是 &lt;class 'type'&gt; 的话
    if (metatype == &amp;PyType_Type) {
        // 获取位置参数和关键字参数个数
        const Py_ssize_t nargs = PyTuple_GET_SIZE(args);
        const Py_ssize_t nkwds = kwds == NULL ? 0 : PyDict_GET_SIZE(kwds);
        // 位置参数的个数为 1，关键字参数的个数为 0，你想到了什么？是不是 type(xxx) 呢
        if (nargs == 1 &amp;&amp; nkwds == 0) {
            PyObject *x = PyTuple_GET_ITEM(args, 0);
            Py_INCREF(Py_TYPE(x));
            // 这显然是初学 Python 时就知道的，查看一个变量指向的对象的类型
            return (PyObject *) Py_TYPE(x);
        }

        // 如果上面的 if 不满足，会走这里，表示现在不再是查看类型了，而是创建类
        // 那么要求位置参数必须是 3 个，否则报错
        if (nargs != 3) {
            PyErr_SetString(PyExc_TypeError,
                            &quot;type() takes 1 or 3 arguments&quot;);
            return NULL;
        }
    }

    // 确定参数类型，因为传递的三个参数是有类型要求的
    // 必须是 PyUnicodeObject、PyTupleObject、PyDictObject
    if (!PyArg_ParseTuple(args, &quot;UO!O!:type.__new__&quot;, &amp;name, &amp;PyTuple_Type,
                          &amp;bases, &amp;PyDict_Type, &amp;orig_dict))
        return NULL;

    // 处理基类
    nbases = PyTuple_GET_SIZE(bases);
    // 如果没有继承基类，那么会默认继承 object
    // 所以将 __base__ 设置为 object，将 __bases__ 设置为 (object,)
    if (nbases == 0) {
        base = &amp;PyBaseObject_Type;
        bases = PyTuple_Pack(1, base);
        if (bases == NULL)
            return NULL;
        nbases = 1;
    }
    else {
        _Py_IDENTIFIER(__mro_entries__);
        // 如果继承了基类，那么循环遍历 bases
        for (i = 0; i &lt; nbases; i++) {
            // 拿到每一个基类
            tmp = PyTuple_GET_ITEM(bases, i);
            // 如果基类的类型为 &amp;PyType_Type，进行下一次循环
            if (PyType_Check(tmp)) {
                continue;
            }
            // 如果基类的类型不是 &amp;PyType_Type，说明继承的不是类
            // 于是寻找 __mro_entries__
            if (_PyObject_LookupAttrId(tmp, &amp;PyId___mro_entries__, &amp;tmp) &lt; 0) {
                return NULL;
            }
            if (tmp != NULL) {
                PyErr_SetString(PyExc_TypeError,
                                &quot;type() doesn't support MRO entry resolution; &quot;
                                &quot;use types.new_class()&quot;);
                Py_DECREF(tmp);
                return NULL;
            }
        }
        // 计算应该使用的元类，该函数会查看当前类使用的元类（metatype）和所有基类使用的元类
        // 根据元类继承规则选择最&quot;具体&quot;的元类作为 winner
        // 例如基类使用了自定义元类，而当前类使用默认的 type，那么自定义元类会胜出
        winner = _PyType_CalculateMetaclass(metatype, bases);
        if (winner == NULL) {
            return NULL;
        }
        // 胜出的元类（winner）和原始元类（metatype）比较
        // 如果胜出的元类和原始元类不同，并且胜出的元类有自己的 tp_new（不是默认的 type_new）
        if (winner != metatype) {
            if (winner-&gt;tp_new != type_new) /* Pass it to the winner */
                // 那么就调用胜出的元类的 tp_new 方法来创建类
                return winner-&gt;tp_new(winner, args, kwds);
            // 否则就用胜出的元类替换原始元类继续执行
            metatype = winner;
        }

        // 每个类都有 __base__ 和 __bases__，前者表示直接继承的第一个类，后者表示直接继承的所有类
        // 那么下面这行代码是做什么呢？直接 base = bases[0] 就好了
        // 其实这个 best_base 所做的事情没有这么简单，它还负责检测基类之间是否发生了冲突
        base = best_base(bases);
        if (base == NULL) {
            return NULL;
        }

        Py_INCREF(bases);
    }

    dict = PyDict_Copy(orig_dict);
    if (dict == NULL)
        goto error;

    // 处理定义了 __slots__ 的逻辑，一旦定义了__slots__，那么类的实例对象就没有属性字典了
    slots = _PyDict_GetItemIdWithError(dict, &amp;PyId___slots__);
    nslots = 0;
    add_dict = 0;
    add_weak = 0;
    may_add_dict = base-&gt;tp_dictoffset == 0;
    may_add_weak = base-&gt;tp_weaklistoffset == 0 &amp;&amp; base-&gt;tp_itemsize == 0;
    if (slots == NULL) {
        // ...
    }
    else {
        // ...
    }

    // 为自定义类对象申请内存
    type = (PyTypeObject *)metatype-&gt;tp_alloc(metatype, nslots);
    if (type == NULL)
        goto error;

    /* Keep name and slots alive in the extended type object */
    et = (PyHeapTypeObject *)type;
    Py_INCREF(name);
    et-&gt;ht_name = name;
    et-&gt;ht_slots = slots;
    slots = NULL;

    /* 初始化 tp_flags */
    type-&gt;tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE |
        Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC;

    // 设置 PyTypeObject 的各个字段
    type-&gt;tp_as_async = &amp;et-&gt;as_async;
    type-&gt;tp_as_number = &amp;et-&gt;as_number;
    type-&gt;tp_as_sequence = &amp;et-&gt;as_sequence;
    type-&gt;tp_as_mapping = &amp;et-&gt;as_mapping;
    type-&gt;tp_as_buffer = &amp;et-&gt;as_buffer;
    type-&gt;tp_name = PyUnicode_AsUTF8AndSize(name, &amp;name_size);
    if (!type-&gt;tp_name)
        goto error;
    if (strlen(type-&gt;tp_name) != (size_t)name_size) {
        PyErr_SetString(PyExc_ValueError,
                        &quot;type name must not contain null characters&quot;);
        goto error;
    }

    /* 设置基类和基类列表 */
    type-&gt;tp_bases = bases;
    bases = NULL;
    Py_INCREF(base);
    type-&gt;tp_base = base;

    /* 设置属性字典 */
    Py_INCREF(dict);
    type-&gt;tp_dict = dict;

    // 设置 __module__
    if (_PyDict_GetItemIdWithError(dict, &amp;PyId___module__) == NULL) {
        // ...
    }

    // 设置 __qualname__，即 &quot;全限定名&quot;
    qualname = _PyDict_GetItemIdWithError(dict, &amp;PyId___qualname__);
    if (qualname != NULL) {
        if (!PyUnicode_Check(qualname)) {
            PyErr_Format(PyExc_TypeError,
                         &quot;type __qualname__ must be a str, not %s&quot;,
                         Py_TYPE(qualname)-&gt;tp_name);
            goto error;
        }
    }
    else if (PyErr_Occurred()) {
        goto error;
    }
    // ...

    // 如果自定义的 class 中重写了 __new__
    // 将 __new__ 对应的函数改造为静态方法，并替换掉默认的 __new__
    tmp = _PyDict_GetItemIdWithError(dict, &amp;PyId___new__);
    if (tmp != NULL &amp;&amp; PyFunction_Check(tmp)) {
        tmp = PyStaticMethod_New(tmp);
        if (tmp == NULL)
            goto error;
        if (_PyDict_SetItemId(dict, &amp;PyId___new__, tmp) &lt; 0) {
            Py_DECREF(tmp);
            goto error;
        }
        Py_DECREF(tmp);
    }
    else if (tmp == NULL &amp;&amp; PyErr_Occurred()) {
        goto error;
    }

    // 获取 __init_subclass__，如果子类继承了父类，那么会触发父类的__init_subclass__
    tmp = _PyDict_GetItemIdWithError(dict, &amp;PyId___init_subclass__);
    if (tmp != NULL &amp;&amp; PyFunction_Check(tmp)) {
        tmp = PyClassMethod_New(tmp);
        if (tmp == NULL)
            goto error;
        if (_PyDict_SetItemId(dict, &amp;PyId___init_subclass__, tmp) &lt; 0) {
            Py_DECREF(tmp);
            goto error;
        }
        Py_DECREF(tmp);
    }
    else if (tmp == NULL &amp;&amp; PyErr_Occurred()) {
        goto error;
    }
    
    // 设置 __class_getitem__，这个类似于 __getitem__
    // __class_getitem__ 支持类通过 cls[&quot;xxx&quot;] 的方式访问
    tmp = _PyDict_GetItemIdWithError(dict, &amp;PyId___class_getitem__);
    if (tmp != NULL &amp;&amp; PyFunction_Check(tmp)) {
        tmp = PyClassMethod_New(tmp);
        if (tmp == NULL)
            goto error;
        if (_PyDict_SetItemId(dict, &amp;PyId___class_getitem__, tmp) &lt; 0) {
            Py_DECREF(tmp);
            goto error;
        }
        Py_DECREF(tmp);
    }
    else if (tmp == NULL &amp;&amp; PyErr_Occurred()) {
        goto error;
    }
    
    // ...
    // 为自定义类对象的实例对象设置内存大小信息 
    type-&gt;tp_basicsize = slotoffset;
    type-&gt;tp_itemsize = base-&gt;tp_itemsize;
    type-&gt;tp_members = PyHeapType_GET_MEMBERS(et);

    // ...
    // 调用 PyType_Ready 对自定义类对象进行初始化
    if (PyType_Ready(type) &lt; 0)
        goto error;

    /* Put the proper slots in place */
    fixup_slot_dispatchers(type);

    if (type-&gt;tp_dictoffset) {
        et-&gt;ht_cached_keys = _PyDict_NewKeysForClass();
    }

    if (set_names(type) &lt; 0)
        goto error;

    if (init_subclass(type, kwds) &lt; 0)
        goto error;

    Py_DECREF(dict);
    return (PyObject *)type;

error:
    Py_XDECREF(dict);
    Py_XDECREF(bases);
    Py_XDECREF(slots);
    Py_XDECREF(type);
    return NULL;
}
</code></pre>
<p>我们看到，如果是内置的类对象，那么不会走当前的 type_new，因为它们本身就已经定义好了，只需调用 PyType_Ready 初始化一下即可。但是对于自定义类对象来说，在初始化之前要先做很多工作。</p>
<p>虚拟机首先会解析出类名、基类列表和属性字典，然后根据基类列表以及传入的 metaclass 确定最佳的 metaclass 和 base。</p>
<p>随后，虚拟机会调用 <code>metatype-&gt;tp_alloc</code>  为要创建的类对象分配内存，需要注意的是，在 &amp;PyType_Type 中，我们会发现 tp_alloc 是一个 NULL，这显然不正常。但是不要忘记，虚拟机会通过 PyType_Ready 对所有的类对象进行初始化，在这个初始化过程中，有一项动作是从基类继承各种操作。由于 type.__bases__中的第一个基类是 object，所以 type 会继承 object 的 tp_alloc 操作，即 PyType_GenericAlloc。</p>
<p>对于所有继承 object 的类对象来说， PyType_GenericAlloc 将申请 <code>metatype-&gt;tp_basicsize + metatype-&gt;tp_itemsize</code> 大小的内存空间，而这个大小实际就是 <code>sizeof(PyHeapTypeObject) + sizeof(PyMemerDef)</code>。因此到这里应该明白 PyHeapTypeObject 这个老铁到底是干嘛用的了，之前因为偏移量的问题，折腾了不少功夫，甚至让人觉得这有啥用啊，但是现在意识到了，这个老铁是为自定义类对象准备的。</p>
<p>接下来就是设置自定义类对象的各个字段，其中包括了在 tp_dict 上设置属性字典，也就是 __dict__。另外要注意的是，这里还计算了类对象对应的实例对象所需要的内存大小信息，换言之，自定义类在创建实例对象时，需要为这个实例对象申请多大的内存空间呢？对于任意一个继承了 object 的自定义类对象来说，这个大小为 <code>PyBaseObject_Type-&gt;tp_basicsize + 16</code>，其中的 16 是 <font color="blue">2 * sizeof(PyObject *)</font>。</p>
<p>而之所以后面要跟着两个 PyObject * 的大小，是因为这些空间的地址被设置给了 tp_dictoffset 以及 tp_weaklistoffset。这一点将在介绍实例对象时进行解析，它是和实例对象的属性字典密切相关的。</p>
<p>最后，虚拟机还会调用 PyType_Ready 对自定义类对象进行和内置类对象一样的初始化动作，到此自定义类对象才算正式创建完毕。因此内置类对象是底层静态定义好的，启动之后再调用 PyType_Ready 完善一下即可；但自定义类对象则不同，它需要运行时动态创建，这是一个复杂的过程。但最后，两者都会调用 PyType_Ready。</p>
<p>那么内置类对象和自定义类对象在内存布局上有什么区别呢？毕竟都是类对象。</p>
<p><img src="./images/260.png" alt="" /></p>
<p>本质上，无论是自定义类对象还是内置类对象，在虚拟机内部，都可以用一个 PyTypeObject 来表示。</p>
<p>但不同的是，内置类对象对应的 PyTypeObject 以及关联的操作簇的内存位置都是在编译时确定的，它们在内存中的位置是分离的。而自定义类对象对应的 PyTypeObject 以及关联的操作簇的内存位置是连续的，必须在运行时动态分配内存。</p>
<p>另外，自定义类对象对应的 PyTypeObject 和相关操作簇组合起来，被称为 PyHeapTypeObject。</p>
<pre><code class="language-C">typedef struct _heaptypeobject {
    PyTypeObject ht_type;
    PyAsyncMethods as_async;
    PyNumberMethods as_number;
    PyMappingMethods as_mapping;
    PySequenceMethods as_sequence; 
    PyBufferProcs as_buffer;
    PyObject *ht_name, *ht_slots, *ht_qualname;
    struct _dictkeysobject *ht_cached_keys;
} PyHeapTypeObject;
</code></pre>
<p>内置类对象有哪些操作是静态定义好的，所以相关操作是分离的。但自定义类对象的相关操作簇必须紧随其后，且顺序也有讲究，只有这样才能通过偏移量 offset 准确找到指定的操作。</p>
<p>现在我们也对 Python 的可调用（callable）这个概念有一个感性认识了，可调用这个概念是一个相当通用的概念，不拘泥于对象、大小，只要类型对象定义了 tp_call，就能进行调用操作。我们已经看到，调用 metaclass 得到类对象，调用类对象得到实例对象，如果类对象也定义了 tp_call，那么还可以继续对实例对象进行调用。</p>
<h2 id="小结"><a class="header" href="#小结">小结</a></h2>
<p>以上我们就聊了聊自定义类对象的底层实现与 metaclass，还是有点复杂的，有兴趣可以多读一读源码。</p>
<hr />
<p> </p>
<p><strong>欢迎大家关注我的公众号：古明地觉的编程教室。</strong></p>
<p><img src="./images/qrcode_for_gh.jpg" alt="" /></p>
<p><strong>如果觉得文章对你有所帮助，也可以请作者吃个馒头，Thanks♪(･ω･)ﾉ。</strong></p>
<p><img src="./images/supports.png" alt="" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="76.类型对象的初始化.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="78.彻底搞懂描述符.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="76.类型对象的初始化.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="78.彻底搞懂描述符.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="theme/custom.js"></script>
    </body>
</html>
