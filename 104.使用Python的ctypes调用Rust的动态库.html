<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>104. 使用 Python 的 ctypes 调用 Rust 的动态库 - CPython3.8 源码探秘</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/custom.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="0.序言.html">0. 序言</a></li><li class="chapter-item expanded "><a href="1.CPython源码长什么样子？.html">1. CPython 源码长什么样子？</a></li><li class="chapter-item expanded "><a href="2.变量和对象，它们之间有什么区别和联系呢？.html">2. 变量和对象，它们之间有什么区别和联系呢？</a></li><li class="chapter-item expanded "><a href="3.Python对象有哪几种，我们可以从哪些角度进行分类呢？.html">3. Python 对象有哪几种，我们可以从哪些角度进行分类呢？</a></li><li class="chapter-item expanded "><a href="4.万丈高楼平地起，一切从PyObject开始.html">4. 万丈高楼平地起，一切从 PyObject 开始</a></li><li class="chapter-item expanded "><a href="5.详解PyTypeObject，Python类型对象的载体.html">5. 详解 PyTypeObject，Python 类型对象的载体</a></li><li class="chapter-item expanded "><a href="6.通过type和object之间的关联，进一步分析类型对象.html">6. 通过 type 和 object 之间的关联，进一步分析类型对象</a></li><li class="chapter-item expanded "><a href="7.当创建一个Python对象时，背后都经历了哪些过程？.html">7. 当创建一个 Python 对象时，背后都经历了哪些过程？</a></li><li class="chapter-item expanded "><a href="8.当调用一个Python对象时，背后都经历了哪些过程？.html">8. 当调用一个 Python 对象时，背后都经历了哪些过程？</a></li><li class="chapter-item expanded "><a href="9.再探泛型API，感受Python对象的设计哲学.html">9. 再探泛型 API，感受 Python 对象的设计哲学</a></li><li class="chapter-item expanded "><a href="10.Python对象的行为是怎么区分的？.html">10. Python 对象的行为是怎么区分的？</a></li><li class="chapter-item expanded "><a href="11.一个Python对象会在何时被销毁？.html">11. 一个 Python 对象会在何时被销毁？</a></li><li class="chapter-item expanded "><a href="12.深度解密Python的浮点数是怎么实现的？.html">12. 深度解密 Python 的浮点数是怎么实现的？</a></li><li class="chapter-item expanded "><a href="13.对象被销毁之后所占的内存一定会释放吗？解密浮点数的缓存池机制.html">13. 对象被销毁之后所占的内存一定会释放吗？解密浮点数的缓存池机制</a></li><li class="chapter-item expanded "><a href="14.浮点数支持的操作是怎么实现的？.html">14. 浮点数支持的操作是怎么实现的？</a></li><li class="chapter-item expanded "><a href="15.解密Python的复数是怎么实现的？它有什么用途呢？.html">15. 解密 Python 的复数是怎么实现的？它有什么用途呢？</a></li><li class="chapter-item expanded "><a href="16.Python的整数是怎么设计的，为什么它不会溢出？.html">16. Python 的整数是怎么设计的，为什么它不会溢出？</a></li><li class="chapter-item expanded "><a href="17.解密Python的小整数对象池.html">17. 解密 Python 的小整数对象池</a></li><li class="chapter-item expanded "><a href="18.两个Python整数之间是如何进行大小比较的？过程并不像我们想的那样简单.html">18. 两个 Python 整数之间是如何进行大小比较的？过程并不像我们想的那样简单</a></li><li class="chapter-item expanded "><a href="19.探究Python整数的加减法，感受大整数的运算哲学与魅力.html">19. 探究 Python 整数的加减法，感受大整数的运算哲学与魅力</a></li><li class="chapter-item expanded "><a href="20.Python的布尔值是怎么实现的，你对它的了解有多深呢？.html">20. Python 的布尔值是怎么实现的，你对它的了解有多深呢？</a></li><li class="chapter-item expanded "><a href="21.Python的None是怎么实现的？.html">21. Python 的 None 是怎么实现的？</a></li><li class="chapter-item expanded "><a href="22.深度解密Python切片的实现原理.html">22.深度解密 Python 切片的实现原理</a></li><li class="chapter-item expanded "><a href="23.bytes对象（字节串）是怎么实现的？解密它的内部原理.html">23. bytes 对象（字节串）是怎么实现的？解密它的内部原理</a></li><li class="chapter-item expanded "><a href="24.bytes对象都支持哪些操作，它们是怎么实现的？.html">24. bytes 对象都支持哪些操作，它们是怎么实现的？</a></li><li class="chapter-item expanded "><a href="25.通过bytes对象的合并，探究缓冲区的奥秘.html">25. 通过 bytes 对象的合并，探究缓冲区的奥秘</a></li><li class="chapter-item expanded "><a href="26.解密bytes对象的缓存池.html">26. 解密 bytes 对象的缓存池</a></li><li class="chapter-item expanded "><a href="27.详解bytearray对象的底层实现.html">27. 详解 bytearray 对象的底层实现</a></li><li class="chapter-item expanded "><a href="28.字符集和字符编码.html">28. 字符集和字符编码</a></li><li class="chapter-item expanded "><a href="29.Python是怎么存储字符串的？.html">29. Python 是怎么存储字符串的？</a></li><li class="chapter-item expanded "><a href="30.解密字符串的底层结构，它是怎么实现的？.html">30. 解密字符串的底层结构，它是怎么实现的？</a></li><li class="chapter-item expanded "><a href="31.字符串的intern机制是怎么一回事？.html">31. 字符串的 intern 机制是怎么一回事？</a></li><li class="chapter-item expanded "><a href="32.聊一聊字符串常见操作的源码实现.html">32. 聊一聊字符串常见操作的源码实现</a></li><li class="chapter-item expanded "><a href="33.列表是怎么实现的？解密列表的数据结构.html">33. 列表是怎么实现的？解密列表的数据结构</a></li><li class="chapter-item expanded "><a href="34.列表是怎么扩容的？.html">34. 列表是怎么扩容的？</a></li><li class="chapter-item expanded "><a href="35.解密列表的创建与销毁，以及缓存池长什么样子？.html">35. 解密列表的创建与销毁，以及缓存池长什么样子？</a></li><li class="chapter-item expanded "><a href="36.列表作为序列型对象都支持哪些操作，它们在底层是怎么实现的？.html">36. 列表作为序列型对象都支持哪些操作，它们在底层是怎么实现的？</a></li><li class="chapter-item expanded "><a href="37.列表都有哪些自定义方法，它们是怎么实现的？.html">37. 列表都有哪些自定义方法，它们是怎么实现的？</a></li><li class="chapter-item expanded "><a href="38.解密元组的实现原理.html">38. 解密元组的实现原理</a></li><li class="chapter-item expanded "><a href="39.聊一聊喜闻乐见的哈希表.html">39. 聊一聊喜闻乐见的哈希表</a></li><li class="chapter-item expanded "><a href="40.字典是怎么实现的，它的底层结构长什么样子？.html">40. 字典是怎么实现的，它的底层结构长什么样子？</a></li><li class="chapter-item expanded "><a href="41.什么是可哈希对象，它的哈希值是怎么计算的？.html">41. 什么是可哈希对象，它的哈希值是怎么计算的？</a></li><li class="chapter-item expanded "><a href="42.字典的key是怎么映射成索引的，索引冲突了又该怎么办？.html">42. 字典的 key 是怎么映射成索引的，索引冲突了又该怎么办？</a></li><li class="chapter-item expanded "><a href="43.哈希表是怎么删除元素的，能直接删除吗？.html">43. 哈希表是怎么删除元素的，能直接删除吗？</a></li><li class="chapter-item expanded "><a href="44.字典是怎么创建的，支持的操作又是如何实现的？.html">44. 字典是怎么创建的，支持的操作又是如何实现的？</a></li><li class="chapter-item expanded "><a href="45.字典的自定义方法是怎么实现的？.html">45. 字典的自定义方法是怎么实现的？</a></li><li class="chapter-item expanded "><a href="46.字典是怎么扩容的？它会经历哪些过程？.html">46. 字典是怎么扩容的？它会经历哪些过程？</a></li><li class="chapter-item expanded "><a href="47.身虽死，道未消，解密字典的缓存池.html">47. 身虽死，道未消，解密字典的缓存池</a></li><li class="chapter-item expanded "><a href="48.解密集合的实现原理.html">48. 解密集合的实现原理</a></li><li class="chapter-item expanded "><a href="49.集合支持的操作有哪些，它们是怎么实现的？.html">49. 集合支持的操作有哪些，它们是怎么实现的？</a></li><li class="chapter-item expanded "><a href="50.迭代器是怎么实现的？.html">50. 迭代器是怎么实现的？</a></li><li class="chapter-item expanded "><a href="51.Python源文件编译之后会得到什么，它的结构是怎样的？和字节码又有什么联系？.html">51. Python 源文件编译之后会得到什么，它的结构是怎样的？和字节码又有什么联系？</a></li><li class="chapter-item expanded "><a href="52.PyCodeObject拾遗.html">52. PyCodeObject 拾遗</a></li><li class="chapter-item expanded "><a href="53.一文让你搞懂pyc文件.html">53. 一文让你搞懂 pyc 文件</a></li><li class="chapter-item expanded "><a href="54.深度解密虚拟机的执行环境：栈帧对象.html">54. 深度解密虚拟机的执行环境：栈帧对象</a></li><li class="chapter-item expanded "><a href="55.名字空间：变量的容身之所.html">55. 名字空间：变量的容身之所</a></li><li class="chapter-item expanded "><a href="56.当查找一个变量时，虚拟机会进行哪些动作？.html">56. 当查找一个变量时，虚拟机会进行哪些动作？</a></li><li class="chapter-item expanded "><a href="57.虚拟机是怎么执行字节码的？背后都经历了哪些过程.html">57. 虚拟机是怎么执行字节码的？背后都经历了哪些过程</a></li><li class="chapter-item expanded "><a href="58.深入源码，进一步考察字节码的执行流程.html">58. 深入源码，进一步考察字节码的执行流程</a></li><li class="chapter-item expanded "><a href="59.局部变量是怎么实现静态查找的，它和local名字空间又有什么联系呢？.html">59. 局部变量是怎么实现静态查找的，它和 local 名字空间又有什么联系呢？</a></li><li class="chapter-item expanded "><a href="60.剖析字节码指令，以及Python赋值语句的原理.html">60. 剖析字节码指令，以及 Python 赋值语句的原理</a></li><li class="chapter-item expanded "><a href="61.流程控制语句if是怎么实现的？.html">61. 流程控制语句 if 是怎么实现的？</a></li><li class="chapter-item expanded "><a href="62.流程控制语句for、while是怎么实现的？.html">62. 流程控制语句 for、while 是怎么实现的？</a></li><li class="chapter-item expanded "><a href="63.异常是怎么实现的？虚拟机是如何将异常抛出去的？.html">63. 异常是怎么实现的？虚拟机是如何将异常抛出去的？</a></li><li class="chapter-item expanded "><a href="64.虚拟机是如何捕获异常的？.html">64. 虚拟机是如何捕获异常的？</a></li><li class="chapter-item expanded "><a href="65.函数在底层长什么样子？.html">65. 函数在底层长什么样子？</a></li><li class="chapter-item expanded "><a href="66.函数是怎么创建的，背后经历了哪些过程？.html">66. 函数是怎么创建的，背后经历了哪些过程？</a></li><li class="chapter-item expanded "><a href="67.函数在底层是如何调用的？.html">67. 函数在底层是如何调用的？</a></li><li class="chapter-item expanded "><a href="68.函数是如何解析位置参数的？.html">68. 函数是如何解析位置参数的？</a></li><li class="chapter-item expanded "><a href="69.函数是如何解析关键字参数的？.html">69. 函数是如何解析关键字参数的？</a></li><li class="chapter-item expanded "><a href="70.扩展位置参数和扩展关键字参数是如何解析的？.html">70. 扩展位置参数和扩展关键字参数是如何解析的？</a></li><li class="chapter-item expanded "><a href="71.闭包是怎么实现的？.html">71. 闭包是怎么实现的？</a></li><li class="chapter-item expanded "><a href="72.生成器是做什么的，为什么会有生成器？.html">72. 生成器是做什么的，为什么会有生成器？</a></li><li class="chapter-item expanded "><a href="73.源码解密生成器的实现原理.html">73. 源码解密生成器的实现原理</a></li><li class="chapter-item expanded "><a href="74.回顾Python的对象模型.html">74. 回顾 Python 的对象模型</a></li><li class="chapter-item expanded "><a href="75.class概念解析.html">75. class 概念解析</a></li><li class="chapter-item expanded "><a href="76.类型对象的初始化.html">76. 类型对象的初始化</a></li><li class="chapter-item expanded "><a href="77.自定义类对象的底层实现与metaclass.html">77. 自定义类对象的底层实现与 metaclass</a></li><li class="chapter-item expanded "><a href="78.彻底搞懂描述符.html">78. 彻底搞懂描述符</a></li><li class="chapter-item expanded "><a href="79.实例对象是如何创建的？.html">79. 实例对象是如何创建的？</a></li><li class="chapter-item expanded "><a href="80.实例对象的属性访问.html">80. 实例对象的属性访问</a></li><li class="chapter-item expanded "><a href="81.为什么实例在调用方法时会将自身传给self参数.html">81. 为什么实例在调用方法时会将自身传给 self 参数</a></li><li class="chapter-item expanded "><a href="82.模块是如何导入的？.html">82. 模块是如何导入的？</a></li><li class="chapter-item expanded "><a href="83.import机制的黑盒探测.html">83. import 机制的黑盒探测</a></li><li class="chapter-item expanded "><a href="84.import机制是怎么实现的？.html">84. import 机制是怎么实现的？</a></li><li class="chapter-item expanded "><a href="85.Python运行时环境的初始化，解释器在启动时都做了什么？.html">85. Python 运行时环境的初始化，解释器在启动时都做了什么？</a></li><li class="chapter-item expanded "><a href="86.激活Python虚拟机.html">86. 激活 Python 虚拟机</a></li><li class="chapter-item expanded "><a href="87.初识GIL、以及多个线程之间的调度机制.html">87. 初识 GIL、以及多个线程之间的调度机制</a></li><li class="chapter-item expanded "><a href="88.线程的创建、销毁、调度，以及GIL的实现原理.html">88. 线程的创建、销毁、调度，以及 GIL 的实现原理</a></li><li class="chapter-item expanded "><a href="89.解密map、filter、zip底层实现，对比列表解析式.html">89. 解密 map、filter、zip 底层实现，对比列表解析式</a></li><li class="chapter-item expanded "><a href="90.为什么要有协程，协程是如何实现的？.html">90. 为什么要有协程，协程是如何实现的？</a></li><li class="chapter-item expanded "><a href="91.什么是asyncio？如何基于单线程实现并发？事件循环又是怎么工作的？.html">91. 什么是 asyncio？如何基于单线程实现并发？事件循环又是怎么工作的？</a></li><li class="chapter-item expanded "><a href="92.协程、任务、future，以及事件循环.html">92. 协程、任务、future，以及事件循环</a></li><li class="chapter-item expanded "><a href="93.在asyncio中使用Socket.html">93. 在 asyncio 中使用 Socket</a></li><li class="chapter-item expanded "><a href="94.解密asyncio的Future和Task.html">94. 解密 asyncio 的 Future 和 Task</a></li><li class="chapter-item expanded "><a href="95.如何精确控制asyncio中并发运行的多个任务.html">95. 如何精确控制 asyncio 中并发运行的多个任务</a></li><li class="chapter-item expanded "><a href="96.详解asyncio的同步原语.html">96. 详解 asyncio 的同步原语</a></li><li class="chapter-item expanded "><a href="97.在asyncio中引入多进程.html">97. 在 asyncio 中引入多进程</a></li><li class="chapter-item expanded "><a href="98.可执行文件的内存模型，变量的值是放在栈上还是放在堆上.html">98. 可执行文件的内存模型，变量的值是放在栈上还是放在堆上</a></li><li class="chapter-item expanded "><a href="99.Python是如何管理内存的？.html">99. Python 是如何管理内存的？</a></li><li class="chapter-item expanded "><a href="100.Python的垃圾回收机制是怎么实现的？.html">100. Python 的垃圾回收机制是怎么实现的？</a></li><li class="chapter-item expanded "><a href="101.深入源码，探究垃圾回收的秘密.html">101. 深入源码，探究垃圾回收的秘密</a></li><li class="chapter-item expanded "><a href="102.侵入Python虚拟机，动态修改底层数据结构和运行时.html">102. 侵入 Python 虚拟机，动态修改底层数据结构和运行时</a></li><li class="chapter-item expanded "><a href="103.使用Python的ctypes调用C的动态库.html">103. 使用 Python 的 ctypes 调用 C 的动态库</a></li><li class="chapter-item expanded "><a href="104.使用Python的ctypes调用Rust的动态库.html" class="active">104. 使用 Python 的 ctypes 调用 Rust 的动态库</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">CPython3.8 源码探秘</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="楔子"><a class="header" href="#楔子">楔子</a></h2>
<p>Rust 让 Python 更加伟大，随着 Rust 的流行，反而让 Python 的生产力提高了不少。因为有越来越多的 Python 工具，都选择了 Rust 进行开发，并且性能也优于同类型的其它工具。比如：</p>
<ul>
<li>ruff：速度极快的代码分析工具，以及代码格式化工具；</li>
<li>orjson：一个高性能的 JSON 解析库；</li>
<li>watchfiles：可以对指定目录进行实时监控；</li>
<li>polars：和 pandas 类似的数据分析工具；</li>
<li>pydantic：数据验证工具；</li>
<li>......</li>
</ul>
<p>总之现在 Rust + Python 已经成为了一个趋势，并且 Rust 也提供了一系列成熟好用的工具，比如 PyO3、Maturin，专门为 Python 编写扩展。不过关于 PyO3 我们以后有机会再聊，本篇文章先来介绍如何将 Rust 代码编译成动态库，然后交给 Python 的 ctypes 模块调用。</p>
<p>正如上一篇文章所说，通过 ctypes 调用动态库是最简单的一种方式，它只对操作系统有要求，只要操作系统一致，那么任何提供了 ctypes 模块的 Python 解释器都可以调用。当然这也侧面要求，Rust 提供的接口不能太复杂，因为 ctypes 提供的交互能力还是比较有限的，最明显的问题就是不同语言的数据类型不同，一些复杂的交互方式还是比较难做到的，还有多线程的控制问题等等。</p>
<h2 id="举个例子"><a class="header" href="#举个例子">举个例子</a></h2>
<p>下面我们举个例子感受一下 Python 和 Rust 的交互过程，首先通过如下命令创建一个 Rust 项目：</p>
<pre><code class="language-sh">cargo new py_lib --lib
</code></pre>
<p>创建完之后修改 Cargo.toml，在里面加入如下内容：</p>
<pre><code class="language-toml">[lib]
# 编译之后的动态库的名称
name = &quot;py_lib&quot;
# 表示编译成一个和 C 语言二进制接口（ABI）兼容的动态链接库
crate-type = [&quot;cdylib&quot;]
</code></pre>
<p>cdylib 表示生成动态库，如果想生成静态库，那么就指定为 staticlib。</p>
<p>下面开始编写源代码，在生成项目之后，src 目录下会有一个 lib.rs，它是整个库的入口点。我们的代码比较简单，直接写在 lib.rs 里面即可。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern &quot;C&quot; fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[no_mangle]
pub extern &quot;C&quot; fn get_square_root(v: i32) -&gt; f64 {
    (v as f64).sqrt()
}
<span class="boring">}
</span></code></pre></pre>
<p>在定义函数时需要使用 pub extern &quot;C&quot; 进行声明，它表示创建一个外部可见、遵循 C 语言调用约定的函数，因为 Python 使用的是 C ABI。此外还要给函数添加一个 #[no_mangle] 属性，让编译器在将 Rust 函数导出为 C 函数时，不要改变函数的名称，确保在编译成动态库后，函数名保持不变，否则在调用动态库时就找不到指定的函数了。</p>
<blockquote>
<p>Rust 有个名称修饰（Name Mangling）的机制，在跨语言操作时，会修改函数名，增加一些额外信息。这种修改对 Rust 内部使用没有影响，但会干扰其它语言的调用，因此需要通过 #[no_mangle] 将该机制禁用掉。</p>
</blockquote>
<p>代码编写完成，我们通过 cargo build 进行编译，然后在 target/debug 目录下就会生成相应的动态库。由于库的名称为 py_lib，那么生成的库文件名就叫 libpy_lib.dylib（我的系统是 macOS）。</p>
<blockquote>
<p>当功能全部实现并且测试通过时，最好重新编译一次，并加上 --release 参数。这样可以对代码进行优化，当然编译时间也会稍微长一些，并且生成的库文件会在 target/release 目录中。</p>
</blockquote>
<p>编译器生成动态库后，会自动加上一个 lib 前缀（Windows 系统除外），至于后缀则与操作系统有关。</p>
<ul>
<li>Windows 系统，后缀名为 .dll；</li>
<li>macOS 系统，后缀名为 .dylib；</li>
<li>Linux 系统，后缀名为 .so；</li>
</ul>
<p>然后通过 Python 进行调用。</p>
<pre><code class="language-python">import ctypes

# 和调用 C 的动态库的逻辑是一样的
# 因为 Python 不关心动态库是 C 编译的，还是 Rust 编译的
py_lib = ctypes.CDLL(&quot;../py_lib/target/debug/libpy_lib.dylib&quot;)

print(py_lib.add(11, 22))  # 33

get_square_root = getattr(py_lib, &quot;get_square_root&quot;, None)
print(get_square_root)  # &lt;_FuncPtr object at 0x7fae30a2b040&gt;
</code></pre>
<p>以上就是通过 ctypes 模块来调用 Rust 编译生成的动态库，但显然目前还是远远不够的，比如说：</p>
<pre><code class="language-Python">from ctypes import CDLL

py_lib = CDLL(&quot;../py_lib/target/debug/libpy_lib.dylib&quot;)

square_root = py_lib.get_square_root(100)
print(square_root)  # 0
</code></pre>
<p>100 的平方根是 10，但却返回了 0。这是因为 ctypes 在解析返回值的时候默认是按照整型来解析的，但当前的函数返回的是浮点型，因此函数在调用之前需要显式地指定其返回值类型。</p>
<p>不过在这之前，我们需要先来看看 Python 类型和 Rust 类型之间的转换关系。</p>
<h2 id="数值类型"><a class="header" href="#数值类型">数值类型</a></h2>
<p>使用 ctypes 调用动态链接库，主要是调用库里面使用 Rust 编写好的函数，但这些函数是需要参数的，还有返回值。而不同语言的变量类型不同，Python 不能直接往 Rust 编写的函数中传参，因此 ctypes 提供了大量的类，帮我们将 Python 的类型转成 Rust 的类型。</p>
<blockquote>
<p>与其说转成 Rust 的类型，倒不如说转成 C 的类型，因为 Rust 导出的函数要遵循 C 的调用约定。</p>
</blockquote>
<p><img src="./images/401.png" alt="" /></p>
<p>下面来测试一下，首先编写 Rust 代码：</p>
<pre><code class="language-Rust">#[no_mangle]
pub extern &quot;C&quot; fn add_u32(a: u32) -&gt; u32 {
    a + 1
}
#[no_mangle]
pub extern &quot;C&quot; fn add_isize(a: isize) -&gt; isize {
    a + 1
}
#[no_mangle]
pub extern &quot;C&quot; fn add_f32(a: f32) -&gt; f32 {
    a + 1.
}
#[no_mangle]
pub extern &quot;C&quot; fn add_f64(a: f64) -&gt; f64 {
    a + 1.
}
#[no_mangle]
pub extern &quot;C&quot; fn reverse_bool(a: bool) -&gt; bool {
    !a
}
</code></pre>
<p>编译之后 Python 进行调用。</p>
<pre><code class="language-python">from ctypes import *

py_lib = CDLL(&quot;../py_lib/target/debug/libpy_lib.dylib&quot;)

print(py_lib.add_u32(123))  # 124
print(py_lib.add_isize(666))  # 667
try:
    print(py_lib.add_f32(3.14))
except Exception as e:
    print(e)  # &lt;class 'TypeError'&gt;: Don't know how to convert parameter 1

# 可以看到报错了，告诉我们不知道如何转化第 1 个参数
# 因为 Python 的数据和 C 的数据不一样，所以不能直接传递
# 但整数是个例外，除了整数，其它数据都需要使用 ctypes 包装一下
# 另外整数最好也包装一下，因为不同整数之间，精度也有区别
print(py_lib.add_f32(c_float(3.14)))  # 1
# 虽然没报错，但是结果不对，结果应该是 3.14 + 1 = 4.14，而不是 1
# 因为 ctypes 调用函数时默认使用整型来解析，但该函数返回的不是整型
# 需要告诉 ctypes，add_f32 函数返回的是 c_float，请按照 c_float 来解析
py_lib.add_f32.restype = c_float
print(py_lib.add_f32(c_float(3.14)))  # 4.140000343322754

# f32 和 f64 是不同的类型，占用的字节数也不一样
# 所以 c_float 和 c_double 之间不可混用，虽然都是浮点数
py_lib.add_f64.restype = c_double
print(py_lib.add_f64(c_double(3.14)))  # 4.140000000000001

py_lib.reverse_bool.restype = c_bool
print(py_lib.reverse_bool(c_bool(True)))  # False
print(py_lib.reverse_bool(c_bool(False)))  # True
</code></pre>
<p>不复杂，以上我们就实现了数值类型的传递。</p>
<h2 id="字符类型"><a class="header" href="#字符类型">字符类型</a></h2>
<p>字符类型有两种，一种是 ASCII 字符，本质上是个 u8；一种是 Unicode 字符，本质上是个 u32。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern &quot;C&quot; fn get_char(a: u8) -&gt; u8  {
    a + 1
}

#[no_mangle]
pub extern &quot;C&quot; fn get_unicode(a: u32) -&gt; u32  {
    let chr = char::from_u32(a).unwrap();
    if chr == '憨' {
        '批' as u32
    } else {
        a
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>我们知道 Rust 专门提供了 4 个字节的 char 类型来表示 unicode 字符，但对于外部导出函数来说，使用 char 是不安全的，所以直接使用 u8 和 u32 就行。编译之后，Python 调用：</p>
<pre><code class="language-Python">from ctypes import *

py_lib = CDLL(&quot;../py_lib/target/debug/libpy_lib.dylib&quot;)

# 指定返回值为 c_byte，会返回一个整数
py_lib.get_char.restype = c_byte
print(py_lib.get_char(97))  # 98
# 指定返回值为 c_char，会返回一个字符（长度为 1 的 bytes 对象）
py_lib.get_char.restype = c_char
print(py_lib.get_char(97))  # b'b'

py_lib.get_unicode.restype = c_wchar
print(py_lib.get_unicode(c_wchar(&quot;嘿&quot;)))  # 嘿
# 直接传一个 u32 整数也可以，因为 unicode 字符在底层就是个 u32
print(py_lib.get_unicode(ord(&quot;憨&quot;)))  # 批
</code></pre>
<p>以上就是字符类型的操作，比较简单。</p>
<h2 id="字符串类型"><a class="header" href="#字符串类型">字符串类型</a></h2>
<p>再来看看字符串，我们用 Rust 实现一个函数，它接收一个字符串，然后返回大写形式。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ffi::{CStr, CString};
use std::os::raw::c_char;

#[no_mangle]
pub extern &quot;C&quot; fn to_uppercase(s: *const c_char) -&gt; *mut c_char {
    // 将 *const c_char 转成 &amp;CStr
    let s = unsafe {
        CStr::from_ptr(s)
    };
    // 将 &amp;CStr 转成 &amp;str，然后调用 to_uppercase 转成大写，得到 String
    let s = s.to_str().unwrap().to_uppercase();
    // 将 String 转成 *mut char 返回
    CString::new(s).unwrap().into_raw()
}
<span class="boring">}
</span></code></pre></pre>
<p>解释一下里面的 CStr 和 CString，在 Rust 中，CString 用于创建 C 风格的字符串（以 \0 结尾），拥有自己的内存。关键的是，CString 拥有值的所有权，当实例离开作用域时，它的析构函数会被调用，相关内存会被自动释放。而 CStr，它和 CString 之间的关系就像 str 和 String 的关系，所以 CStr 一般以引用的形式出现。并且 CStr 没有 new 方法，不能直接创建，它需要通过 from_ptr 方法从原始指针转化得到。</p>
<p>然后指针类型是 *const 和 *mut，分别表示指向 C 风格字符串首字符的不可变指针和可变指针，它们的区别主要在于指向的数据是否可以被修改。如果不需要修改，那么使用 *const 会更安全一些。</p>
<p>我们编写 Python 代码测试一下。</p>
<pre><code class="language-python">from ctypes import *

py_lib = CDLL(&quot;../py_lib/target/debug/libpy_lib.dylib&quot;)

s = &quot;hello 古明地觉&quot;.encode(&quot;utf-8&quot;)
# 默认是按照整型解析的，所以不指定返回值类型的话，会得到脏数据
print(py_lib.to_uppercase(c_char_p(s)))
&quot;&quot;&quot;
31916096
&quot;&quot;&quot;
# 指定返回值为 c_char_p，表示按照 char * 来解析
py_lib.to_uppercase.restype = c_char_p
print(
    py_lib.to_uppercase(c_char_p(s)).decode(&quot;utf-8&quot;)
)
&quot;&quot;&quot;
HELLO 古明地觉
&quot;&quot;&quot;
</code></pre>
<p>从表面上看似乎挺顺利的，但背后隐藏着内存泄露的风险，因为 Rust 里面创建的 CString 还驻留在堆区，必须要将它释放掉。所以我们还要写一个函数，用于释放字符串。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ffi::{CStr, CString};
use std::os::raw::c_char;

#[no_mangle]
pub extern &quot;C&quot; fn to_uppercase(s: *const c_char) -&gt; *mut c_char {
    let s = unsafe {
        CStr::from_ptr(s)
    };
    let s = s.to_str().unwrap().to_uppercase();
    CString::new(s).unwrap().into_raw()
}

#[no_mangle]
pub extern &quot;C&quot; fn free_cstring(s: *mut c_char) {
    unsafe {
        if s.is_null() { return }
        // 基于原始指针创建 CString，拿到堆区字符串的所有权
        // 然后离开作用域，自动释放
        CString::from_raw(s)
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>然后来看看 Python 如何调用：</p>
<pre><code class="language-Python">from ctypes import *

py_lib = CDLL(&quot;../py_lib/target/debug/libpy_lib.dylib&quot;)

s = &quot;hello 古明地觉&quot;.encode(&quot;utf-8&quot;)
# Rust 返回的是原始指针，这里必须要拿到它保存的地址，所以指定返回值为 c_void_p
# 如果指定为 c_char_p，那么会直接转成 bytes 对象，这样地址就拿不到了
py_lib.to_uppercase.restype = c_void_p
ptr = py_lib.to_uppercase(c_char_p(s))
# 将 ptr 转成 c_char_p，获取 value 属性，即可得到具体的 bytes 对象
print(cast(ptr, c_char_p).value.decode(&quot;utf-8&quot;))
&quot;&quot;&quot;
HELLO 古明地觉
&quot;&quot;&quot;
# 内容我们拿到了，但堆区的字符串还没有释放，所以调用 free_cstring
py_lib.free_cstring(c_void_p(ptr))
</code></pre>
<p>通过 CString 的 into_raw，可以基于 CString 创建原始指针 *mut，然后 Python 将指针指向的堆区数据拷贝一份，得到 bytes 对象。但这个 CString 依旧驻留在堆区，所以 Python 不能将返回值指定为 c_char_p，因为它会直接创建 bytes 对象，这样就拿不到指针了。因此将返回值指定为 c_void_p，调用函数会得到一串整数，这个整数就是指针保存的地址。</p>
<p>我们使用 cast 函数可以将地址转成 c_char_p，获取它的 value 属性拿到具体的字节串。再通过 c_void_p 创建原始指针交给 Rust，调用 CString 的 from_raw，可以基于 *mut 创建 CString，从而将所有权夺回来，然后离开作用域时释放堆内存。</p>
<h2 id="给函数传递指针"><a class="header" href="#给函数传递指针">给函数传递指针</a></h2>
<p>如果扩展函数里面接收的是指针，那么 Python 要怎么传递呢？</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern &quot;C&quot; fn add(a: *mut i32, b: *mut i32) -&gt; i32 {
    // 定义为 *mut，那么可以修改指针指向的值，定义为 *const，则不能修改
    if a.is_null() || b.is_null() {
        0
    } else {
        let res = unsafe {
            *a + *b
        };
        unsafe {
            // 这里将 *a 和 *b 给改掉
            *a = 666;
            *b = 777;
        }
        res
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>定义了一个 add 函数，接收两个 i32 指针，返回解引用后相加的结果。但是在返回之前，我们将 *a 和 *b 的值也修改了。</p>
<pre><code class="language-Python">from ctypes import *

py_lib = CDLL(&quot;../py_lib/target/debug/libpy_lib.dylib&quot;)

a = c_int(22)
b = c_int(33)
# 计算
print(py_lib.add(pointer(a), pointer(b)))  # 55
# 我们看到 a 和 b 也被修改了
print(a, a.value)  # c_int(666) 666
print(b, b.value)  # c_int(777) 777
</code></pre>
<p>非常简单，那么问题来了，能不能返回一个指针呢？答案是当然可以，只不过存在一些注意事项。</p>
<p>由于 Rust 本身的内存安全原则，直接从函数返回一个指向本地局部变量的指针是不安全的。因为该变量的作用域仅限于函数本身，一旦函数返回，该变量的内存就会被回收，从而出现悬空指针。</p>
<p>为了避免这种情况出现，我们应该在堆上分配内存，但这又出现了之前 CString 的问题。Python 在拿到值之后，堆内存依旧驻留在堆区。因此 Rust 如果想返回指针，那么同时还要定义一个释放函数。</p>
<pre><code class="language-Rust">#[no_mangle]
pub extern &quot;C&quot; fn add(a: *const i32, b: *const i32) -&gt; *mut i32 {
    // 返回值的类型是 *mut i32，所以 res 不能直接返回，因此它是 i32
    let res = unsafe {*a + *b};
    // 创建智能指针（将 res 装箱），然后返回原始指针
    Box::into_raw(Box::new(res))
}

#[no_mangle]
pub extern &quot;C&quot; fn free_i32(ptr: *mut i32) {
    if !ptr.is_null() {
        // 转成 Box&lt;i32&gt;，同时拿到所有权，在离开作用域时释放堆内存
        unsafe { let _ = Box::from_raw(ptr); }
    }
}
</code></pre>
<p>然后 Python 进行调用：</p>
<pre><code class="language-Python">from ctypes import *

py_lib = CDLL(&quot;../py_lib/target/debug/libpy_lib.dylib&quot;)

a, b = c_int(22), c_int(33)
# 指定类型为 c_void_p
py_lib.add.restype = c_void_p
# 拿到指针保存的地址
ptr = py_lib.add(pointer(a), pointer(b))
# 将 c_void_p 转成 POINTER(c_int) 类型，也就是 c_int *
# 通过它的 contents 属性拿到具体的值
print(cast(ptr, POINTER(c_int)).contents)  # c_int(55)
print(cast(ptr, POINTER(c_int)).contents.value)  # 55
# 释放堆内存
py_lib.free_i32(c_void_p(ptr))
</code></pre>
<p>这样我们就拿到了指针，并且也不会出现内存泄露。但是单独定义一个释放函数还是有些麻烦的，所以 Rust 自动提供了一个 free 函数，专门用于释放堆内存。举个例子：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ffi::{CStr, CString};
use std::os::raw::c_char;

#[no_mangle]
pub extern &quot;C&quot; fn to_uppercase(s: *const c_char) -&gt; *mut c_char {
    let s = unsafe {
        CStr::from_ptr(s)
    };
    let s = s.to_str().unwrap().to_uppercase();
    CString::new(s).unwrap().into_raw()
}

#[no_mangle]
pub extern &quot;C&quot; fn add(a: *const i32, b: *const i32) -&gt; *mut i32 {
    let res = unsafe {*a + *b};
    Box::into_raw(Box::new(res))
}
<span class="boring">}
</span></code></pre></pre>
<p>这是出现过的两个函数，它们的内存都申请在堆区，但我们将内存释放函数删掉了，因为 Rust 自动提供了一个 free 函数，专门用于堆内存的释放。</p>
<pre><code class="language-Python">from ctypes import *

py_lib = CDLL(&quot;../py_lib/target/debug/libpy_lib.dylib&quot;)

# 返回值类型指定为 c_void_p，表示万能指针
py_lib.to_uppercase.restype = c_void_p
py_lib.add.restype = c_void_p

ptr1 = py_lib.to_uppercase(
    c_char_p(&quot;Serpen 老师&quot;.encode(&quot;utf-8&quot;))
)
ptr2 = py_lib.add(
    pointer(c_int(123)), pointer(c_int(456))
)
# 函数调用完毕，将地址转成具体的类型的指针
print(cast(ptr1, c_char_p).value.decode(&quot;utf-8&quot;))
&quot;&quot;&quot;
SERPEN 老师
&quot;&quot;&quot;
print(cast(ptr2, POINTER(c_int)).contents.value)
&quot;&quot;&quot;
579
&quot;&quot;&quot;
# 释放堆内存，直接调用 free 函数即可，非常方便
py_lib.free(c_void_p(ptr1))
py_lib.free(c_void_p(ptr2))
</code></pre>
<p>以上我们就实现了指针的传递和返回，但对于整数、浮点数而言，直接返回它们的值即可，没必要返回指针。</p>
<h2 id="传递数组"><a class="header" href="#传递数组">传递数组</a></h2>
<p>下面来看看如何传递数组，由于数组在作为参数传递的时候会退化为指针，所以数组的长度信息就丢失了，使用 sizeof 计算出来的结果就是一个指针的大小。因此将数组作为参数传递的时候，应该将当前数组的长度信息也传递过去，否则可能会访问非法的内存。</p>
<p>我们实现一个功能，Rust 接收一个 Python 数组，进行原地排序。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::slice;

#[no_mangle]
pub extern &quot;C&quot; fn sort_array(arr: *mut i32, len: usize) {
    assert!(!arr.is_null());

    unsafe {
        // 得到一个切片 &amp;mut[i32]
        let slice = slice::from_raw_parts_mut(arr, len);
        slice.sort();  // 排序
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>然后 Python 进行调用：</p>
<pre><code class="language-Python">from ctypes import *

py_lib = CDLL(&quot;../py_lib/target/debug/libpy_lib.dylib&quot;)

# 一个列表
data = [3, 2, 1, 5, 4, 7, 6]
# 但是列表不能传递，必须要转成 C 数组
# Array_Type 就相当于 C 的 int array[len(data)]
Array_Type = c_int * len(data)
# 创建数组
array = Array_Type(*data)
print(list(array))  # [3, 2, 1, 5, 4, 7, 6]
py_lib.sort_array(array, len(array))
print(list(array))  # [1, 2, 3, 4, 5, 6, 7]
</code></pre>
<p>排序实现完成，这里的数组是 Python 传过去的，并且进行了原地修改。那 Rust 可不可以返回数组给 Python 呢？从理论上来说可以，但实际不建议这么做，因为你不知道返回的数组的长度是多少？</p>
<p>如果你真的想返回数组的话，那么可以将数组拼接成字符串，然后返回。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ffi::{c_char, CString};

#[no_mangle]
pub extern &quot;C&quot; fn create_array() -&gt; *mut c_char {
    // 筛选出 1 到 50 中，能被 3 整除的数
    // 并以逗号为分隔符，将这些整数拼接成字符串
    let vec = (1..=50)
        .filter(|c| *c % 3 == 0)
        .map(|c| c.to_string())
        .collect::&lt;Vec&lt;String&gt;&gt;()
        .join(&quot;,&quot;);
    CString::new(vec).unwrap().into_raw()
}
<span class="boring">}
</span></code></pre></pre>
<p>编译之后交给 Python 调用。</p>
<pre><code class="language-Python">from ctypes import *

py_lib = CDLL(&quot;../py_lib/target/debug/libpy_lib.dylib&quot;)

# 只要是需要释放的堆内存，都建议按照 c_void_p 来解析
py_lib.create_array.restype = c_void_p
# 此时拿到的就是指针保存的地址，在 Python 里面就是一串整数
ptr = py_lib.create_array()
# 由于是字符串首字符的地址，所以转成 char *，拿到具体内容
print(cast(ptr, c_char_p).value.decode(&quot;utf-8&quot;))
&quot;&quot;&quot;
3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48
&quot;&quot;&quot;
# 此时我们就将数组拼接成字符串返回了
# 但是堆区的 CString 还在，所以还要释放掉，调用 free 函数即可
# 注意：ptr 只是一串整数，或者说它就是 Python 的一个 int 对象
# 换句话说 ptr 只是保存了地址值，但它不具备指针的含义
# 因此需要再使用 c_void_p 包装一下（转成指针），才能传给 free 函数
py_lib.free(c_void_p(ptr))
</code></pre>
<p>因此虽然不建议返回数组，但将数组转成字符串返回也不失为一个办法，当然除了数组，你还可以将更复杂的结构转成字符串返回。</p>
<h2 id="传递结构体"><a class="header" href="#传递结构体">传递结构体</a></h2>
<p>结构体应该是 Rust 里面最重要的结构之一了，它要如何和外部交互呢？</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ffi::c_char;

#[repr(C)]
pub struct Girl {
    pub name: *mut c_char,
    pub age: u8,
}

#[no_mangle]
pub extern &quot;C&quot; fn create_struct(name: *mut c_char, age: u8) -&gt; Girl {
    Girl { name, age }
<span class="boring">}
</span></code></pre></pre>
<p>因为结构体实例要返回给外部，所以它的字段类型必须是兼容的，不能定义 C 理解不了的类型。然后还要设置 #[repr(C)] 属性，来保证结构体的内存布局和 C 是兼容的。</p>
<p>下面通过 cargo build 命令编译成动态库，Python 负责调用。</p>
<pre><code class="language-Python">from ctypes import *

py_lib = CDLL(&quot;../py_lib/target/debug/libpy_lib.dylib&quot;)

class Girl(Structure):

    _fields_ = [
        (&quot;name&quot;, c_char_p),
        (&quot;age&quot;, c_uint8),
    ]

# 指定 create_struct 的返回值类型为 Girl
py_lib.create_struct.restype = Girl
girl = py_lib.create_struct(
    c_char_p(&quot;S 老师&quot;.encode(&quot;utf-8&quot;)),
    c_uint8(18)
)
print(girl.name.decode(&quot;utf-8&quot;))  # S 老师
print(girl.age)  # 18
</code></pre>
<p>调用成功，并且此时是没有内存泄露的。</p>
<p>当通过 FFI 将数据从 Rust 传递到 Python 时，如果传递的是指针，那么会涉及内存释放的问题。但如果传递的是值，那么它会复制一份给 Python，而原始的值（这里是结构体实例）会被自动销毁，所以无需担心。</p>
<p>然后是结构体内部的字段，虽然里面的 name 字段是 *mut c_char，但它的值是由 Python 传过来的，而不是在 Rust 内部创建的，因此没有问题。但如果将 Rust 代码改一下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ffi::{c_char, CString};

#[repr(C)]
pub struct Girl {
    pub name: *mut c_char,
    pub age: u8,
}

#[no_mangle]
pub extern &quot;C&quot; fn create_struct() -&gt; Girl {
    let name = CString::new(&quot;S 老师&quot;).unwrap().into_raw();
    let age = 18;
    Girl { name, age }
}
<span class="boring">}
</span></code></pre></pre>
<p>这时就尴尬了，此时的字符串是 Rust 里面创建的，转成原始指针之后，Rust 将不再管理相应的堆内存（因为 into_raw 将所有权转移走了），此时就需要手动管理堆内存了。</p>
<pre><code class="language-Python">from ctypes import *

py_lib = CDLL(&quot;../py_lib/target/debug/libpy_lib.dylib&quot;)

class Girl(Structure):

    _fields_ = [
        (&quot;name&quot;, c_char_p),
        (&quot;age&quot;, c_uint8),
    ]

# 指定 create_struct 的返回值类型为 Girl
py_lib.create_struct.restype = Girl
girl = py_lib.create_struct()
print(girl.name.decode(&quot;utf-8&quot;))  # S 老师
print(girl.age)  # 18
# 直接传递 girl 即可，会释放 girl 里面的字段在堆区的内存
py_lib.free(girl)
</code></pre>
<p>此时就不会出现内存泄露了，在 free 的时候，将变量 girl 传进去，释放掉内部字段占用的堆内存。当然，Rust 也可以返回结构体指针，通过 Box&lt;T&gt; 实现。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern &quot;C&quot; fn create_struct() -&gt; *mut Girl {
    let name = CString::new(&quot;S 老师&quot;).unwrap().into_raw();
    let age = 18;
    Box::into_raw(Box::new(Girl { name, age }))
}
<span class="boring">}
</span></code></pre></pre>
<p>注意：之前是 name 字段在堆上，但结构体实例在栈上，现在 name 字段和结构体实例都在堆上。然后 Python 调用也很简单，关键是释放的问题。</p>
<pre><code class="language-Python">from ctypes import *

py_lib = CDLL(&quot;../py_lib/target/debug/libpy_lib.dylib&quot;)

class Girl(Structure):

    _fields_ = [
        (&quot;name&quot;, c_char_p),
        (&quot;age&quot;, c_uint8),
    ]

# 此时返回值类型就变成了 c_void_p
# 当返回指针时，建议将返回值设置为 c_void_p
py_lib.create_struct.restype = c_void_p
# 拿到指针（一串整数）
ptr = py_lib.create_struct()
# 将指针转成指定的类型，而类型显然是 POINTER(Girl)
# 调用 POINTER(T) 的 contents 方法，拿到相应的结构体实例
girl = cast(ptr, POINTER(Girl)).contents
# 访问具体内容
print(girl.name.decode(&quot;utf-8&quot;))  # S 老师
print(girl.age)  # 18

# 释放堆内存，这里的释放分为两步，并且顺序不能错
# 先 free(girl)，释放掉内部字段（name）占用的堆内存
# 然后 free(c_void_p(ptr))，释放掉结构体实例 girl 占用的堆内存
py_lib.free(girl)
py_lib.free(c_void_p(ptr))
</code></pre>
<p>不难理解，只是在释放结构体实例的时候需要多留意，如果内部有字段占用堆内存，那么需要先将这些字段释放掉。而释放的方式是将结构体实例作为参数传给 free 函数，然后再传入 c_void_p 释放结构体实例。</p>
<h2 id="回调函数"><a class="header" href="#回调函数">回调函数</a></h2>
<p>最后看一下 Python 如何传递函数给 Rust，因为 Python 和 Rust 之间使用的是 C ABI，所以函数必须遵循 C 的标准。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// calc 接收三个参数，前两个参数是 *const i32
// 最后一个参数是函数，它接收两个 *const i32，返回一个 i32
#[no_mangle]
pub extern &quot;C&quot; fn calc(
    a: *const i32, b: *const i32,
    op: extern &quot;C&quot; fn(*const i32, *const i32) -&gt; i32
) -&gt; i32
{
    op(a, b)
}
<span class="boring">}
</span></code></pre></pre>
<p>然后看看 Python 如何传递回调函数。</p>
<pre><code class="language-Python">from ctypes import *

py_lib = CDLL(&quot;../py_lib/target/debug/libpy_lib.dylib&quot;)

# 基于 Python 函数创建 C 函数，通过 @CFUNCTYPE() 进行装饰
@CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))
def add(a, b):  # a、b 为 int *，通过 .contents.value 拿到具体的值
    return a.contents.value + b.contents.value

@CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))
def sub(a, b):
    return a.contents.value - b.contents.value

@CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))
def mul(a, b):
    return a.contents.value * b.contents.value

@CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))
def div(a, b):
    return a.contents.value // b.contents.value

a = pointer(c_int(10))
b = pointer(c_int(2))
print(py_lib.calc(a, b, add))  # 12
print(py_lib.calc(a, b, sub))  # 8
print(py_lib.calc(a, b, mul))  # 20
print(py_lib.calc(a, b, div))  # 5
</code></pre>
<p>成功实现了向 Rust 传递回调函数，当然例子举得有点刻意了，比如参数类型指定为 i32 即可，没有必要使用指针。</p>
<h2 id="小结"><a class="header" href="#小结">小结</a></h2>
<p>以上我们就介绍了 Python 如何调用 Rust 编译的动态库，再次强调一下，通过 ctypes 调用动态库是最方便、最简单的方式。它和 Python 的版本无关，也不涉及底层的 C 扩展，它只是将 Rust 编译成 C ABI  用。</p>
<p>因此这也侧面要求，函数的参数和返回值的类型应该是 C 可以表示的类型，比如 Rust 函数不能返回一个 trait 对象。总之在调用动态库的时候，库函数内部的逻辑可以很复杂，但是参数和返回值最好要简单。</p>
<p>如果你发现 Python 代码存在大量的 CPU 密集型计算，并且不怎么涉及复杂的 Python 数据结构，那么不妨将这些计算交给 Rust。</p>
<hr />
<p> </p>
<p><strong>欢迎大家关注我的公众号：古明地觉的编程教室。</strong></p>
<p><img src="./images/qrcode_for_gh.jpg" alt="" /></p>
<p><strong>如果觉得文章对你有所帮助，也可以请作者吃个馒头，Thanks♪(･ω･)ﾉ。</strong></p>
<p><img src="./images/supports.png" alt="" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="103.使用Python的ctypes调用C的动态库.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="103.使用Python的ctypes调用C的动态库.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="theme/custom.js"></script>
    </body>
</html>
