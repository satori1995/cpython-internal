<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>22.深度解密 Python 切片的实现原理 - CPython3.8 源码探秘</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/custom.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="0.序言.html">0. 序言</a></li><li class="chapter-item expanded "><a href="1.CPython源码长什么样子？.html">1. CPython 源码长什么样子？</a></li><li class="chapter-item expanded "><a href="2.变量和对象，它们之间有什么区别和联系呢？.html">2. 变量和对象，它们之间有什么区别和联系呢？</a></li><li class="chapter-item expanded "><a href="3.Python对象有哪几种，我们可以从哪些角度进行分类呢？.html">3. Python 对象有哪几种，我们可以从哪些角度进行分类呢？</a></li><li class="chapter-item expanded "><a href="4.万丈高楼平地起，一切从PyObject开始.html">4. 万丈高楼平地起，一切从 PyObject 开始</a></li><li class="chapter-item expanded "><a href="5.详解PyTypeObject，Python类型对象的载体.html">5. 详解 PyTypeObject，Python 类型对象的载体</a></li><li class="chapter-item expanded "><a href="6.通过type和object之间的关联，进一步分析类型对象.html">6. 通过 type 和 object 之间的关联，进一步分析类型对象</a></li><li class="chapter-item expanded "><a href="7.当创建一个Python对象时，背后都经历了哪些过程？.html">7. 当创建一个 Python 对象时，背后都经历了哪些过程？</a></li><li class="chapter-item expanded "><a href="8.当调用一个Python对象时，背后都经历了哪些过程？.html">8. 当调用一个 Python 对象时，背后都经历了哪些过程？</a></li><li class="chapter-item expanded "><a href="9.再探泛型API，感受Python对象的设计哲学.html">9. 再探泛型 API，感受 Python 对象的设计哲学</a></li><li class="chapter-item expanded "><a href="10.Python对象的行为是怎么区分的？.html">10. Python 对象的行为是怎么区分的？</a></li><li class="chapter-item expanded "><a href="11.一个Python对象会在何时被销毁？.html">11. 一个 Python 对象会在何时被销毁？</a></li><li class="chapter-item expanded "><a href="12.深度解密Python的浮点数是怎么实现的？.html">12. 深度解密 Python 的浮点数是怎么实现的？</a></li><li class="chapter-item expanded "><a href="13.对象被销毁之后所占的内存一定会释放吗？解密浮点数的缓存池机制.html">13. 对象被销毁之后所占的内存一定会释放吗？解密浮点数的缓存池机制</a></li><li class="chapter-item expanded "><a href="14.浮点数支持的操作是怎么实现的？.html">14. 浮点数支持的操作是怎么实现的？</a></li><li class="chapter-item expanded "><a href="15.解密Python的复数是怎么实现的？它有什么用途呢？.html">15. 解密 Python 的复数是怎么实现的？它有什么用途呢？</a></li><li class="chapter-item expanded "><a href="16.Python的整数是怎么设计的，为什么它不会溢出？.html">16. Python 的整数是怎么设计的，为什么它不会溢出？</a></li><li class="chapter-item expanded "><a href="17.解密Python的小整数对象池.html">17. 解密 Python 的小整数对象池</a></li><li class="chapter-item expanded "><a href="18.两个Python整数之间是如何进行大小比较的？过程并不像我们想的那样简单.html">18. 两个 Python 整数之间是如何进行大小比较的？过程并不像我们想的那样简单</a></li><li class="chapter-item expanded "><a href="19.探究Python整数的加减法，感受大整数的运算哲学与魅力.html">19. 探究 Python 整数的加减法，感受大整数的运算哲学与魅力</a></li><li class="chapter-item expanded "><a href="20.Python的布尔值是怎么实现的，你对它的了解有多深呢？.html">20. Python 的布尔值是怎么实现的，你对它的了解有多深呢？</a></li><li class="chapter-item expanded "><a href="21.Python的None是怎么实现的？.html">21. Python 的 None 是怎么实现的？</a></li><li class="chapter-item expanded "><a href="22.深度解密Python切片的实现原理.html" class="active">22.深度解密 Python 切片的实现原理</a></li><li class="chapter-item expanded "><a href="23.bytes对象（字节串）是怎么实现的？解密它的内部原理.html">23. bytes 对象（字节串）是怎么实现的？解密它的内部原理</a></li><li class="chapter-item expanded "><a href="24.bytes对象都支持哪些操作，它们是怎么实现的？.html">24. bytes 对象都支持哪些操作，它们是怎么实现的？</a></li><li class="chapter-item expanded "><a href="25.通过bytes对象的合并，探究缓冲区的奥秘.html">25. 通过 bytes 对象的合并，探究缓冲区的奥秘</a></li><li class="chapter-item expanded "><a href="26.解密bytes对象的缓存池.html">26. 解密 bytes 对象的缓存池</a></li><li class="chapter-item expanded "><a href="27.详解bytearray对象的底层实现.html">27. 详解 bytearray 对象的底层实现</a></li><li class="chapter-item expanded "><a href="28.字符集和字符编码.html">28. 字符集和字符编码</a></li><li class="chapter-item expanded "><a href="29.Python是怎么存储字符串的？.html">29. Python 是怎么存储字符串的？</a></li><li class="chapter-item expanded "><a href="30.解密字符串的底层结构，它是怎么实现的？.html">30. 解密字符串的底层结构，它是怎么实现的？</a></li><li class="chapter-item expanded "><a href="31.字符串的intern机制是怎么一回事？.html">31. 字符串的 intern 机制是怎么一回事？</a></li><li class="chapter-item expanded "><a href="32.聊一聊字符串常见操作的源码实现.html">32. 聊一聊字符串常见操作的源码实现</a></li><li class="chapter-item expanded "><a href="33.列表是怎么实现的？解密列表的数据结构.html">33. 列表是怎么实现的？解密列表的数据结构</a></li><li class="chapter-item expanded "><a href="34.列表是怎么扩容的？.html">34. 列表是怎么扩容的？</a></li><li class="chapter-item expanded "><a href="35.解密列表的创建与销毁，以及缓存池长什么样子？.html">35. 解密列表的创建与销毁，以及缓存池长什么样子？</a></li><li class="chapter-item expanded "><a href="36.列表作为序列型对象都支持哪些操作，它们在底层是怎么实现的？.html">36. 列表作为序列型对象都支持哪些操作，它们在底层是怎么实现的？</a></li><li class="chapter-item expanded "><a href="37.列表都有哪些自定义方法，它们是怎么实现的？.html">37. 列表都有哪些自定义方法，它们是怎么实现的？</a></li><li class="chapter-item expanded "><a href="38.解密元组的实现原理.html">38. 解密元组的实现原理</a></li><li class="chapter-item expanded "><a href="39.聊一聊喜闻乐见的哈希表.html">39. 聊一聊喜闻乐见的哈希表</a></li><li class="chapter-item expanded "><a href="40.字典是怎么实现的，它的底层结构长什么样子？.html">40. 字典是怎么实现的，它的底层结构长什么样子？</a></li><li class="chapter-item expanded "><a href="41.什么是可哈希对象，它的哈希值是怎么计算的？.html">41. 什么是可哈希对象，它的哈希值是怎么计算的？</a></li><li class="chapter-item expanded "><a href="42.字典的key是怎么映射成索引的，索引冲突了又该怎么办？.html">42. 字典的 key 是怎么映射成索引的，索引冲突了又该怎么办？</a></li><li class="chapter-item expanded "><a href="43.哈希表是怎么删除元素的，能直接删除吗？.html">43. 哈希表是怎么删除元素的，能直接删除吗？</a></li><li class="chapter-item expanded "><a href="44.字典是怎么创建的，支持的操作又是如何实现的？.html">44. 字典是怎么创建的，支持的操作又是如何实现的？</a></li><li class="chapter-item expanded "><a href="45.字典的自定义方法是怎么实现的？.html">45. 字典的自定义方法是怎么实现的？</a></li><li class="chapter-item expanded "><a href="46.字典是怎么扩容的？它会经历哪些过程？.html">46. 字典是怎么扩容的？它会经历哪些过程？</a></li><li class="chapter-item expanded "><a href="47.身虽死，道未消，解密字典的缓存池.html">47. 身虽死，道未消，解密字典的缓存池</a></li><li class="chapter-item expanded "><a href="48.解密集合的实现原理.html">48. 解密集合的实现原理</a></li><li class="chapter-item expanded "><a href="49.集合支持的操作有哪些，它们是怎么实现的？.html">49. 集合支持的操作有哪些，它们是怎么实现的？</a></li><li class="chapter-item expanded "><a href="50.迭代器是怎么实现的？.html">50. 迭代器是怎么实现的？</a></li><li class="chapter-item expanded "><a href="51.Python源文件编译之后会得到什么，它的结构是怎样的？和字节码又有什么联系？.html">51. Python 源文件编译之后会得到什么，它的结构是怎样的？和字节码又有什么联系？</a></li><li class="chapter-item expanded "><a href="52.PyCodeObject拾遗.html">52. PyCodeObject 拾遗</a></li><li class="chapter-item expanded "><a href="53.一文让你搞懂pyc文件.html">53. 一文让你搞懂 pyc 文件</a></li><li class="chapter-item expanded "><a href="54.深度解密虚拟机的执行环境：栈帧对象.html">54. 深度解密虚拟机的执行环境：栈帧对象</a></li><li class="chapter-item expanded "><a href="55.名字空间：变量的容身之所.html">55. 名字空间：变量的容身之所</a></li><li class="chapter-item expanded "><a href="56.当查找一个变量时，虚拟机会进行哪些动作？.html">56. 当查找一个变量时，虚拟机会进行哪些动作？</a></li><li class="chapter-item expanded "><a href="57.虚拟机是怎么执行字节码的？背后都经历了哪些过程.html">57. 虚拟机是怎么执行字节码的？背后都经历了哪些过程</a></li><li class="chapter-item expanded "><a href="58.深入源码，进一步考察字节码的执行流程.html">58. 深入源码，进一步考察字节码的执行流程</a></li><li class="chapter-item expanded "><a href="59.局部变量是怎么实现静态查找的，它和local名字空间又有什么联系呢？.html">59. 局部变量是怎么实现静态查找的，它和 local 名字空间又有什么联系呢？</a></li><li class="chapter-item expanded "><a href="60.剖析字节码指令，以及Python赋值语句的原理.html">60. 剖析字节码指令，以及 Python 赋值语句的原理</a></li><li class="chapter-item expanded "><a href="61.流程控制语句if是怎么实现的？.html">61. 流程控制语句 if 是怎么实现的？</a></li><li class="chapter-item expanded "><a href="62.流程控制语句for、while是怎么实现的？.html">62. 流程控制语句 for、while 是怎么实现的？</a></li><li class="chapter-item expanded "><a href="63.异常是怎么实现的？虚拟机是如何将异常抛出去的？.html">63. 异常是怎么实现的？虚拟机是如何将异常抛出去的？</a></li><li class="chapter-item expanded "><a href="64.虚拟机是如何捕获异常的？.html">64. 虚拟机是如何捕获异常的？</a></li><li class="chapter-item expanded "><a href="65.函数在底层长什么样子？.html">65. 函数在底层长什么样子？</a></li><li class="chapter-item expanded "><a href="66.函数是怎么创建的，背后经历了哪些过程？.html">66. 函数是怎么创建的，背后经历了哪些过程？</a></li><li class="chapter-item expanded "><a href="67.函数在底层是如何调用的？.html">67. 函数在底层是如何调用的？</a></li><li class="chapter-item expanded "><a href="68.函数是如何解析位置参数的？.html">68. 函数是如何解析位置参数的？</a></li><li class="chapter-item expanded "><a href="69.函数是如何解析关键字参数的？.html">69. 函数是如何解析关键字参数的？</a></li><li class="chapter-item expanded "><a href="70.扩展位置参数和扩展关键字参数是如何解析的？.html">70. 扩展位置参数和扩展关键字参数是如何解析的？</a></li><li class="chapter-item expanded "><a href="71.闭包是怎么实现的？.html">71. 闭包是怎么实现的？</a></li><li class="chapter-item expanded "><a href="72.生成器是做什么的，为什么会有生成器？.html">72. 生成器是做什么的，为什么会有生成器？</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">CPython3.8 源码探秘</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/satori1995/cpython-internal" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="楔子"><a class="header" href="#楔子">楔子</a></h2>
<p>本篇文章来探讨一下切片是如何实现的，因为在操作字符串、元组、列表等数据结构时，我们经常会使用切片截取数据，所以对切片做一个全方位的了解是很有必要的。</p>
<pre><code class="language-Python">data = list(range(10))
print(data[1: 8: 3])  # [1, 4, 7]
</code></pre>
<p>以上就是基于切片截取数据，在工作中我们会大量使用切片。但你知道吗，其实切片也是一个对象，类型为 slice，下面我们来看一下切片的底层结构。</p>
<h2 id="切片的底层结构"><a class="header" href="#切片的底层结构">切片的底层结构</a></h2>
<p>切片的类型是 slice，那么根据解释器的 API 命名规则，我们猜测：</p>
<ul>
<li>切片（slice 对象）在底层对应 PySliceObject 结构体实例；</li>
<li>slice 类型本身在底层对应 PySlice_Type；</li>
</ul>
<p>下面看一下具体实现。</p>
<pre><code class="language-C">// Include/sliceobject.h
typedef struct {
    PyObject_HEAD
    PyObject *start, *stop, *step;
} PySliceObject;
</code></pre>
<p>切片是不可变对象，除了对象的公共头部之外，还有三个字段，分别表示切片的起始位置、终止位置、步长。这也意味着创建切片时，可以给 slice 传递三个参数。</p>
<pre><code class="language-Python"># 创建一个切片
s = slice(1, 8, 3)
print(s)  # slice(1, 8, 3)
</code></pre>
<p>问题来了，切片创建的时候，传递的参数绑定在了哪些属性上呢？前面我们说过，实例对象可以绑定哪些属性，会定义在类型对象的 tp_members 字段中。</p>
<p><img src="./images/73.png" alt="" /></p>
<p>我们看到切片拥有三个属性，名称也是 start、stop、step。</p>
<pre><code class="language-python">s = slice(1, 8, 3)
print(s)  # slice(1, 8, 3)
print(s.start)  # 1
print(s.stop)  # 8
print(s.step)  # 3
</code></pre>
<p>非常简单，你在 Python 里面看到的一切，都能从源码中找到答案。</p>
<h2 id="切片是怎么创建的"><a class="header" href="#切片是怎么创建的">切片是怎么创建的</a></h2>
<p>切片是内置类型的实例对象，对于这样的对象，有两种创建方式，相信你已经知道我要说什么了。我们在最开始专门用了十篇文章，从宏观的角度介绍了 Python 的对象模型，目的就在于此。</p>
<p>创建内置对象的两种方式：</p>
<ul>
<li>通过对象的特定类型 API 创建，只适用于内置对象；</li>
<li>通过调用类型对象创建，所有对象都适用；</li>
</ul>
<p>解释器对内置对象了如指掌，它们对应的结构体在源码中是写死的，直接 sizeof 一下即可知晓要申请多大内存，完全不需要借助类型对象。</p>
<pre><code class="language-python">data = list(range(10))
# 通过特定类型 API 创建
print(data[1: 8: 3])  # [1，4，7]
# 通过调用类型对象创建
print(data[slice(1, 8, 3)])  # [1，4，7]
</code></pre>
<p>解释器看到 data[1: 8: 3] 就知道要创建一个切片，并且是在数据截取的过程中创建的，我们不能单独写一个 <font color="blue">1: 8: 3</font>，这是不符合语法规则的。如果真的想单独创建一个切片，那么需要通过 <font color="blue">slice(1, 8, 3)</font> 的方式。</p>
<p>下面通过源码，看一下底层的创建过程。</p>
<pre><code class="language-C">// Objects/sliceobject.c
static PyObject *
slice_new(PyTypeObject *type, PyObject *args, PyObject *kw)
{
    PyObject *start, *stop, *step;
    start = stop = step = NULL;
    // slice 不接收关键字参数，因此 kw 要指向空字典
    if (!_PyArg_NoKeywords(&quot;slice&quot;, kw))
        return NULL;
    // slice 接收 1 ~ 3 个位置参数，因此 args 指向的元组必须包含 1 ~ 3 个元素
    // 然后解析 args，将内部的元素分别赋值给 start、stop、step
    if (!PyArg_UnpackTuple(args, &quot;slice&quot;, 1, 3, &amp;start, &amp;stop, &amp;step))
        return NULL;

    // 如果 stop == NULL，说明只传递了一个参数，按照顺序这个参数会赋值给 start
    // 但很明显，如果只有一个参数，那么这个参数应该交给 stop 保存
    // 于是让 stop = start，并让 start = NULL，至于这么做的原因可以想象一下 range
    // 如果是 range(0, 9)，那么起始位置和终止位置就是 0 和 9
    // 但如果是 range(9)，那么这个 9 就是终止位置
    if (stop == NULL) {
        stop = start;
        start = NULL;
    }
    // 假设传了一个参数 8，那么这里就是 PySlice_New(NULL, 8, NULL)
    // 假设传了两个参数 1、8，那么这里就是 PySlice_New(1, 8, NULL)
    // 假设传了三个参数 1、8、3，那么这里就是 PySlice_New(1, 8, 3)
    return PySlice_New(start, stop, step);
}

// 切片缓存，注：slice_cache 只能缓存一个切片
static PySliceObject *slice_cache = NULL;

PyObject *
PySlice_New(PyObject *start, PyObject *stop, PyObject *step)
{
    PySliceObject *obj;
    // 如果 slice_cache 不为 NULL，证明缓存了切片，那么赋值给 obj
    // 由于 slice_cache 只能缓存一个切片，那么赋值给 obj 之后，自身要重置为 NULL
    if (slice_cache != NULL) {
        obj = slice_cache;
        slice_cache = NULL;
        _Py_NewReference((PyObject *)obj);
    } else {
        // 否则调用 PyObject_GC_New 为 PySliceObject 实例申请内存
        obj = PyObject_GC_New(PySliceObject, &amp;PySlice_Type);
        if (obj == NULL)
            return NULL;
    }
    // 如果 start、stop、step 是 NULL，那么转成 Python 的 None
    if (step == NULL) step = Py_None;
    Py_INCREF(step);
    if (start == NULL) start = Py_None;
    Py_INCREF(start);
    if (stop == NULL) stop = Py_None;
    Py_INCREF(stop);
    // 设置切片的 start、stop、step 属性
    obj-&gt;step = step;
    obj-&gt;start = start;
    obj-&gt;stop = stop;
    // 接收 GC 跟踪（在之后的篇章中会解释）
    _PyObject_GC_TRACK(obj);
    // 转成泛型指针之后返回
    return (PyObject *) obj;
}
</code></pre>
<p>以上就是切片的创建过程，非常简单，我们用 Python 代码演示一遍。</p>
<pre><code class="language-Python">print(slice(8))  # slice(None, 8, None)
print(slice(1, 8))  # slice(1, 8, None)
print(slice(1, 8, 3))  # slice(1, 8, 3)
</code></pre>
<p>结果和源码是一致的。</p>
<h2 id="切片的缓存"><a class="header" href="#切片的缓存">切片的缓存</a></h2>
<p>从源码中可以看到，切片是有缓存的。</p>
<pre><code class="language-c">static PySliceObject *slice_cache = NULL;
</code></pre>
<p>这个字段用于缓存被回收的切片，并且从切片的创建过程可以看出只会缓存一个，而不是像浮点数那样以链表的形式缓存多个。之所以这么做，是因为在大部分情况下，切片用完之后会立即销毁。</p>
<pre><code class="language-python">data = list(range(10))
# 创建一个切片，截取完数据之后就销毁
print(data[0: 3])  # [0, 1, 2]
# 创建一个切片，截取完数据之后就销毁
print(data[2: 7])  # [2, 3, 4, 5, 6]
</code></pre>
<p>像 <font color="blue">data[start: stop: step]</font> 这种形式，当数据截取完毕之后，创建的切片会立即回收，所以对于解释器来说，它只需要缓存一个切片即可。因此你可以认为同一时刻只会存在一个有效切片，那什么时候会存在多个呢？</p>
<pre><code class="language-Python">data = list(range(10))
s1 = slice(0, 3)
s2 = slice(2, 7)
print(data[s1])  # [0, 1, 2]
print(data[s2])  # [2, 3, 4, 5, 6]
</code></pre>
<p>在这种情况下，会同时存在多个有效切片，比如 s1 和 s2 都指向了有效的切片。但很明显，我们在工作中不会这么做，而是在截取数据时，让解释器通过切片的特定类型 API 自动创建。</p>
<p>下面我们来打印切片的地址，看看切片是否被缓存起来了。</p>
<pre><code class="language-python"># 创建一个切片，缓存如果存在，从缓存获取，否则创建新的切片
&gt;&gt;&gt; s1 = slice(0, 3)
&gt;&gt;&gt; id(s1)
140190801666944

# 创建切片，因为 s1 和 s2 是两个独立的切片，所以它们的地址是不一样的
&gt;&gt;&gt; s2 = slice(2, 7)
&gt;&gt;&gt; id(s2)
140190800965120

# 删除 s1，那么它指向的切片会被放到缓存中
&gt;&gt;&gt; del s1

# 创建新的切片，使用缓存，显然它的地址和之前 s1 指向的切片的地址是一样的
&gt;&gt;&gt; s3 = slice(1, 5)
&gt;&gt;&gt; id(s3)
140190801666944

# 由于缓存为空，那么删除 s2，它指向的切片会被放入缓存
&gt;&gt;&gt; del s2

# 创建新的切片，显然它的地址和之前 s2 指向的切片的地址是一样的
&gt;&gt;&gt; s4 = slice(1, 6)
&gt;&gt;&gt; id(s4)
140190800965120
</code></pre>
<p>打印结果表明，切片是会被缓存的，但我们怎么证明切片只会缓存一个呢？这个直接看源码即可，根据之前的经验，对象被放入缓存这一步一定发生在对象被销毁的时候，所以我们只需要看切片的销毁过程即可。</p>
<p>对象被销毁时，会调用类型对象的 tp_dealloc，也就是析构函数。</p>
<p><img src="./images/74.png" alt="" /></p>
<p>类型对象的 tp_basicsize 保存了实例对象的基础大小，对于切片而言就是 sizeof(PySliceObject)，然后切片又是定长对象，因此 tp_itemsize 是 0。所以切片的大小是固定的，PyObject 占 16 字节，start、end、step 各占 8 字节，总共 40 字节，因此任何一个切片的大小都是固定的 40 字节。</p>
<p>而这个大小即使不借助类型对象也可以计算出来，因为内置对象的定义都是写死的，解释器对它们了如指掌。</p>
<p>为了唤醒大家的记忆，加深理解，以前的内容会时不时回顾一下。我们继续看切片的销毁，对应的析构函数是 slice_dealloc。</p>
<pre><code class="language-C">// Objects/sliceobject.c
static void
slice_dealloc(PySliceObject *r)
{
    // 取消 GC 跟踪，相关内容后续介绍
    _PyObject_GC_UNTRACK(r);
    // 切片销毁时，减少 start、stop、step 指向对象的引用计数
    Py_DECREF(r-&gt;step);
    Py_DECREF(r-&gt;start);
    Py_DECREF(r-&gt;stop);
    // 关键来了，如果 slice_cache 为 NULL，证明没有缓存
    // 那么让 slice_cache 保存销毁的切片的指针，而切片的内存不释放
    // 这样下一次创建切片时就不需要申请内存了，直接使用缓存即可
    // 因为没有申请内存，只是初始化了 start、stop、step 三个字段，所以效率会更高
    if (slice_cache == NULL)
        slice_cache = r;
    // 否则释放切片所占的内存
    else
        PyObject_GC_Del(r);
}
</code></pre>
<p>从源码中可以看到，如果 slice_cache 不为空，说明已经缓存了一个切片，if 条件不成立，于是会选择释放内存，所以切片只会缓存一个。</p>
<h2 id="切片属性的初始化"><a class="header" href="#切片属性的初始化">切片属性的初始化</a></h2>
<p>切片接收 1 到 3 个元素，但我们可能只传一个，那么剩余的属性是怎么初始化的呢？举个例子：</p>
<pre><code class="language-python">&gt;&gt;&gt; data = list(range(10))
&gt;&gt;&gt; data[: 5]
[0, 1, 2, 3, 4]
&gt;&gt;&gt; data[1:]
[1, 2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt;&gt; data[1:: 2]
[1, 3, 5, 7, 9]
&gt;&gt;&gt; data[:: 2]
[0, 2, 4, 6, 8]
&gt;&gt;&gt; data[:]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>这些切片都是合法的，当参数不足时，它们的 start、end、step 是怎么设置的呢？</p>
<pre><code class="language-C">// Objects/sliceobject.c

// 该函数接收指向切片的指针，以及三个整型指针
// 会将切片的起始位置、终止位置、步长解析出来，赋值给 *start、*stop、*step
// 所以该函数会在其它函数的内部被调用，先声明 Py_ssize_t start, stop, step
// 然后将切片指针、&amp;start、&amp;stop、&amp;end 传递给 PySlice_Unpack 进行调用
// 当该函数执行完毕时，外部就拿到了切片的起始位置、终止位置以及步长
int
PySlice_Unpack(PyObject *_r,
               Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step)
{
    // 将 PyObject * 转成 PySliceObject *
    PySliceObject *r = (PySliceObject*)_r;
    Py_BUILD_ASSERT(PY_SSIZE_T_MIN + 1 &lt;= -PY_SSIZE_T_MAX);
  
    // 判断步长，如果解析出的步长为空，那么将 *step 赋值为 1
    // 所以当不指定步长时，步长会被设置为 1，因此 data[::] 等价于 data[:: 1]
    if (r-&gt;step == Py_None) {
        *step = 1;
    }
    else {
        // 如果步长不为空，那么它应该是整数，或者是实现了 __index__ 的类的实例对象
        // 但如果步长的类型不合法，那么 _PyEval_SliceIndex 里面会设置异常
        // 合法的话，会将 r-&gt;step 赋值给 *step
        if (!_PyEval_SliceIndex(r-&gt;step, step)) return -1;
        // 步长不能为 0，否则设置 ValueError(&quot;slice step cannot be zero&quot;)
        if (*step == 0) {
            PyErr_SetString(PyExc_ValueError,
                            &quot;slice step cannot be zero&quot;);
            return -1;
        }
        // 如果步长小于 -PY_SSIZE_T_MAX，那么设置为 -PY_SSIZE_T_MAX
        // 显然这一步基本不会发生
        if (*step &lt; -PY_SSIZE_T_MAX)
            *step = -PY_SSIZE_T_MAX;
    }
  
    // 检测起始位置，如果为 None
    // 当步长大于 0 时，将 *start 设置为 0
    // 当步长小于 0 时，将 *start 设置为 int64 最大值，这背后的原理一会儿解释
    if (r-&gt;start == Py_None) {
        *start = *step &lt; 0 ? PY_SSIZE_T_MAX : 0;
    }
    // 说明起始位置不为 None
    else {
        // 如果起始位置的类型不合法，那么设置异常，直接返回，否则赋值给 *start
        if (!_PyEval_SliceIndex(r-&gt;start, start)) return -1;
    }
  
    // 如果终止位置为 None
    // 当步长大于 0 时，将 *stop 设置为 PY_SSIZE_T_MAX，即 int64 最大值
    // 当步长小于 0 时，将 *stop 设置为 PY_SSIZE_T_MIN，即 int64 最小值
    if (r-&gt;stop == Py_None) {
        *stop = *step &lt; 0 ? PY_SSIZE_T_MIN : PY_SSIZE_T_MAX;
    }
    // 说明终止位置不为 None
    else {
        // 如果终止位置不合法，那么设置异常，直接返回，否则赋值给 *stop
        if (!_PyEval_SliceIndex(r-&gt;stop, stop)) return -1;
    }

    return 0;
}
</code></pre>
<p>代码逻辑有一些绕，虽然我们知道它在做什么，但问题是这么做的意义是什么呢？在解释之前，我们先用 Python 代码将该函数所做的事情再描述一遍，这样更容易理解。</p>
<pre><code class="language-Python">PY_SSIZE_T_MAX = 2 ** 63 - 1
PY_SSIZE_T_MIN = -2 ** 63

# 如果切片同时包含起始位置、终止位置、步长，会直接赋值给 start、end、step
# 这种情况最简单，就不赘述了，我们来讨论未被同时指定的情况

# 步长为空，比如 data[1: 8]
start = 1
end = 8
step = 1

# 起始位置为空，步长大于 0，比如 data[: 8]
start = 0
end = 8
step = 1
# 起始位置为空，步长小于 0，比如 data[: 8: -1]
start = PY_SSIZE_T_MAX
end = 8
step = -1

# 终止位置为空，步长大于 0，比如 data[2:]
start = 2
end = PY_SSIZE_T_MAX
step = 1
# 终止位置为空，步长小于 0，比如 data[2:: -1]
start = 2
end = PY_SSIZE_T_MIN
step = -1

# 起始位置、终止位置均为空，步长大于 0，比如 data[::]
start = 0
end = PY_SSIZE_T_MAX
step = 1
# 起始位置、终止位置均为空，步长小于 0，比如 data[:: -1]
start = PY_SSIZE_T_MAX
end = PY_SSIZE_T_MIN
step = -1
</code></pre>
<p>下面来分析一下它为什么要这么做，首先我们要知道，所谓的切片截取数据，本质上就是一层 for 循环。</p>
<pre><code class="language-python">def slice_data(data: list, start: int, end: int, step: int) -&gt; list:
    ret_data = []
    assert step != 0
    if step &gt; 0:
        while start &lt; end and start &lt; len(data):
            ret_data.append(data[start])
            start += step
    else:
        while start &gt; end and start &gt;= 0:
            ret_data.append(data[start])
            start -= step * -1
    return ret_data

data = list(range(0, 10))
print(data[: 5])
print(slice_data(data, 0, 5, 1))
&quot;&quot;&quot;
[0, 1, 2, 3, 4]
[0, 1, 2, 3, 4]
&quot;&quot;&quot;
print(data[8: 3: -1])
print(slice_data(data, 8, 3, -1))
&quot;&quot;&quot;
[8, 7, 6, 5, 4]
[8, 7, 6, 5, 4]
&quot;&quot;&quot;
</code></pre>
<p>所以当步长大于 0 时，从左往右遍历，当步长小于 0 时，从右往左遍历。最后我们再画两张图，看完之后你就彻底理解了。</p>
<p><font color="darkblue"><strong>当步长大于 0 时：</strong></font></p>
<p><img src="./images/75.png" alt="" /></p>
<p>步长大于 0 时，从左往右遍历。</p>
<p>如果 start 未指定，那么设置为 0，表示从头截取，这很好理解，但问题是 end 应该设置为多少。由于 PySlice_Unpack 相当于只是做了一步预处理，它并不包含截取的原始数据的信息，所以 end 如果不指定，直接设置为 int64 最大值。</p>
<p><font color="darkblue"><strong>当步长小于 0 时：</strong></font></p>
<p><img src="./images/76.png" alt="" /></p>
<p>当步长小于 0 时，从右往左遍历。</p>
<p>因为不知道截取的原始数据有多长，所以如果 start 未指定，那么设置为 int64 最大值。但不管是从左往右还是从右往左，end 都是不包含的，所以当 end 为空时，不能指定为 0，否则索引为 0 的元素就取不到了。当然也不能设置为 -1，因为 -1 会被当成是合法的负数索引，后续截取数据时会被解释为最后一个元素的索引，所以它被设置成了 int64 最小值。</p>
<p>我们以使用切片截取列表为例，后续介绍列表的时候还会详细说：</p>
<p><img src="./images/77.png" alt="" /></p>
<p>代码中的 item 指向切片，截取数据之前要先获取它内部的 start、stop、step 属性，于是创建三个 Py_ssize_t 变量，并将指针作为参数，调用 PySlice_Unpack。当调用结束后，就拿到了切片的起始位置、终止位置、步长。</p>
<p>但还没有结束，我们说 PySlice_Unpack 只是对切片里面的值做了一些预处理，比如当 step 为 1 并且 end 没有指定时，那么 end 会被设置为 PY_SSIZE_T_MAX。</p>
<p>所以它下面又调用了函数 PySlice_AdjustIndices，会将截取的原始数据的长度也传进去，然后对 start、end、step 做进一步处理，所有的序列对象在基于切片截取数据时都会有这两步。我们看一下该函数的逻辑。</p>
<pre><code class="language-C">// Objects/sliceobject.c
Py_ssize_t
PySlice_AdjustIndices(Py_ssize_t length,
                      Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t step)
{
    // 参数 length：截取的原始数据的长度
    // 参数 start、stop：指向起始位置和终止位置的指针
    // 参数 step：步长
  
    assert(step != 0);
    assert(step &gt;= -PY_SSIZE_T_MAX);
    
    // 如果起始位置小于 0
    if (*start &lt; 0) {
        // 那么加上长度，得到正数索引，因为负数索引就是个语法糖
        *start += length;
        // 如果加上长度之后还小于 0，那么判断步长
        /* 如果 step &gt; 0，表示从前往后遍历，因此当 *start &lt; 0 时，
           直接将 *start 设置为 0，最终会从第一个元素开始往后遍历
        
           如果 step &lt; 0，表示从后往前遍历，因此当 *start &lt; 0 时，
           显然遍历不到任何元素，因为索引是大于 0 的，所以直接将 *start 设置为 -1 */        
        if (*start &lt; 0) {
            *start = (step &lt; 0) ? -1 : 0;
        }
    }
    // 如果起始位置大于等于长度，继续判断步长
    else if (*start &gt;= length) {
        /* 如果 step &gt; 0，表示从前往后遍历，因此当 *start &gt;= length 时，
           显然遍历不到任何元素，因为最大索引为 length - 1
           所以直接将 *start 设置为 length
           
           如果 step &lt; 0，表示从后往前遍历，因此当 *start &gt;= length 时，
           直接将 *start 设置为 length - 1，最终会从最后一个元素往前遍历 */       
        *start = (step &lt; 0) ? length - 1 : length;
    }
    
    // 如果终止位置小于 0
    if (*stop &lt; 0) {
        // 那么加上长度，得到正数索引
        *stop += length;
        // 如果加上长度之后还小于 0，那么判断步长
        /* 如果 step &gt; 0，表示从前往后遍历，因此当 *stop &lt; 0 时，
           显然遍历不到任何元素，因此直接将 *stop 设置为 0
           
           如果 step &lt; 0，表示从后往前遍历，因此当 *stop &lt; 0 时，
           直接将 *stop 设置为 -1，最终会从后往前遍历到头 */           
        if (*stop &lt; 0) {
            *stop = (step &lt; 0) ? -1 : 0;
        }
    }
    // 如果终止位置大于等于长度，继续判断步长
    else if (*stop &gt;= length) {
        /* 如果 step &gt; 0，表示从前往后遍历，因此当 *stop &gt;= length 时，
           直接设置为 length，会从 start 往后遍历到头
           
           如果 step &lt; 0，表示从后往前遍历，因此当 *stop &gt;= length 时，
           此时遍历不到任何元素，直接设置为 length - 1 */           
        *stop = (step &lt; 0) ? length - 1 : length;
    }
    
    // 到这里 *start、*stop 就已经转换好了
    // 或者说 PY_SSIZE_T_MIN、PY_SSIZE_T_MAX 已经基于 length 被替换掉了
    // 然后计算 *start 和 *stop 之间的距离，也就是应该要遍历多少个元素
    if (step &lt; 0) {
        if (*stop &lt; *start) {
            return (*start - *stop - 1) / (-step) + 1;
        }
    }
    else {
        if (*start &lt; *stop) {
            return (*stop - *start - 1) / step + 1;
        }
    }
    // 如果不符合条件的话，比如像 data[3: 8: -1]，显然遍历不到任何元素
    // 那么直接返回 0
    return 0;
}
</code></pre>
<p>可以看到，哪有什么岁月静好，我们之所以能够通过各种姿势使用切片，全靠解释器在替我们负重前行，它在背后做了非常多的工作。正如前面提到的，C 是一门很单纯的语言，Python 的花里胡哨的操作回归到 C 里面，就是普通的 if else 以及 while、for。</p>
<h2 id="小结"><a class="header" href="#小结">小结</a></h2>
<p>以上我们就介绍了切片的底层结构，切片也是一个对象，拥有自己的缓存。并且 Python 针对切片提供的语法也非常丰富：</p>
<ul>
<li>data[:: 1]，从左往右遍历，或者说从前往后遍历；</li>
<li>data[:: -1]，从右往左遍历；</li>
<li>data[:: 2]，只筛选索引为偶数的元素；</li>
<li>起始位置和终止位置可以为负数，会自动转成正数；</li>
</ul>
<p>所以切片用起来很方便，但要明白这背后都是因为解释器做了大量的工作。当然大部分情况下我们使用切片都是无感知的，一般不会刻意地想着要去创建一个切片，只是字符串、列表、元组等数据都支持通过切片截取数据，所以切片还是值得我们深入了解一下的。</p>
<hr />
<p> </p>
<p><strong>欢迎大家关注我的公众号：古明地觉的编程教室。</strong></p>
<p><img src="./images/qrcode_for_gh.jpg" alt="" /></p>
<p><strong>如果觉得文章对你有所帮助，也可以请作者吃个馒头，Thanks♪(･ω･)ﾉ。</strong></p>
<p><img src="./images/supports.png" alt="" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="21.Python的None是怎么实现的？.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="23.bytes对象（字节串）是怎么实现的？解密它的内部原理.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="21.Python的None是怎么实现的？.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="23.bytes对象（字节串）是怎么实现的？解密它的内部原理.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="theme/custom.js"></script>
    </body>
</html>
