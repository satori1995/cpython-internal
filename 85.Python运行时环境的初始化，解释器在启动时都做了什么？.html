<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>85. Python 运行时环境的初始化，解释器在启动时都做了什么？ - CPython3.8 源码探秘</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/custom.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="0.序言.html">0. 序言</a></li><li class="chapter-item expanded "><a href="1.CPython源码长什么样子？.html">1. CPython 源码长什么样子？</a></li><li class="chapter-item expanded "><a href="2.变量和对象，它们之间有什么区别和联系呢？.html">2. 变量和对象，它们之间有什么区别和联系呢？</a></li><li class="chapter-item expanded "><a href="3.Python对象有哪几种，我们可以从哪些角度进行分类呢？.html">3. Python 对象有哪几种，我们可以从哪些角度进行分类呢？</a></li><li class="chapter-item expanded "><a href="4.万丈高楼平地起，一切从PyObject开始.html">4. 万丈高楼平地起，一切从 PyObject 开始</a></li><li class="chapter-item expanded "><a href="5.详解PyTypeObject，Python类型对象的载体.html">5. 详解 PyTypeObject，Python 类型对象的载体</a></li><li class="chapter-item expanded "><a href="6.通过type和object之间的关联，进一步分析类型对象.html">6. 通过 type 和 object 之间的关联，进一步分析类型对象</a></li><li class="chapter-item expanded "><a href="7.当创建一个Python对象时，背后都经历了哪些过程？.html">7. 当创建一个 Python 对象时，背后都经历了哪些过程？</a></li><li class="chapter-item expanded "><a href="8.当调用一个Python对象时，背后都经历了哪些过程？.html">8. 当调用一个 Python 对象时，背后都经历了哪些过程？</a></li><li class="chapter-item expanded "><a href="9.再探泛型API，感受Python对象的设计哲学.html">9. 再探泛型 API，感受 Python 对象的设计哲学</a></li><li class="chapter-item expanded "><a href="10.Python对象的行为是怎么区分的？.html">10. Python 对象的行为是怎么区分的？</a></li><li class="chapter-item expanded "><a href="11.一个Python对象会在何时被销毁？.html">11. 一个 Python 对象会在何时被销毁？</a></li><li class="chapter-item expanded "><a href="12.深度解密Python的浮点数是怎么实现的？.html">12. 深度解密 Python 的浮点数是怎么实现的？</a></li><li class="chapter-item expanded "><a href="13.对象被销毁之后所占的内存一定会释放吗？解密浮点数的缓存池机制.html">13. 对象被销毁之后所占的内存一定会释放吗？解密浮点数的缓存池机制</a></li><li class="chapter-item expanded "><a href="14.浮点数支持的操作是怎么实现的？.html">14. 浮点数支持的操作是怎么实现的？</a></li><li class="chapter-item expanded "><a href="15.解密Python的复数是怎么实现的？它有什么用途呢？.html">15. 解密 Python 的复数是怎么实现的？它有什么用途呢？</a></li><li class="chapter-item expanded "><a href="16.Python的整数是怎么设计的，为什么它不会溢出？.html">16. Python 的整数是怎么设计的，为什么它不会溢出？</a></li><li class="chapter-item expanded "><a href="17.解密Python的小整数对象池.html">17. 解密 Python 的小整数对象池</a></li><li class="chapter-item expanded "><a href="18.两个Python整数之间是如何进行大小比较的？过程并不像我们想的那样简单.html">18. 两个 Python 整数之间是如何进行大小比较的？过程并不像我们想的那样简单</a></li><li class="chapter-item expanded "><a href="19.探究Python整数的加减法，感受大整数的运算哲学与魅力.html">19. 探究 Python 整数的加减法，感受大整数的运算哲学与魅力</a></li><li class="chapter-item expanded "><a href="20.Python的布尔值是怎么实现的，你对它的了解有多深呢？.html">20. Python 的布尔值是怎么实现的，你对它的了解有多深呢？</a></li><li class="chapter-item expanded "><a href="21.Python的None是怎么实现的？.html">21. Python 的 None 是怎么实现的？</a></li><li class="chapter-item expanded "><a href="22.深度解密Python切片的实现原理.html">22.深度解密 Python 切片的实现原理</a></li><li class="chapter-item expanded "><a href="23.bytes对象（字节串）是怎么实现的？解密它的内部原理.html">23. bytes 对象（字节串）是怎么实现的？解密它的内部原理</a></li><li class="chapter-item expanded "><a href="24.bytes对象都支持哪些操作，它们是怎么实现的？.html">24. bytes 对象都支持哪些操作，它们是怎么实现的？</a></li><li class="chapter-item expanded "><a href="25.通过bytes对象的合并，探究缓冲区的奥秘.html">25. 通过 bytes 对象的合并，探究缓冲区的奥秘</a></li><li class="chapter-item expanded "><a href="26.解密bytes对象的缓存池.html">26. 解密 bytes 对象的缓存池</a></li><li class="chapter-item expanded "><a href="27.详解bytearray对象的底层实现.html">27. 详解 bytearray 对象的底层实现</a></li><li class="chapter-item expanded "><a href="28.字符集和字符编码.html">28. 字符集和字符编码</a></li><li class="chapter-item expanded "><a href="29.Python是怎么存储字符串的？.html">29. Python 是怎么存储字符串的？</a></li><li class="chapter-item expanded "><a href="30.解密字符串的底层结构，它是怎么实现的？.html">30. 解密字符串的底层结构，它是怎么实现的？</a></li><li class="chapter-item expanded "><a href="31.字符串的intern机制是怎么一回事？.html">31. 字符串的 intern 机制是怎么一回事？</a></li><li class="chapter-item expanded "><a href="32.聊一聊字符串常见操作的源码实现.html">32. 聊一聊字符串常见操作的源码实现</a></li><li class="chapter-item expanded "><a href="33.列表是怎么实现的？解密列表的数据结构.html">33. 列表是怎么实现的？解密列表的数据结构</a></li><li class="chapter-item expanded "><a href="34.列表是怎么扩容的？.html">34. 列表是怎么扩容的？</a></li><li class="chapter-item expanded "><a href="35.解密列表的创建与销毁，以及缓存池长什么样子？.html">35. 解密列表的创建与销毁，以及缓存池长什么样子？</a></li><li class="chapter-item expanded "><a href="36.列表作为序列型对象都支持哪些操作，它们在底层是怎么实现的？.html">36. 列表作为序列型对象都支持哪些操作，它们在底层是怎么实现的？</a></li><li class="chapter-item expanded "><a href="37.列表都有哪些自定义方法，它们是怎么实现的？.html">37. 列表都有哪些自定义方法，它们是怎么实现的？</a></li><li class="chapter-item expanded "><a href="38.解密元组的实现原理.html">38. 解密元组的实现原理</a></li><li class="chapter-item expanded "><a href="39.聊一聊喜闻乐见的哈希表.html">39. 聊一聊喜闻乐见的哈希表</a></li><li class="chapter-item expanded "><a href="40.字典是怎么实现的，它的底层结构长什么样子？.html">40. 字典是怎么实现的，它的底层结构长什么样子？</a></li><li class="chapter-item expanded "><a href="41.什么是可哈希对象，它的哈希值是怎么计算的？.html">41. 什么是可哈希对象，它的哈希值是怎么计算的？</a></li><li class="chapter-item expanded "><a href="42.字典的key是怎么映射成索引的，索引冲突了又该怎么办？.html">42. 字典的 key 是怎么映射成索引的，索引冲突了又该怎么办？</a></li><li class="chapter-item expanded "><a href="43.哈希表是怎么删除元素的，能直接删除吗？.html">43. 哈希表是怎么删除元素的，能直接删除吗？</a></li><li class="chapter-item expanded "><a href="44.字典是怎么创建的，支持的操作又是如何实现的？.html">44. 字典是怎么创建的，支持的操作又是如何实现的？</a></li><li class="chapter-item expanded "><a href="45.字典的自定义方法是怎么实现的？.html">45. 字典的自定义方法是怎么实现的？</a></li><li class="chapter-item expanded "><a href="46.字典是怎么扩容的？它会经历哪些过程？.html">46. 字典是怎么扩容的？它会经历哪些过程？</a></li><li class="chapter-item expanded "><a href="47.身虽死，道未消，解密字典的缓存池.html">47. 身虽死，道未消，解密字典的缓存池</a></li><li class="chapter-item expanded "><a href="48.解密集合的实现原理.html">48. 解密集合的实现原理</a></li><li class="chapter-item expanded "><a href="49.集合支持的操作有哪些，它们是怎么实现的？.html">49. 集合支持的操作有哪些，它们是怎么实现的？</a></li><li class="chapter-item expanded "><a href="50.迭代器是怎么实现的？.html">50. 迭代器是怎么实现的？</a></li><li class="chapter-item expanded "><a href="51.Python源文件编译之后会得到什么，它的结构是怎样的？和字节码又有什么联系？.html">51. Python 源文件编译之后会得到什么，它的结构是怎样的？和字节码又有什么联系？</a></li><li class="chapter-item expanded "><a href="52.PyCodeObject拾遗.html">52. PyCodeObject 拾遗</a></li><li class="chapter-item expanded "><a href="53.一文让你搞懂pyc文件.html">53. 一文让你搞懂 pyc 文件</a></li><li class="chapter-item expanded "><a href="54.深度解密虚拟机的执行环境：栈帧对象.html">54. 深度解密虚拟机的执行环境：栈帧对象</a></li><li class="chapter-item expanded "><a href="55.名字空间：变量的容身之所.html">55. 名字空间：变量的容身之所</a></li><li class="chapter-item expanded "><a href="56.当查找一个变量时，虚拟机会进行哪些动作？.html">56. 当查找一个变量时，虚拟机会进行哪些动作？</a></li><li class="chapter-item expanded "><a href="57.虚拟机是怎么执行字节码的？背后都经历了哪些过程.html">57. 虚拟机是怎么执行字节码的？背后都经历了哪些过程</a></li><li class="chapter-item expanded "><a href="58.深入源码，进一步考察字节码的执行流程.html">58. 深入源码，进一步考察字节码的执行流程</a></li><li class="chapter-item expanded "><a href="59.局部变量是怎么实现静态查找的，它和local名字空间又有什么联系呢？.html">59. 局部变量是怎么实现静态查找的，它和 local 名字空间又有什么联系呢？</a></li><li class="chapter-item expanded "><a href="60.剖析字节码指令，以及Python赋值语句的原理.html">60. 剖析字节码指令，以及 Python 赋值语句的原理</a></li><li class="chapter-item expanded "><a href="61.流程控制语句if是怎么实现的？.html">61. 流程控制语句 if 是怎么实现的？</a></li><li class="chapter-item expanded "><a href="62.流程控制语句for、while是怎么实现的？.html">62. 流程控制语句 for、while 是怎么实现的？</a></li><li class="chapter-item expanded "><a href="63.异常是怎么实现的？虚拟机是如何将异常抛出去的？.html">63. 异常是怎么实现的？虚拟机是如何将异常抛出去的？</a></li><li class="chapter-item expanded "><a href="64.虚拟机是如何捕获异常的？.html">64. 虚拟机是如何捕获异常的？</a></li><li class="chapter-item expanded "><a href="65.函数在底层长什么样子？.html">65. 函数在底层长什么样子？</a></li><li class="chapter-item expanded "><a href="66.函数是怎么创建的，背后经历了哪些过程？.html">66. 函数是怎么创建的，背后经历了哪些过程？</a></li><li class="chapter-item expanded "><a href="67.函数在底层是如何调用的？.html">67. 函数在底层是如何调用的？</a></li><li class="chapter-item expanded "><a href="68.函数是如何解析位置参数的？.html">68. 函数是如何解析位置参数的？</a></li><li class="chapter-item expanded "><a href="69.函数是如何解析关键字参数的？.html">69. 函数是如何解析关键字参数的？</a></li><li class="chapter-item expanded "><a href="70.扩展位置参数和扩展关键字参数是如何解析的？.html">70. 扩展位置参数和扩展关键字参数是如何解析的？</a></li><li class="chapter-item expanded "><a href="71.闭包是怎么实现的？.html">71. 闭包是怎么实现的？</a></li><li class="chapter-item expanded "><a href="72.生成器是做什么的，为什么会有生成器？.html">72. 生成器是做什么的，为什么会有生成器？</a></li><li class="chapter-item expanded "><a href="73.源码解密生成器的实现原理.html">73. 源码解密生成器的实现原理</a></li><li class="chapter-item expanded "><a href="74.回顾Python的对象模型.html">74. 回顾 Python 的对象模型</a></li><li class="chapter-item expanded "><a href="75.class概念解析.html">75. class 概念解析</a></li><li class="chapter-item expanded "><a href="76.类型对象的初始化.html">76. 类型对象的初始化</a></li><li class="chapter-item expanded "><a href="77.自定义类对象的底层实现与metaclass.html">77. 自定义类对象的底层实现与 metaclass</a></li><li class="chapter-item expanded "><a href="78.彻底搞懂描述符.html">78. 彻底搞懂描述符</a></li><li class="chapter-item expanded "><a href="79.实例对象是如何创建的？.html">79. 实例对象是如何创建的？</a></li><li class="chapter-item expanded "><a href="80.实例对象的属性访问.html">80. 实例对象的属性访问</a></li><li class="chapter-item expanded "><a href="81.为什么实例在调用方法时会将自身传给self参数.html">81. 为什么实例在调用方法时会将自身传给 self 参数</a></li><li class="chapter-item expanded "><a href="82.模块是如何导入的？.html">82. 模块是如何导入的？</a></li><li class="chapter-item expanded "><a href="83.import机制的黑盒探测.html">83. import 机制的黑盒探测</a></li><li class="chapter-item expanded "><a href="84.import机制是怎么实现的？.html">84. import 机制是怎么实现的？</a></li><li class="chapter-item expanded "><a href="85.Python运行时环境的初始化，解释器在启动时都做了什么？.html" class="active">85. Python 运行时环境的初始化，解释器在启动时都做了什么？</a></li><li class="chapter-item expanded "><a href="86.激活Python虚拟机.html">86. 激活 Python 虚拟机</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">CPython3.8 源码探秘</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/satori1995/cpython-internal" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="楔子"><a class="header" href="#楔子">楔子</a></h2>
<p>我们之前完成了 Python 的字节码、以及虚拟机的剖析工作，但这仅仅只是一部分，而其余的部分则被遮在了幕后。记得在分析虚拟机的时候，曾这么说过：</p>
<blockquote>
<p>解释器启动时，首先会进行 &quot;运行时环境&quot; 的初始化，关于 &quot;运行时环境&quot; 的初始化是一个非常复杂的过程。并且 &quot;运行时环境&quot; 和 &quot;执行环境&quot; 是不同的，&quot;运行时环境&quot; 是一个全局的概念，而 &quot;执行环境&quot; 是一个栈帧。关于 &quot;运行时环境&quot; 后面会单独分析，这里就假设初始化动作已经完成，我们已经站在了虚拟机的门槛外面，只需要轻轻推动第一张骨牌，整个执行过程就会像多米诺骨牌一样，一环扣一环地展开。</p>
</blockquote>
<p>所以这次，我们将回到时间的起点，从 Python 的应用程序被执行开始，一步一步紧紧跟随 Python 的轨迹，完整地展示解释器在启动之初的所有动作。当我们了解所有的初始化动作之后，也就能对 Python 引擎执行字节码指令时的整个运行环境了如指掌了。</p>
<h2 id="线程模型"><a class="header" href="#线程模型">线程模型</a></h2>
<p>我们知道线程是操作系统调度的最小单元，那么 Python 的线程又是怎样的呢？</p>
<p>启动一个 Python 线程，底层会启动一个 C 线程，然后启动操作系统的一个原生线程（OS 线程）。所以 Python 线程实际上是对 OS 线程的一个封装，因此 Python 的线程是货真价实的。</p>
<p>然后 Python 还提供了一个 PyThreadState 对象，也就是线程状态对象，维护 OS 线程执行的状态信息，相当于是 OS 线程的一个抽象描述。虽然真正用来执行的线程及其状态肯定是由操作系统进行维护的，但 Python 虚拟机在运行的时候总需要另外一些与线程相关的状态和信息，比如是否发生了异常等等，这些信息显然操作系统是没有办法提供的。</p>
<p>而 PyThreadState 对象正是为 OS 线程准备的、在虚拟机层面保存其状态信息的对象，也就是线程状态对象。在 Python 中，当前活动的 OS 线程对应的 PyThreadState 对象可以通过调用 PyThreadState_GET 函数获得，有了线程状态对象之后，就可以设置一些额外信息了。具体内容，我们后面会说。</p>
<p>当然除了线程状态对象之外，还有进程状态对象，我们来看看两者在底层的定义是什么？它们位于 Include/pystate.h 中。</p>
<pre><code class="language-c">// ts 是 thread state 的简写
typedef struct _ts PyThreadState;
// is 是 interpreter state 的简写
typedef struct _is PyInterpreterState;
</code></pre>
<p>里面的 PyThreadState 表示线程状态对象，PyInterpreterState 表示进程状态对象，但它们都是 typedef 起的一个别名。前者是 struct _ts 的别名，后者是 struct _is 的别名，来看一下它们长什么样。</p>
<pre><code class="language-C">// Include/cpython/pystate.h

// Python 的异常信息有三个属性
// exc_type：异常类型；exc_value：异常值，说白了就是异常本身；exc_traceback：异常的回溯栈
// 而 _PyErr_StackItem 相当于对这三个属性做了封装，并且还通过 previous_item 形成了一个链表
typedef struct _err_stackitem {
    PyObject *exc_type, *exc_value, *exc_traceback;
    struct _err_stackitem *previous_item;
} _PyErr_StackItem;

struct _ts {
    // 指向上一个线程状态对象
    struct _ts *prev;
    // 指向下一个线程状态对象    
    struct _ts *next;
    // 进程状态对象，因为每个线程都隶属于一个进程
    PyInterpreterState *interp;
    // 当前正在执行的栈桢
    struct _frame *frame;
    // 递归深度
    int recursion_depth;
    // 标记栈是否溢出，如果溢出，还允许 50 次调用来处理运行时错误
    char overflowed;
    // 标记当前调用不能导致栈溢出的标志位
    char recursion_critical;
    // 栈检查计数器
    int stackcheck_counter;
    // 追踪和性能分析时的执行深度计数器
    int tracing;
    // 是否启用追踪
    int use_tracing;
    // C 级性能分析的函数指针
    Py_tracefunc c_profilefunc;
    // C 级追踪函数指针
    Py_tracefunc c_tracefunc;
    // Python 级性能分析对象
    PyObject *c_profileobj;
    // Python 级追踪对象
    PyObject *c_traceobj;
    // 当前抛出的异常信息
    PyObject *curexc_type;
    PyObject *curexc_value;
    PyObject *curexc_traceback;
    // 当前正在处理的异常状态（如果没有协程/生成器）
    _PyErr_StackItem exc_state;
    // 指向当前正在处理的异常栈的栈顶
    // 估计有人好奇 exc_state 和 exc_info 啥区别，我们稍后说
    _PyErr_StackItem *exc_info;
    // 存储线程状态信息的字典
    PyObject *dict;
    // GIL 状态计数器
    int gilstate_counter;
    // 待抛出的异步异常
    PyObject *async_exc;
    // 创建该线程状态对象的线程 ID
    unsigned long thread_id;
    // 嵌套层级，用于延迟删除
    int trash_delete_nesting;
    // 延迟删除的对象，关于延迟删除，我们介绍列表的时候说过
    PyObject *trash_delete_later;
    // 线程状态正常删除时的回调函数
    void (*on_delete)(void *);
    // 回调函数的数据参数（实现为一个指向锁的弱引用）
    void *on_delete_data;
    // 协程起源追踪深度
    int coroutine_origin_tracking_depth;
    // 当异步生成器首次迭代时，用于存储相关状态和处理异常
    PyObject *async_gen_firstiter;
    // 当异步生成器被垃圾回收时，用于执行必要的清理工作
    PyObject *async_gen_finalizer;
    // 上下文对象
    PyObject *context;
    // 上下文版本号
    uint64_t context_ver;
    // 线程状态对象的唯一标识符
    uint64_t id;
};
</code></pre>
<p>以上是线程状态对象，然后我们再来看看进程状态对象。需要补充的是，struct _is、或者说 PyInterpreterState 在严格意义上应该叫做解释器状态对象。我们知道当解释器启动后会创建一个进程，但这两者并不是一对一的，因为 CPython 支持多解释器模式。也就是说可以在一个进程中启动多个解释器，这种模式一般应用在嵌入式 Python 或需要隔离环境的情况。</p>
<p>但是多解释器模式只能通过手动调用 Python/C API 实现，Python 代码层面无法直接创建和管理多个解释器，所以默认一个进程只会对应一个解释器实例。因此为了和线程对应，我们这里称 PyInterpreterState 为进程状态对象。</p>
<pre><code class="language-c">// Include/internal/pycore_pystate.h

struct _is {
    // Python 支持多进程，多个进程状态对象也会以链表的形式进行组织
    // next 字段会指向下一个进程状态对象
    struct _is *next;
    // 每个进程内部可以有很多个线程，那么自然就会有很多个线程状态对象
    // 这些线程状态对象会以链表的形式串起来，而 tstate_head 指向链表的头节点
    struct _ts *tstate_head;
    // 进程状态对象的 ID
    int64_t id;
    // 进程状态对象的引用计数
    int64_t id_refcount;
    // 指示解释器是否需要引用计数跟踪
    // 当多个子解释器共享同一个 ID 时，此标志用于确保 ID 的正确管理和清理
    int requires_idref;
    // ID 相关的互斥锁
    PyThread_type_lock id_mutex;
    // 终止标志
    int finalizing;
    // sys.modules，所以可以看出，多个线程共用一个 sys.modules
    PyObject *modules;
    // 按模块索引存储的缓存，它允许通过数字索引快速访问模块
    // 而不是每次都通过模块名在 modules 字典中查找，提高了模块访问性能
    PyObject *modules_by_index;
    // sys 模块的属性字典
    PyObject *sysdict;
    // 内置名称空间
    PyObject *builtins;
    // 导入机制
    PyObject *importlib;
    // 线程切换检查间隔
    int check_interval;
    // 进程内部的线程数量
    long num_threads;
    // 线程栈大小
    size_t pythread_stacksize;
    // 编解码器搜索路径
    PyObject *codec_search_path;
    // 编解码器缓存
    PyObject *codec_search_cache;
    // 存储自定义的编解码错误处理器
    // 允许通过 codecs.register_error() 注册新的错误处理策略，用于处理编解码过程中遇到的错误
    PyObject *codec_error_registry;
    // 表示编解码系统是否已经完成初始化，为 1 时表示已初始化，0 表示未初始化
    int codecs_initialized;
    // 文件系统编码设置
    struct {
        char *encoding;   /* Filesystem encoding (encoded to UTF-8) */
        char *errors;     /* Filesystem errors (encoded to UTF-8) */
        _Py_error_handler error_handler;
    } fs_codec;
    // 解释器的配置参数结构体
    // 包含：路径设置、命令行参数、环境变量设置、编码设置、性能和调试选项、内存分配器设置、隔离选项等
    PyConfig config;
    // 控制动态库加载行为的标志位，用于 dlopen() 函数调用
    // 这个标志决定了动态库加载时的符号解析策略和可见性
#ifdef HAVE_DLOPEN
    int dlopenflags;
#endif
    // 存储进程状态信息的字典
    PyObject *dict;
    // 内置名字空间的备份副本，用于在必要时恢复到内置名字空间的默认状态
    // 这是一个安全措施，防止内置名字空间被意外修改。
    PyObject *builtins_copy;
    // 存储当前解释器使用的导入函数，通常是 __import__ 函数
    // 因此解释器也允许自定义模块导入行为，用于实现特殊的导入逻辑
    PyObject *import_func;
    // 帧评估函数，默认是 _PyEval_EvalFrameDefault
    // 所以解释器也支持自定义帧评估函数，即自定义字节码执行逻辑
    _PyFrameEvalFunction eval_frame;
        Py_ssize_t co_extra_user_count;
    freefunc co_extra_freefuncs[MAX_CO_EXTRA_USERS];

#ifdef HAVE_FORK
    PyObject *before_forkers;
    PyObject *after_forkers_parent;
    PyObject *after_forkers_child;
#endif
    /* AtExit module */
    void (*pyexitfunc)(PyObject *);
    PyObject *pyexitmodule;

    uint64_t tstate_next_unique_id;

    struct _warnings_runtime_state warnings;

    PyObject *audit_hooks;
};
</code></pre>
<p>所以 PyInterpreterState 对象可以看成是对进程的模拟， PyThreadState 对象可以看成是对线程的模拟。我们之前分析虚拟机的时候说过执行环境，如果再将运行时环境加进去的话。</p>
<p><img src="./images/276.png" alt="" /></p>
<p>进程状态对象的 tstate_head 指向了线程状态对象，对应当前活跃的 Python 线程；而每个线程状态对象的 frame 都指向当前正在执行的栈帧对象。</p>
<h2 id="线程环境的初始化"><a class="header" href="#线程环境的初始化">线程环境的初始化</a></h2>
<p>在解释器启动之后，初始化的动作是从 Py_NewInterpreter 函数开始的，然后这个函数调用了 new_interpreter 函数完成初始化。至于这两个函数长什么样一会儿再聊，先往后看。</p>
<p>我们知道当操作系统在运行一个可执行文件时，首先会创建一个进程内核。同理在 Python 中亦是如此，会在 new_interpreter 中调用 PyInterpreterState_New 创建一个崭新的 PyInterpreterState 对象，该函数位于 Python/pystate.c 中。</p>
<pre><code class="language-C">PyInterpreterState *
PyInterpreterState_New(void)
{
    // 触发审计事件
    if (PySys_Audit(&quot;cpython.PyInterpreterState_New&quot;, NULL) &lt; 0) {
        return NULL;
    }
    // 为进程状态对象分配内存
    PyInterpreterState *interp = PyMem_RawMalloc(sizeof(PyInterpreterState));
    if (interp == NULL) {
        return NULL;
    }
    // 初始化内存
    memset(interp, 0, sizeof(*interp));
    interp-&gt;id_refcount = -1;
    // 每个线程执行 100 条字节码后进行切换
    interp-&gt;check_interval = 100;
    // 初始化 Python 配置
    PyConfig_InitPythonConfig(&amp;interp-&gt;config);
    // 设置帧评估函数，默认为 _PyEval_EvalFrameDefault
    interp-&gt;eval_frame = _PyEval_EvalFrameDefault;
    // 设置动态库加载标志
#ifdef HAVE_DLOPEN
#if HAVE_DECL_RTLD_NOW
    interp-&gt;dlopenflags = RTLD_NOW;
#else
    interp-&gt;dlopenflags = RTLD_LAZY;
#endif
#endif
    // _PyRuntimeState 是 Python 解释器的全局运行时状态结构体，管理以下内容
    // GIL 锁相关的状态、解释器链表、垃圾回收系统状态、核心模块和类型
    // 信号处理、内存分配器、线程状态追踪、全局审计钩子等
    // 注：每个进程只有一个全局运行时（_PyRuntime），它是最高级的运行时状态容器
    _PyRuntimeState *runtime = &amp;_PyRuntime;
    // struct pyinterpreters 内部有四个字段
    // PyThread_type_lock mutex：互斥锁
    // PyInterpreterState *head：进程状态对象的头结点
    // PyInterpreterState *main：主进程对应的进程状态对象
    // int64_t next_id：下一个可用的解释器 ID，注意：主解释器 ID、或者说主进程状态对象的 ID 永远是 0
    struct pyinterpreters *interpreters = &amp;runtime-&gt;interpreters;
    
    // 获取全局解释器锁，用于保护解释器链表的操作
    // 它确保在多线程环境下，解释器的创建和管理是线程安全的
    HEAD_LOCK(runtime);
    // next_id 必须大于等于 0
    if (interpreters-&gt;next_id &lt; 0) {
        PyErr_SetString(PyExc_RuntimeError,
                        &quot;failed to get an interpreter ID&quot;);
        PyMem_RawFree(interp);
        interp = NULL;
    }
    else {
        // 分配新 ID 并更新 next_id
        interp-&gt;id = interpreters-&gt;next_id;
        interpreters-&gt;next_id += 1;
        // 让新创建的进程状态对象 interp，成为进程状态对象链表的头结点
        // 所以它的 next 要等于 interpreters-&gt;head
        interp-&gt;next = interpreters-&gt;head;
        // 如果 interpreters-&gt;main 等于 NULL，说明当前的进程是第一个进程
        // 那么显然它就是主进程，而之后创建的进程就是子进程了
        if (interpreters-&gt;main == NULL) {
            interpreters-&gt;main = interp;
        }
        // 然后再让 interpreters-&gt;head 等于 interp
        interpreters-&gt;head = interp;
    }
    HEAD_UNLOCK(runtime);

    if (interp == NULL) {
        return NULL;
    }

    interp-&gt;tstate_next_unique_id = 0;
    interp-&gt;audit_hooks = NULL;
    return interp;
}
</code></pre>
<p>所以解释器在启动时，会创建一个 PyInterpreterState 对象。如果开启了多进程，那么内部会继续创建，然后通过 next 指针将多个 PyInterpreterState 串成一个链表结构。</p>
<p>在调用 PyInterpreterState_New 成功创建 PyInterpreterState 之后，会再接再厉，调用 PyThreadState_New 创建一个全新的线程状态对象，相关函数定义同样位于 Python/pystate.c 中。</p>
<pre><code class="language-C">PyThreadState *
PyThreadState_New(PyInterpreterState *interp)
{
    return new_threadstate(interp, 1);
}
</code></pre>
<p>我们注意到这个函数接收一个 PyInterpreterState，这说明线程是依赖进程的，因为需要进程给自己分配资源，然后这个函数又调用了 new_threadstate。除了传递 PyInterpreterState 之外，还传了一个 1，想也不用想这肯定是创建的线程数量。这里创建 1 个，也就是主线程（main thread）。</p>
<pre><code class="language-C">static PyThreadState *
new_threadstate(PyInterpreterState *interp, int init)
{
    _PyRuntimeState *runtime = &amp;_PyRuntime;
    // 为线程状态对象申请内存
    PyThreadState *tstate = (PyThreadState *)PyMem_RawMalloc(sizeof(PyThreadState));
    if (tstate == NULL) {
        return NULL;
    }
    // 设置从线程中获取函数调用栈的操作
    if (_PyThreadState_GetFrame == NULL) {
        _PyThreadState_GetFrame = threadstate_getframe;
    }
    // 下面就是设置内部的字段属性
    // 该线程所在的进程
    tstate-&gt;interp = interp;
    // 当前正在执行的栈桢，初始为 NULL
    tstate-&gt;frame = NULL;
    // 递归深度，初始为 0
    tstate-&gt;recursion_depth = 0;
    tstate-&gt;overflowed = 0;
    tstate-&gt;recursion_critical = 0;
    tstate-&gt;stackcheck_counter = 0;
    tstate-&gt;tracing = 0;
    tstate-&gt;use_tracing = 0;
    tstate-&gt;gilstate_counter = 0;
    tstate-&gt;async_exc = NULL;
    tstate-&gt;thread_id = PyThread_get_thread_ident();

    tstate-&gt;dict = NULL;

    tstate-&gt;curexc_type = NULL;
    tstate-&gt;curexc_value = NULL;
    tstate-&gt;curexc_traceback = NULL;

    tstate-&gt;exc_state.exc_type = NULL;
    tstate-&gt;exc_state.exc_value = NULL;
    tstate-&gt;exc_state.exc_traceback = NULL;
    tstate-&gt;exc_state.previous_item = NULL;
    tstate-&gt;exc_info = &amp;tstate-&gt;exc_state;

    tstate-&gt;c_profilefunc = NULL;
    tstate-&gt;c_tracefunc = NULL;
    tstate-&gt;c_profileobj = NULL;
    tstate-&gt;c_traceobj = NULL;

    tstate-&gt;trash_delete_nesting = 0;
    tstate-&gt;trash_delete_later = NULL;
    tstate-&gt;on_delete = NULL;
    tstate-&gt;on_delete_data = NULL;

    tstate-&gt;coroutine_origin_tracking_depth = 0;

    tstate-&gt;async_gen_firstiter = NULL;
    tstate-&gt;async_gen_finalizer = NULL;

    tstate-&gt;context = NULL;
    tstate-&gt;context_ver = 1;

    if (init) {
        _PyThreadState_Init(runtime, tstate);
    }

    HEAD_LOCK(runtime);
    tstate-&gt;id = ++interp-&gt;tstate_next_unique_id;
    tstate-&gt;prev = NULL;
    // 当前线程状态对象的 next，我们看到指向了线程状态对象链表的头结点
    tstate-&gt;next = interp-&gt;tstate_head;
    // 因为每个线程状态对象的 prev 指针都要指向上一个线程状态对象
    // 如果是头结点的话，那么 prev 就是 NULL
    // 但由于新的线程状态对象在插入之后变成了链表的新的头结点
    // 因此还需要将插入之前的头结点的 prev 指向新插入的线程状态对象
    if (tstate-&gt;next)
        tstate-&gt;next-&gt;prev = tstate;
    // 将 tstate 设置为线程状态对象链表的新的头结点
    interp-&gt;tstate_head = tstate;
    HEAD_UNLOCK(runtime);
    // 返回线程状态对象
    return tstate;
}
</code></pre>
<p>和 PyInterpreterState_New 相同， PyThreadState_New 会申请内存，创建线程状态对象，并且对每个字段进行初始化。其中 prev 指针和 next 指针分别指向了上一个线程状态对象和下一个线程状态对象。而且也肯定会存在某一时刻，会有多个 PyThreadState 对象组成一个链表，那什么时刻会发生这种情况呢？显然用鼻子想也知道这是在启动多线程的时候。</p>
<blockquote>
<p>Python 在插入线程状态对象的时候采用的是头插法。</p>
</blockquote>
<p>从源码中我们看到，虚拟机设置了从线程中获取函数调用栈的操作，所谓函数调用栈就是前面说的 PyFrameObject 对象链表。而且在源码中，PyThreadState 关联了 PyInterpreterState，PyInterpreterState 也关联了 PyInterpreterState 。</p>
<p>到目前为止，仅有的两个对象建立起了联系。而对应到操作系统，就是进程和线程建立了联系。</p>
<p>而在两者建立了联系之后，那么就很容易在 PyInterpreterState 和 PyThreadState 之间穿梭。并且在 Python 运行时环境中，会有一个变量（先卖个关子）一直维护着当前活动的线程，更准确的说是当前活动线程（OS 线程）对应的 PyThreadState 对象。初始时，该变量为 NULL，在 Python 启动并创建了第一个 PyThreadState 之后，会调用 PyThreadState_Swap 函数来设置这个变量。</p>
<pre><code class="language-C">// Python/pystate.c
PyThreadState *
PyThreadState_Swap(PyThreadState *newts)
{
    // 调用了 _PyThreadState_Swap，里面传入了两个参数
    // 第一个我们后面说，从名字上看显然这是和 GIL 相关的
    // 第二个参数就是新创建的线程状态对象
    return _PyThreadState_Swap(&amp;_PyRuntime.gilstate, newts);
}

PyThreadState *
_PyThreadState_Swap(struct _gilstate_runtime_state *gilstate, PyThreadState *newts)
{
    // 获取当前的线程状态对象，并且保证线程的安全
    PyThreadState *oldts = _PyRuntimeGILState_GetThreadState(gilstate);
    // 将 GIL 交给 newts，也就是新创建、即将获取执行权的线程状态对象
    _PyRuntimeGILState_SetThreadState(gilstate, newts);
    // ...
    return oldts;
}
</code></pre>
<p>所以逻辑很容易理解，有一个<strong>变量</strong>始终维护着当前活跃线程对应的线程状态对象，初始时它是个 NULL。而一旦解释器启动，并创建了第一个线程状态对象（显然对应主线程），那么就会将创建的线程状态对象交给这个<strong>变量</strong>保存。</p>
<p>如果调用 _PyThreadState_Swap 的时候，发现保存线程状态对象的<strong>变量</strong>不为 NULL，那么说明开启了多线程。<strong>变量</strong>保存的就是代码中的 oldts，也就是当前活动线程对应的线程状态对象，可由于它的时间片耗尽，解释器会剥夺它的执行权，然后交给 newts。那么 newts 就成为了新的当前活跃线程对应的线程状态对象，那么它也要交给<strong>变量</strong>进行保存。</p>
<p>而通过 _PyThreadState_Swap 可以看到，想要实现这一点，主要依赖两个宏。</p>
<pre><code class="language-c">// 通过 &amp;(gilstate)-&gt;tstate_current 获取当前活动线程（的线程状态对象）
#define _PyRuntimeGILState_GetThreadState(gilstate) \
    ((PyThreadState*)_Py_atomic_load_relaxed(&amp;(gilstate)-&gt;tstate_current))

// 将 newts 设置为新的活跃线程，可以理解为发生了线程切换
#define _PyRuntimeGILState_SetThreadState(gilstate, value) \
    _Py_atomic_store_relaxed(&amp;(gilstate)-&gt;tstate_current, \
                             (uintptr_t)(value))
</code></pre>
<p>然后这两个宏里面出现了 _Py_atomic_load_relaxed、_Py_atomic_store_relaxed 和 &amp;(gilstate)-&gt;tstate_current ，这些又是什么呢？还有到底是哪个变量在维护着当前活动线程对应的线程状态对象呢？其实那两个宏已经告诉你了。</p>
<pre><code class="language-C">//Include/internal/pycore_pystate.h
struct _gilstate_runtime_state {
    // GIL 检查是否启用
    int check_enabled;
    // 持有 GIL 的活动线程对应的线程状态对象
    _Py_atomic_address tstate_current;
    // 函数指针，用于获取栈桢
    PyThreadFrameGetter getframe;
    PyInterpreterState *autoInterpreterState;
    Py_tss_t autoTSSkey;
};

//Include/internal/pycore_atomic.h
#define _Py_atomic_store_relaxed(ATOMIC_VAL, NEW_VAL) \
    _Py_atomic_store_explicit((ATOMIC_VAL), (NEW_VAL), _Py_memory_order_relaxed)
#define _Py_atomic_load_relaxed(ATOMIC_VAL) \
    _Py_atomic_load_explicit((ATOMIC_VAL), _Py_memory_order_relaxed)

#define _Py_atomic_store_explicit(ATOMIC_VAL, NEW_VAL, ORDER) \
    atomic_store_explicit(&amp;((ATOMIC_VAL)-&gt;_value), NEW_VAL, ORDER)
#define _Py_atomic_load_explicit(ATOMIC_VAL, ORDER) \
    atomic_load_explicit(&amp;((ATOMIC_VAL)-&gt;_value), ORDER)
</code></pre>
<p>不难发现：</p>
<ul>
<li>_Py_atomic_load_relaxed 调用了 _Py_atomic_load_explicit，_Py_atomic_load_explicit 又调用了 atomic_load_explicit。</li>
<li>_Py_atomic_store_relaxed 调用了 _Py_atomic_store_explicit，_Py_atomic_store_explicit 调用了 atomic_store_explicit。</li>
</ul>
<p>而 atomic_load_explicit 和 atomic_store_explicit 是系统头文件 stdatomic.h 中定义的 api，这是在系统的 api 中修改的，所以说是线程安全的。</p>
<p>介绍完中间部分的内容，那么我们可以从头开始分析 Python 运行时环境的初始化了，我们说它是从 Py_NewInterpreter 开始的。</p>
<pre><code class="language-C">// Python/pylifecycle.c
PyThreadState *
Py_NewInterpreter(void)
{   
    // 线程状态对象
    PyThreadState *tstate = NULL;
    // 传入线程状态对象，调用 new_interpreter
    PyStatus status = new_interpreter(&amp;tstate);
    if (_PyStatus_EXCEPTION(status)) {
        Py_ExitStatusException(status);
    }
    // 返回线程状态对象
    return tstate;
}
</code></pre>
<p>然后我们的重点是 new_interpreter 函数，进程状态对象的创建就是在这个函数里面发生的。</p>
<pre><code class="language-C">// Include/cpython/initconfig.h
// 程序执行的状态
typedef struct {
    enum {
        _PyStatus_TYPE_OK=0,     // 正常
        _PyStatus_TYPE_ERROR=1,  // 错误
        _PyStatus_TYPE_EXIT=2    // 退出
    } _type;
    const char *func;     // 发生错误的函数名
    const char *err_msg;  // 错误消息
    int exitcode;         // 退出码
} PyStatus;


// Python/pylifecycle.c
static PyStatus
new_interpreter(PyThreadState **tstate_p)
{
    PyStatus status;
    // 运行时初始化，如果出现异常直接返回
    status = _PyRuntime_Initialize();
    if (_PyStatus_EXCEPTION(status)) {
        return status;
    }
    // 获取运行时
    _PyRuntimeState *runtime = &amp;_PyRuntime;
    if (!runtime-&gt;initialized) {
        return _PyStatus_ERR(&quot;Py_Initialize must be called first&quot;);
    }
    // GIL API 在多解释器环境下存在问题，无法正常工作，因此需要禁用 PyGILState_Check() 来避免问题
    _PyGILState_check_enabled = 0;
    // 创建进程状态对象
    PyInterpreterState *interp = PyInterpreterState_New();
    if (interp == NULL) {
        *tstate_p = NULL;
        return _PyStatus_OK();
    }
    // 根据进程状态对象创建线程状态对象，维护对应的 OS 线程的状态
    PyThreadState *tstate = PyThreadState_New(interp);
    if (tstate == NULL) {
        PyInterpreterState_Delete(interp);
        *tstate_p = NULL;
        return _PyStatus_OK();
    }
    // 将 GIL 的控制权交给创建的线程
    PyThreadState *save_tstate = PyThreadState_Swap(tstate);

    // 从当前或主进程状态对象复制配置到新的进程状态对象
    PyConfig *config;
    if (save_tstate != NULL) {
        config = &amp;save_tstate-&gt;interp-&gt;config;
    } else {
        PyInterpreterState *main_interp = PyInterpreterState_Main();
        config = &amp;main_interp-&gt;config;
    }
    status = _PyConfig_Copy(&amp;interp-&gt;config, config);
    if (_PyStatus_EXCEPTION(status)) {
        return status;
    }
    config = &amp;interp-&gt;config;
    
    // 异常系统初始化
    status = _PyExc_Init();
    if (_PyStatus_EXCEPTION(status)) {
        return status;
    }
    status = _PyErr_Init();
    if (_PyStatus_EXCEPTION(status)) {
        return status;
    }

    // 创建模块字典
    PyObject *modules = PyDict_New();
    if (modules == NULL) {
        return _PyStatus_ERR(&quot;can't make modules dictionary&quot;);
    }
    interp-&gt;modules = modules;
    
    // 初始化 sys 模块
    PyObject *sysmod = _PyImport_FindBuiltin(&quot;sys&quot;, modules);
    if (sysmod != NULL) {
        interp-&gt;sysdict = PyModule_GetDict(sysmod);
        if (interp-&gt;sysdict == NULL) {
            goto handle_error;
        }
        Py_INCREF(interp-&gt;sysdict);
        PyDict_SetItemString(interp-&gt;sysdict, &quot;modules&quot;, modules);
        if (_PySys_InitMain(runtime, interp) &lt; 0) {
            return _PyStatus_ERR(&quot;can't finish initializing sys&quot;);
        }
    }
    else if (PyErr_Occurred()) {
        goto handle_error;
    }
    
    // 初始化 builtins 模块
    PyObject *bimod = _PyImport_FindBuiltin(&quot;builtins&quot;, modules);
    if (bimod != NULL) {
        interp-&gt;builtins = PyModule_GetDict(bimod);
        if (interp-&gt;builtins == NULL)
            goto handle_error;
        Py_INCREF(interp-&gt;builtins);
    }
    else if (PyErr_Occurred()) {
        goto handle_error;
    }
    
    if (bimod != NULL &amp;&amp; sysmod != NULL) {
        // 添加内置异常
        status = _PyBuiltins_AddExceptions(bimod);
        if (_PyStatus_EXCEPTION(status)) {
            return status;
        }
        status = _PySys_SetPreliminaryStderr(interp-&gt;sysdict);
        if (_PyStatus_EXCEPTION(status)) {
            return status;
        }
        
        status = _PyImportHooks_Init();
        if (_PyStatus_EXCEPTION(status)) {
            return status;
        }
        
        // 初始化导入系统
        status = init_importlib(interp, sysmod);
        if (_PyStatus_EXCEPTION(status)) {
            return status;
        }

        status = init_importlib_external(interp);
        if (_PyStatus_EXCEPTION(status)) {
            return status;
        }
        
        // 初始化编码
        status = _PyUnicode_InitEncodings(tstate);
        if (_PyStatus_EXCEPTION(status)) {
            return status;
        }
        
        // 设置标准流
        status = init_sys_streams(interp);
        if (_PyStatus_EXCEPTION(status)) {
            return status;
        }
        
        // 添加 main 模块
        status = add_main_module(interp);
        if (_PyStatus_EXCEPTION(status)) {
            return status;
        }
        
        // 初始化 site 导入
        if (config-&gt;site_import) {
            status = init_import_size();
            if (_PyStatus_EXCEPTION(status)) {
                return status;
            }
        }
    }

    if (PyErr_Occurred()) {
        goto handle_error;
    }

    *tstate_p = tstate;
    return _PyStatus_OK();

handle_error:
    // 错误处理，如果失败则清理所有资源并恢复原状态
    PyErr_PrintEx(0);
    PyThreadState_Clear(tstate);
    PyThreadState_Swap(save_tstate);
    PyThreadState_Delete(tstate);
    PyInterpreterState_Delete(interp);

    *tstate_p = NULL;
    return _PyStatus_OK();
}
</code></pre>
<p>Python 在初始化运行时环境时，肯定也要对类型系统进行初始化等等，整体是一个非常庞大的过程。</p>
<p>到这里，我们对 new_interpreter 的探索算是有了一个阶段性的成功，我们创建了代表进程和线程概念的 PyInterpreterState 和 PyThreadState 对象，并在它们之间建立了联系。下面 new_interpreter 将进入另一个环节，设置系统 module。</p>
<h2 id="创建-builtins-模块"><a class="header" href="#创建-builtins-模块">创建 builtins 模块</a></h2>
<p>在 new_interpreter 中创建了 PyInterpreterState 和 PyThreadState 对象之后，就会开始设置系统的 builtins 了。</p>
<pre><code class="language-C">static PyStatus
new_interpreter(PyThreadState **tstate_p)
{
    // ...
    // 申请一个 PyDictObject 对象，用于 sys.modules
    PyObject *modules = PyDict_New();
    if (modules == NULL) {
        return _PyStatus_ERR(&quot;can't make modules dictionary&quot;);
    }
    // 然后让 interp -&gt; modules 维护 modules
    // 由于 interp 表示的是进程状态对象，这说明什么? 
    // 显然是该进程内的多个线程共享同一个 sys.modules
    interp-&gt;modules = modules;
    // 加载 sys 模块，所有的 module 对象都在 sys.modules 中
    PyObject *sysmod = _PyImport_FindBuiltin(&quot;sys&quot;, modules);
    if (sysmod != NULL) {
        interp-&gt;sysdict = PyModule_GetDict(sysmod);
        if (interp-&gt;sysdict == NULL) {
            goto handle_error;
        }
        Py_INCREF(interp-&gt;sysdict);
        PyDict_SetItemString(interp-&gt;sysdict, &quot;modules&quot;, modules);
        if (_PySys_InitMain(runtime, interp) &lt; 0) {
            return _PyStatus_ERR(&quot;can't finish initializing sys&quot;);
        }
    }
    else if (PyErr_Occurred()) {
        goto handle_error;
    }
    // 加载内置模块 builtins
    PyObject *bimod = _PyImport_FindBuiltin(&quot;builtins&quot;, modules);
    if (bimod != NULL) {
        // 设置内置名字空间
        interp-&gt;builtins = PyModule_GetDict(bimod);
        if (interp-&gt;builtins == NULL)
            goto handle_error;
        Py_INCREF(interp-&gt;builtins);
    }
    // ...
}  
</code></pre>
<p>整体还是比较清晰和直观的，另外我们说内置名字空间是由进程来维护的，因为进程就是用来为线程提供资源的。但是也能看出，一个进程内的多个线程共享同一个内置名字空间。显然这是非常合理的，不可能每开启一个线程，就为其创建一个 builtins。我们来从 Python 的角度证明这一点：</p>
<pre><code class="language-Python">import threading
import builtins

def foo1():
    builtins.list, builtins.tuple = builtins.tuple, builtins.list

def foo2():
    print(f&quot;猜猜下面代码会输出什么：&quot;)
    print(&quot;list:&quot;, list([1, 2, 3, 4, 5]))
    print(&quot;tuple:&quot;, tuple([1, 2, 3, 4, 5]))

f1 = threading.Thread(target=foo1)
f1.start()
f1.join()
threading.Thread(target=foo2).start()
&quot;&quot;&quot;
猜猜下面代码会输出什么：
list: (1, 2, 3, 4, 5)
tuple: [1, 2, 3, 4, 5]
&quot;&quot;&quot;
</code></pre>
<p>所有的内置对象和内置函数都在内置名字空间里面，可以通过 import builtins 获取、也可以直接通过 __builtins__ 这个变量来获取，当然这种方式拿到的是模块，再获取模块的 __dict__ 就是内置名字空间了。</p>
<p>我们在 foo1 中把 list 和 tuple 互换了，而这个结果显然也影响了 foo2 函数，这也说明了 builtins 模块是属于进程级别的，它被多个线程共享。当然不止内置名字空间，所有的 module 对象都是被多个线程共享的，所以是 <code>interp-&gt;modules = modules</code>。</p>
<p>至于对 builtins 模块的初始化是在 _PyBuiltin_Init 函数中进行的。</p>
<pre><code class="language-C">// Python/bltinmodule.c

PyObject *
_PyBuiltin_Init(void)
{
    PyObject *mod, *dict, *debug;

    const PyConfig *config = &amp;_PyInterpreterState_GET_UNSAFE()-&gt;config;

    if (PyType_Ready(&amp;PyFilter_Type) &lt; 0 ||
        PyType_Ready(&amp;PyMap_Type) &lt; 0 ||
        PyType_Ready(&amp;PyZip_Type) &lt; 0)
        return NULL;
    // 获取 builtins 模块
    mod = _PyModule_CreateInitialized(&amp;builtinsmodule, PYTHON_API_VERSION);
    if (mod == NULL)
        return NULL;
    // 拿到模块内部的属性字典
    dict = PyModule_GetDict(mod);

    // ...
    // 将所有内置对象加入到 builtins 模块的属性字典中，下面这些东西应该不陌生吧
    SETBUILTIN(&quot;None&quot;,                  Py_None);
    SETBUILTIN(&quot;Ellipsis&quot;,              Py_Ellipsis);
    SETBUILTIN(&quot;NotImplemented&quot;,        Py_NotImplemented);
    SETBUILTIN(&quot;False&quot;,                 Py_False);
    SETBUILTIN(&quot;True&quot;,                  Py_True);
    SETBUILTIN(&quot;bool&quot;,                  &amp;PyBool_Type);
    SETBUILTIN(&quot;memoryview&quot;,        &amp;PyMemoryView_Type);
    SETBUILTIN(&quot;bytearray&quot;,             &amp;PyByteArray_Type);
    SETBUILTIN(&quot;bytes&quot;,                 &amp;PyBytes_Type);
    SETBUILTIN(&quot;classmethod&quot;,           &amp;PyClassMethod_Type);
    SETBUILTIN(&quot;complex&quot;,               &amp;PyComplex_Type);
    SETBUILTIN(&quot;dict&quot;,                  &amp;PyDict_Type);
    SETBUILTIN(&quot;enumerate&quot;,             &amp;PyEnum_Type);
    SETBUILTIN(&quot;filter&quot;,                &amp;PyFilter_Type);
    SETBUILTIN(&quot;float&quot;,                 &amp;PyFloat_Type);
    SETBUILTIN(&quot;frozenset&quot;,             &amp;PyFrozenSet_Type);
    SETBUILTIN(&quot;property&quot;,              &amp;PyProperty_Type);
    SETBUILTIN(&quot;int&quot;,                   &amp;PyLong_Type);
    SETBUILTIN(&quot;list&quot;,                  &amp;PyList_Type);
    SETBUILTIN(&quot;map&quot;,                   &amp;PyMap_Type);
    SETBUILTIN(&quot;object&quot;,                &amp;PyBaseObject_Type);
    SETBUILTIN(&quot;range&quot;,                 &amp;PyRange_Type);
    SETBUILTIN(&quot;reversed&quot;,              &amp;PyReversed_Type);
    SETBUILTIN(&quot;set&quot;,                   &amp;PySet_Type);
    SETBUILTIN(&quot;slice&quot;,                 &amp;PySlice_Type);
    SETBUILTIN(&quot;staticmethod&quot;,          &amp;PyStaticMethod_Type);
    SETBUILTIN(&quot;str&quot;,                   &amp;PyUnicode_Type);
    SETBUILTIN(&quot;super&quot;,                 &amp;PySuper_Type);
    SETBUILTIN(&quot;tuple&quot;,                 &amp;PyTuple_Type);
    SETBUILTIN(&quot;type&quot;,                  &amp;PyType_Type);
    SETBUILTIN(&quot;zip&quot;,                   &amp;PyZip_Type);
    debug = PyBool_FromLong(config-&gt;optimization_level == 0);
    if (PyDict_SetItemString(dict, &quot;__debug__&quot;, debug) &lt; 0) {
        Py_DECREF(debug);
        return NULL;
    }
    Py_DECREF(debug);

    return mod;
#undef ADD_TO_ALL
#undef SETBUILTIN
}
</code></pre>
<p>整个 _PyBuiltin__Init 函数的功能就是设置内置名字空间，不过设置的东西似乎少了很多，比如 dir、hasattr、setattr 等等，这些明显也是内置的，但是它们到哪里去了呢。其实，设置内置名字空间这个过程是分为两步的：</p>
<ul>
<li>通过 _PyModule_CreateInitialized 函数创建 PyModuleObject 对象，即 builtins 模块。</li>
<li>获取 builtins 模块的属性字典（即内置名字空间），将 Python 的内置对象塞到里面。</li>
</ul>
<p>我们上面只看到了第二步，其实在第一步创建 builtins 模块时就已经完成了大部分的属性设置工作。</p>
<pre><code class="language-C">// Include/moduleobject.h

// 包含了模块的核心信息
typedef struct PyModuleDef{
    PyModuleDef_Base m_base;
    // 模块名称
    const char* m_name;
    // 模块的文档字符串
    const char* m_doc;
    // 模块的额外内存大小，用于单进程多解释器
    // 如果不是多解释器模式，那么写 -1 即可
    Py_ssize_t m_size;
    // 模块内部定义的函数
    PyMethodDef *m_methods;
    // 用于定义模块导入时的特殊行为，比如多阶段初始化等高级特性
    struct PyModuleDef_Slot* m_slots;
    // 用于垃圾回收，负责遍历模块引用的对象
    traverseproc m_traverse;
    // 用于垃圾回收，负责清理模块状态
    inquiry m_clear;
    // 模块被销毁时调用的清理函数
    freefunc m_free;
} PyModuleDef;

// Object/moduleobject.c
PyObject *
_PyModule_CreateInitialized(struct PyModuleDef* module, int module_api_version)
{
    const char* name;
    PyModuleObject *m;
    // 初始化
    if (!PyModuleDef_Init(module))
        return NULL;
    // 拿到 module 的 name，对于当前来说就是 builtins
    name = module-&gt;m_name;
    // 这里比较有意思，这是检测模块版本的，针对的是需要被导入的 py 文件
    // 解释器在导入 py 文件时，会优先从当前目录的 __pycache__ 里面加载 pyc
    // 而 pyc 文件包含了编译时解释器的 MAGIC NUMBER，所以要比较是否一致
    // 如果不一致，说明解释器版本不对，则不导入 pyc 文件，而是会重新编译 py 文件    
    if (!check_api_version(name, module_api_version)) {
        return NULL;
    }
    if (module-&gt;m_slots) {
        PyErr_Format(
            PyExc_SystemError,
            &quot;module %s: PyModule_Create is incompatible with m_slots&quot;, name);
        return NULL;
    }
    // ...
    // 创建一个 PyModuleObject 实例
    if ((m = (PyModuleObject*)PyModule_New(name)) == NULL)
        return NULL;
    // 如果 m_size &gt; 0，说明当前是多解释器模式，这个不需要关注
    // 因为多解释器模式只能手动调用 Python/C API 开启（用得也很少）
    // 像我们平时在使用 Python 时，都是一个进程对应一个解释器
    if (module-&gt;m_size &gt; 0) {
        m-&gt;md_state = PyMem_MALLOC(module-&gt;m_size);
        if (!m-&gt;md_state) {
            PyErr_NoMemory();
            Py_DECREF(m);
            return NULL;
        }
        memset(m-&gt;md_state, 0, module-&gt;m_size);
    }
    // 这里的变量 module 指向 PyModuleDef，它包含了模块的核心信息
    // 而变量 m 指向的 PyModuleObject 才是模块对象，它是基于 PyModuleDef 构建的
    if (module-&gt;m_methods != NULL) {
        // module-&gt;m_methods 指向 builtin_methods 数组，该数组中包含了大量的内置函数
        // 调用 PyModule_AddFunctions 将它们添加到模块中
        if (PyModule_AddFunctions((PyObject *) m, module-&gt;m_methods) != 0) {
            Py_DECREF(m);
            return NULL;
        }
    }
    if (module-&gt;m_doc != NULL) {
        // 设置 docstring
        if (PyModule_SetDocString((PyObject *) m, module-&gt;m_doc) != 0) {
            Py_DECREF(m);
            return NULL;
        }
    }
    m-&gt;md_def = module;
    return (PyObject*)m;
}
</code></pre>
<p>所以在创建模块之后，就已经将大量的内置函数添加到 builtins 模块里面了。然后来看一下模块的具体创建过程。</p>
<h3 id="创建-module-对象"><a class="header" href="#创建-module-对象">创建 module 对象</a></h3>
<p>Python 的 module 对象在底层对应 PyModuleObject 结构体，来看看它长什么样子。</p>
<pre><code class="language-c">// Objects/moduleobject.c
typedef struct {
    // 头部信息
    PyObject_HEAD
    // 属性字典，所有的属性和值都在里面
    PyObject *md_dict;
    // module 对象的核心信息
    struct PyModuleDef *md_def;
    void *md_state;
    PyObject *md_weaklist;
    PyObject *md_name;
} PyModuleObject;
</code></pre>
<p>而这个对象是通过 PyModule_New 创建的。</p>
<pre><code class="language-C">// Objects/moduleobject.c
PyObject *
PyModule_New(const char *name)
{
    PyObject *nameobj, *module;
    // 模块的名称
    nameobj = PyUnicode_FromString(name);
    if (nameobj == NULL)
        return NULL;
    // 创建 PyModuleObject
    module = PyModule_NewObject(nameobj);
    Py_DECREF(nameobj);
    return module;
}

PyObject *
PyModule_NewObject(PyObject *name)
{
    PyModuleObject *m;
    // 为模块对象申请内存空间
    m = PyObject_GC_New(PyModuleObject, &amp;PyModule_Type);
    if (m == NULL)
        return NULL;
    // 初始化内部字段
    m-&gt;md_def = NULL;
    m-&gt;md_state = NULL;
    m-&gt;md_weaklist = NULL;
    m-&gt;md_name = NULL;
    // 属性字典
    m-&gt;md_dict = PyDict_New();
    // 调用 module_init_dict 初始化属性字典
    if (module_init_dict(m, m-&gt;md_dict, name, NULL) != 0)
        goto fail;
    PyObject_GC_Track(m);
    return (PyObject *)m;

 fail:
    Py_DECREF(m);
    return NULL;
}

static int
module_init_dict(PyModuleObject *mod, PyObject *md_dict,
                 PyObject *name, PyObject *doc)
{
    _Py_IDENTIFIER(__name__);
    _Py_IDENTIFIER(__doc__);
    _Py_IDENTIFIER(__package__);
    _Py_IDENTIFIER(__loader__);
    _Py_IDENTIFIER(__spec__);

    if (md_dict == NULL)
        return -1;
    if (doc == NULL)
        doc = Py_None;
    // 模块的一些属性，如 __name__、__doc__等等
    if (_PyDict_SetItemId(md_dict, &amp;PyId___name__, name) != 0)
        return -1;
    if (_PyDict_SetItemId(md_dict, &amp;PyId___doc__, doc) != 0)
        return -1;
    if (_PyDict_SetItemId(md_dict, &amp;PyId___package__, Py_None) != 0)
        return -1;
    if (_PyDict_SetItemId(md_dict, &amp;PyId___loader__, Py_None) != 0)
        return -1;
    if (_PyDict_SetItemId(md_dict, &amp;PyId___spec__, Py_None) != 0)
        return -1;
    if (PyUnicode_CheckExact(name)) {
        Py_INCREF(name);
        Py_XSETREF(mod-&gt;md_name, name);
    }

    return 0;
}
</code></pre>
<p>这里虽然创建了一个 module 对象，但这仅仅是一个空的 module 对象，并没有包含相应的操作和数据。我们看到只设置了 name 和 doc 等属性。</p>
<h3 id="设置-module-对象的属性"><a class="header" href="#设置-module-对象的属性">设置 module 对象的属性</a></h3>
<p>在 _PyModule_CreateInitialized 函数中调用 PyModule_New 创建了一个模块，然后通过 PyModule_AddFunctions 完成了对 builtins 大部分属性的设置。这个设置的属性依赖于第二个参数 <code>module-&gt;m_methods</code>，在这里为 builtin_methods。</p>
<pre><code class="language-C">// Python/bltinmodule.c
static PyMethodDef builtin_methods[] = {
    {&quot;__build_class__&quot;, (PyCFunction)(void(*)(void))builtin___build_class__,
     METH_FASTCALL | METH_KEYWORDS, build_class_doc},
    {&quot;__import__&quot;,      (PyCFunction)(void(*)(void))builtin___import__, METH_VARARGS | METH_KEYWORDS, import_doc},
    BUILTIN_ABS_METHODDEF
    BUILTIN_ALL_METHODDEF
    BUILTIN_ANY_METHODDEF
    BUILTIN_ASCII_METHODDEF
    BUILTIN_BIN_METHODDEF
    {&quot;breakpoint&quot;,      (PyCFunction)(void(*)(void))builtin_breakpoint, METH_FASTCALL | METH_KEYWORDS, breakpoint_doc},
    BUILTIN_CALLABLE_METHODDEF
    BUILTIN_CHR_METHODDEF
    BUILTIN_COMPILE_METHODDEF
    BUILTIN_DELATTR_METHODDEF
    {&quot;dir&quot;,             builtin_dir,        METH_VARARGS, dir_doc},
    BUILTIN_DIVMOD_METHODDEF
    BUILTIN_EVAL_METHODDEF
    BUILTIN_EXEC_METHODDEF
    BUILTIN_FORMAT_METHODDEF
    {&quot;getattr&quot;,         (PyCFunction)(void(*)(void))builtin_getattr, METH_FASTCALL, getattr_doc},
    BUILTIN_GLOBALS_METHODDEF
    BUILTIN_HASATTR_METHODDEF
    BUILTIN_HASH_METHODDEF
    BUILTIN_HEX_METHODDEF
    BUILTIN_ID_METHODDEF
    BUILTIN_INPUT_METHODDEF
    BUILTIN_ISINSTANCE_METHODDEF
    BUILTIN_ISSUBCLASS_METHODDEF
    {&quot;iter&quot;,            (PyCFunction)(void(*)(void))builtin_iter,       METH_FASTCALL, iter_doc},
    BUILTIN_LEN_METHODDEF
    BUILTIN_LOCALS_METHODDEF
    {&quot;max&quot;,             (PyCFunction)(void(*)(void))builtin_max,        METH_VARARGS | METH_KEYWORDS, max_doc},
    {&quot;min&quot;,             (PyCFunction)(void(*)(void))builtin_min,        METH_VARARGS | METH_KEYWORDS, min_doc},
    {&quot;next&quot;,            (PyCFunction)(void(*)(void))builtin_next,       METH_FASTCALL, next_doc},
    BUILTIN_OCT_METHODDEF
    BUILTIN_ORD_METHODDEF
    BUILTIN_POW_METHODDEF
    {&quot;print&quot;,           (PyCFunction)(void(*)(void))builtin_print,      METH_FASTCALL | METH_KEYWORDS, print_doc},
    BUILTIN_REPR_METHODDEF
    BUILTIN_ROUND_METHODDEF
    BUILTIN_SETATTR_METHODDEF
    BUILTIN_SORTED_METHODDEF
    BUILTIN_SUM_METHODDEF
    {&quot;vars&quot;,            builtin_vars,       METH_VARARGS, vars_doc},
    {NULL,              NULL},
};
</code></pre>
<p>怎么样，是不是看到了玄机。</p>
<p>总结一下就是：在 Py_NewInterpreter 里面调用 new_interpreter 函数，然后在 new_interpreter 函数里面，通过 PyInterpreterState_New 创建 PyInterpreterState 对象，然后以 PyInterpreterState 对象为参数，调用 PyThreadState_New 函数创建 PyThreadState 对象。</p>
<p>接着就是执行各种初始化动作，然后调用 _PyBuiltin_Init 设置内置属性。然而在 _PyBuiltin_Init 函数的最后设置的都是一些内置的类对象，而内置函数（比如 getattr、exec 等）却没有设置。</p>
<p>所以 _PyBuiltin_Init 函数中间调用的 _PyModule_CreateInitialized 不仅仅是初始化一个 module 对象，还会在初始化之后将我们没有看到的一些属性设置进去。在里面先使用 PyModule_New 创建一个 PyModuleObject，此时它内部只有 __name__ 和 __doc__ 等属性，之后再通过 PyModule_AddFunctions 设置 builtin_methods，在 builtin_methods 里面我们看到了 dir、getattr 等内置函数。当这些属性设置完之后，退回到 _PyBuiltin_Init 函数中，再设置剩余的部分属性（内置的类对象和一些常量）。之后，builtins 模块就完成了。</p>
<p><img src="./images/277.png" alt="" /></p>
<p>另外 builtin_methods 是一个 PyMethodDef 类型的数组，里面是一个个的 PyMethodDef 结构体实例。</p>
<pre><code class="language-C">// Include/methodobject.h

typedef PyObject *(*PyCFunction)(PyObject *, PyObject *);
typedef PyObject *(*_PyCFunctionFast) (PyObject *, PyObject *const *, Py_ssize_t);
typedef PyObject *(*PyCFunctionWithKeywords)(PyObject *, PyObject *, PyObject *);

struct PyMethodDef {
    // 内置函数的名称
    const char  *ml_name;
    // 具体实现对应的 C 函数
    PyCFunction ml_meth;
    // 函数类型
    /* #define METH_VARARGS  0x0001  支持扩展位置参数
     * #define METH_KEYWORDS 0x0002  支持扩展关键字参数
     * #define METH_NOARGS   0x0004  不需要参数
     * #define METH_O        0x0008  精确接收一个位置参数
     * #define METH_CLASS    0x0010  被 classmethod 装饰的类方法
     * #define METH_STATIC   0x0020  被 staticmethod 装饰的静态方法
     */
    int         ml_flags;
    // 函数的 __doc__
    const char  *ml_doc;
};
typedef struct PyMethodDef PyMethodDef;
</code></pre>
<p>对于这里面每一个 PyMethodDef 实例，_PyModule_CreateInitialized 都会基于它创建一个 PyCFunctionObject 对象，我们说过内置函数以及内置实例对象的方法在底层会对应 PyCFunctionObject。</p>
<pre><code class="language-C">// Include/methodobject.h

typedef struct {
    // 头部信息
    PyObject_HEAD
    // PyMethodDef 实例
    PyMethodDef *m_ml;
    // self 
    PyObject    *m_self;
    // __module__
    PyObject    *m_module;
    // 弱引用列表，不讨论
    PyObject    *m_weakreflist;
    // 为了效率而单独实现的矢量调用函数
    vectorcallfunc vectorcall;
} PyCFunctionObject;
</code></pre>
<p>然后 PyCFunctionObject 的创建则是通过 PyCFunction_New 完成的。</p>
<pre><code class="language-C">// Objects/methodobject.c
PyObject *
PyCFunction_New(PyMethodDef *ml, PyObject *self)
{
    return PyCFunction_NewEx(ml, self, NULL);
}

PyObject *
PyCFunction_NewEx(PyMethodDef *ml, PyObject *self, PyObject *module)
{
    vectorcallfunc vectorcall;
    // 判断参数类型，决定调用方式
    switch (ml-&gt;ml_flags &amp; (METH_VARARGS | METH_FASTCALL | METH_NOARGS | METH_O | METH_KEYWORDS))
    {
        case METH_VARARGS:
        case METH_VARARGS | METH_KEYWORDS:
            /* For METH_VARARGS functions, it's more efficient to use tp_call
             * instead of vectorcall. */
            vectorcall = NULL;
            break;
        case METH_FASTCALL:
            vectorcall = cfunction_vectorcall_FASTCALL;
            break;
        case METH_FASTCALL | METH_KEYWORDS:
            vectorcall = cfunction_vectorcall_FASTCALL_KEYWORDS;
            break;
        case METH_NOARGS:
            vectorcall = cfunction_vectorcall_NOARGS;
            break;
        case METH_O:
            vectorcall = cfunction_vectorcall_O;
            break;
        default:
            PyErr_Format(PyExc_SystemError,
                         &quot;%s() method: bad call flags&quot;, ml-&gt;ml_name);
            return NULL;
    }

    PyCFunctionObject *op;
    // 我们看到 PyCFunctionObject 也采用了缓存池
    op = free_list;
    if (op != NULL) {
        free_list = (PyCFunctionObject *)(op-&gt;m_self);
        (void)PyObject_INIT(op, &amp;PyCFunction_Type);
        numfree--;
    }
    else {
        op = PyObject_GC_New(PyCFunctionObject, &amp;PyCFunction_Type);
        if (op == NULL)
            return NULL;
    }
    // 设置属性
    op-&gt;m_weakreflist = NULL;
    op-&gt;m_ml = ml;
    Py_XINCREF(self);
    op-&gt;m_self = self;
    Py_XINCREF(module);
    op-&gt;m_module = module;
    op-&gt;vectorcall = vectorcall;
    _PyObject_GC_TRACK(op);
    return (PyObject *)op;
}
</code></pre>
<p>以上就是 _PyBuiltin__Init 所做的事情，再之后虚拟机会把 PyModuleObject 对象的属性字典抽取出来，赋值给 <code>interp -&gt; builtins</code>。</p>
<pre><code class="language-C">// Python/pylifecycle.c
static PyStatus
new_interpreter(PyThreadState **tstate_p)
{
    // ...
    PyObject *bimod = _PyImport_FindBuiltin(&quot;builtins&quot;, modules);
    if (bimod != NULL) {
        // 通过 PyModule_GetDict 获取属性字典，赋值给 builtins
        interp-&gt;builtins = PyModule_GetDict(bimod);
        if (interp-&gt;builtins == NULL)
            goto handle_error;
        Py_INCREF(interp-&gt;builtins);
    }
    else if (PyErr_Occurred()) {
        goto handle_error;
    }
    // ...
}
</code></pre>
<p>以后 Python 在访问内置名字空间时，直接访问 <code>interp-&gt;builtins</code> 就可以了，因为内置属性的使用会很频繁，所以这种加速机制是很有效的。</p>
<h2 id="创建-sys-模块"><a class="header" href="#创建-sys-模块">创建 sys 模块</a></h2>
<p>Python 在创建 builtins 模块、设置内置名字空间之前，会先创建 sys 模块，流程是一样的，只是我们将介绍的顺序颠倒了一下。</p>
<pre><code class="language-C">static PyStatus
new_interpreter(PyThreadState **tstate_p)
{
    // ...
    // 创建 sys 模块
    PyObject *sysmod = _PyImport_FindBuiltin(&quot;sys&quot;, modules);
    if (sysmod != NULL) {
        // 获取 sys 模块的属性字典，并赋值给 interp-&gt;sysdict
        interp-&gt;sysdict = PyModule_GetDict(sysmod);
        if (interp-&gt;sysdict == NULL) {
            goto handle_error;
        }
        Py_INCREF(interp-&gt;sysdict);
        // 将 &quot;modules&quot;: modules 添加到 sys 模块的属性字典中
        // 在 Python 里面便可通过 sys.modules 拿到所有的模块
        PyDict_SetItemString(interp-&gt;sysdict, &quot;modules&quot;, modules);
        if (_PySys_InitMain(runtime, interp) &lt; 0) {
            return _PyStatus_ERR(&quot;can't finish initializing sys&quot;);
        }
    }
    else if (PyErr_Occurred()) {
        goto handle_error;
    }
    // ...
}
</code></pre>
<p>创建 sys module 之后，还会额外添加一个 __main__ 模块。</p>
<pre><code class="language-C">static PyStatus
new_interpreter(PyThreadState **tstate_p)
{
    // ...
    status = add_main_module(interp);
    if (_PyStatus_EXCEPTION(status)) {
        return status;
    }  
    // ...
}  

static PyStatus
add_main_module(PyInterpreterState *interp)
{
    PyObject *m, *d, *loader, *ann_dict;
    // 将 __main__ 添加进 sys.modules 中
    m = PyImport_AddModule(&quot;__main__&quot;);
    if (m == NULL)
        return _PyStatus_ERR(&quot;can't create __main__ module&quot;);

    d = PyModule_GetDict(m);
    ann_dict = PyDict_New();
    if ((ann_dict == NULL) ||
        (PyDict_SetItemString(d, &quot;__annotations__&quot;, ann_dict) &lt; 0)) {
        return _PyStatus_ERR(&quot;Failed to initialize __main__.__annotations__&quot;);
    }
    Py_DECREF(ann_dict);

    if (PyDict_GetItemString(d, &quot;__builtins__&quot;) == NULL) {
        PyObject *bimod = PyImport_ImportModule(&quot;builtins&quot;);
        if (bimod == NULL) {
            return _PyStatus_ERR(&quot;Failed to retrieve builtins module&quot;);
        }
        if (PyDict_SetItemString(d, &quot;__builtins__&quot;, bimod) &lt; 0) {
            return _PyStatus_ERR(&quot;Failed to initialize __main__.__builtins__&quot;);
        }
        Py_DECREF(bimod);
    }
  
    loader = PyDict_GetItemString(d, &quot;__loader__&quot;);
    if (loader == NULL || loader == Py_None) {
        PyObject *loader = PyObject_GetAttrString(interp-&gt;importlib,
                                                  &quot;BuiltinImporter&quot;);
        if (loader == NULL) {
            return _PyStatus_ERR(&quot;Failed to retrieve BuiltinImporter&quot;);
        }
        if (PyDict_SetItemString(d, &quot;__loader__&quot;, loader) &lt; 0) {
            return _PyStatus_ERR(&quot;Failed to initialize __main__.__loader__&quot;);
        }
        Py_DECREF(loader);
    }
    return _PyStatus_OK();
}
</code></pre>
<p>这个 __main__ 估计不用我多说了。之前在 PyModule_New 中，创建一个 PyModuleObject 对象之后，会在其属性字典中插入一个名为 &quot;__name__&quot; 的 key，value 就是 &quot;__main__&quot;。但是对于当前模块来说，这个模块也叫做 __main__。</p>
<pre><code class="language-Python">name = &quot;古明地觉&quot;

import __main__
print(__main__.name)  # 古明地觉

import sys
print(sys.modules[&quot;__main__&quot;] is __main__)  # True
</code></pre>
<p>因此我们算是知道了，为什么执行 python xxx.py 的时候，__name__ 是 &quot;__main__&quot; 了，因为这里设置了。而 Python 沿着名字空间寻找的时候，最终会在 __main__ 的 local 空间中发现 __name__，且值为字符串 &quot;__main__&quot;。但如果是以 import 的方式加载的，那么 __name__ 则不是 &quot;__main__&quot;，而是模块名。</p>
<p>其实这个 __main__ 我们再熟悉不过了，当输入 dir() 的时候，就会显示 __main__ 的内容。dir 可以不加参数，如果不加参数，那么默认访问当前的 local 空间，也就是 __main__。</p>
<pre><code class="language-python">&gt;&gt;&gt; __name__
'__main__'
&gt;&gt;&gt; 
&gt;&gt;&gt; __builtins__.__name__
'builtins'
&gt;&gt;&gt;
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; np.__name__
'numpy'
</code></pre>
<p>所以说，访问模块就类似访问变量一样，modules 里面存放了所有的 &lt;模块名, 模块对象&gt;。当我们访问 np 的时候，会找到 name 为 &quot;numpy&quot; 的模块，然后这个值里面也维护了一个字典，其中也有一个 key 为 &quot;__name__&quot; 的 entry，value 为 &quot;numpy&quot;。</p>
<h2 id="设置-site-specific-的-module-搜索路径"><a class="header" href="#设置-site-specific-的-module-搜索路径">设置 site-specific 的 module 搜索路径</a></h2>
<p>Python 是一个非常开放的体系，它的强大来源于丰富的第三方库，这些库由外部的 py 文件来提供。当使用这些第三方库的时候，只需要简单地进行 import 即可。一般来说，这些第三方库都放在 Lib/site-packages 中，如果程序想使用这些库，直接导入即可。</p>
<p>但是到目前为止，我们好像也没看到 Python 将 site-packages 路径设置到搜索路径里面去啊。其实在完成了 __main__ 的创建之后，Python 才腾出手来收拾这个 site-package。这个关键的动作在于 Python 的一个标准库：site.py。</p>
<p>我们先将 Lib 目录下的 site.py 删掉，然后导入一个第三方模块，看看会有什么后果。</p>
<p><img src="./images/278.png" alt="" /></p>
<p>因此 Python 在初始化的过程中确实导入了 site.py，所以才有了如下的输出。而这个 site.py 也正是 Python 能正确加载位于 site-packages 目录下第三方包的关键所在。我们可以猜测，应该就是这个 site.py 将 site-packages 目录加入到了 sys.path 中，而这个动作是由 init_import_size 完成的。</p>
<pre><code class="language-C">static PyStatus
new_interpreter(PyThreadState **tstate_p)
{
    // ...
    if (config-&gt;site_import) {
        status = init_import_size();
        if (_PyStatus_EXCEPTION(status)) {
            return status;
        }
    }
    // ...
}

static PyStatus
init_import_size(void)
{
    PyObject *m;
    // 导入 site 模块，在 site 模块里面会将 site-packages 加入到 sys.path 中
    m = PyImport_ImportModule(&quot;site&quot;);
    // 如果导入失败，抛出异常
    if (m == NULL) {
        // 这里的报错信息是不是和上图中显示的一样呢？
        return _PyStatus_ERR(&quot;Failed to import the site module&quot;);
    }
    Py_DECREF(m);
    return _PyStatus_OK();
}
</code></pre>
<p>在 init_import_size 中，只调用了 PyImport_ImportModule 函数，这个函数是 import 机制的核心所在。比如 PyImport_ImportModule(&quot;numpy&quot;) 就等价于 <font color="blue">import numpy</font>。</p>
<h2 id="小结"><a class="header" href="#小结">小结</a></h2>
<p>以上就是运行时环境的初始化所做的事情，但需要注意：此时虚拟机还没有完全启动。对，上面的那些工作都只是前戏，是虚拟机启动之前所做的一些准备工作。而在准备工作做完之后，虚拟机就会正式启动。那么怎么启动呢？我们下一篇文章再聊。</p>
<hr />
<p> </p>
<p><strong>欢迎大家关注我的公众号：古明地觉的编程教室。</strong></p>
<p><img src="./images/qrcode_for_gh.jpg" alt="" /></p>
<p><strong>如果觉得文章对你有所帮助，也可以请作者吃个馒头，Thanks♪(･ω･)ﾉ。</strong></p>
<p><img src="./images/supports.png" alt="" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="84.import机制是怎么实现的？.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="86.激活Python虚拟机.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="84.import机制是怎么实现的？.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="86.激活Python虚拟机.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="theme/custom.js"></script>
    </body>
</html>
