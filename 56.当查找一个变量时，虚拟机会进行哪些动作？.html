<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>56. 当查找一个变量时，虚拟机会进行哪些动作？ - CPython3.8 源码探秘</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/custom.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="0.序言.html">0. 序言</a></li><li class="chapter-item expanded "><a href="1.CPython源码长什么样子？.html">1. CPython 源码长什么样子？</a></li><li class="chapter-item expanded "><a href="2.变量和对象，它们之间有什么区别和联系呢？.html">2. 变量和对象，它们之间有什么区别和联系呢？</a></li><li class="chapter-item expanded "><a href="3.Python对象有哪几种，我们可以从哪些角度进行分类呢？.html">3. Python 对象有哪几种，我们可以从哪些角度进行分类呢？</a></li><li class="chapter-item expanded "><a href="4.万丈高楼平地起，一切从PyObject开始.html">4. 万丈高楼平地起，一切从 PyObject 开始</a></li><li class="chapter-item expanded "><a href="5.详解PyTypeObject，Python类型对象的载体.html">5. 详解 PyTypeObject，Python 类型对象的载体</a></li><li class="chapter-item expanded "><a href="6.通过type和object之间的关联，进一步分析类型对象.html">6. 通过 type 和 object 之间的关联，进一步分析类型对象</a></li><li class="chapter-item expanded "><a href="7.当创建一个Python对象时，背后都经历了哪些过程？.html">7. 当创建一个 Python 对象时，背后都经历了哪些过程？</a></li><li class="chapter-item expanded "><a href="8.当调用一个Python对象时，背后都经历了哪些过程？.html">8. 当调用一个 Python 对象时，背后都经历了哪些过程？</a></li><li class="chapter-item expanded "><a href="9.再探泛型API，感受Python对象的设计哲学.html">9. 再探泛型 API，感受 Python 对象的设计哲学</a></li><li class="chapter-item expanded "><a href="10.Python对象的行为是怎么区分的？.html">10. Python 对象的行为是怎么区分的？</a></li><li class="chapter-item expanded "><a href="11.一个Python对象会在何时被销毁？.html">11. 一个 Python 对象会在何时被销毁？</a></li><li class="chapter-item expanded "><a href="12.深度解密Python的浮点数是怎么实现的？.html">12. 深度解密 Python 的浮点数是怎么实现的？</a></li><li class="chapter-item expanded "><a href="13.对象被销毁之后所占的内存一定会释放吗？解密浮点数的缓存池机制.html">13. 对象被销毁之后所占的内存一定会释放吗？解密浮点数的缓存池机制</a></li><li class="chapter-item expanded "><a href="14.浮点数支持的操作是怎么实现的？.html">14. 浮点数支持的操作是怎么实现的？</a></li><li class="chapter-item expanded "><a href="15.解密Python的复数是怎么实现的？它有什么用途呢？.html">15. 解密 Python 的复数是怎么实现的？它有什么用途呢？</a></li><li class="chapter-item expanded "><a href="16.Python的整数是怎么设计的，为什么它不会溢出？.html">16. Python 的整数是怎么设计的，为什么它不会溢出？</a></li><li class="chapter-item expanded "><a href="17.解密Python的小整数对象池.html">17. 解密 Python 的小整数对象池</a></li><li class="chapter-item expanded "><a href="18.两个Python整数之间是如何进行大小比较的？过程并不像我们想的那样简单.html">18. 两个 Python 整数之间是如何进行大小比较的？过程并不像我们想的那样简单</a></li><li class="chapter-item expanded "><a href="19.探究Python整数的加减法，感受大整数的运算哲学与魅力.html">19. 探究 Python 整数的加减法，感受大整数的运算哲学与魅力</a></li><li class="chapter-item expanded "><a href="20.Python的布尔值是怎么实现的，你对它的了解有多深呢？.html">20. Python 的布尔值是怎么实现的，你对它的了解有多深呢？</a></li><li class="chapter-item expanded "><a href="21.Python的None是怎么实现的？.html">21. Python 的 None 是怎么实现的？</a></li><li class="chapter-item expanded "><a href="22.深度解密Python切片的实现原理.html">22.深度解密 Python 切片的实现原理</a></li><li class="chapter-item expanded "><a href="23.bytes对象（字节串）是怎么实现的？解密它的内部原理.html">23. bytes 对象（字节串）是怎么实现的？解密它的内部原理</a></li><li class="chapter-item expanded "><a href="24.bytes对象都支持哪些操作，它们是怎么实现的？.html">24. bytes 对象都支持哪些操作，它们是怎么实现的？</a></li><li class="chapter-item expanded "><a href="25.通过bytes对象的合并，探究缓冲区的奥秘.html">25. 通过 bytes 对象的合并，探究缓冲区的奥秘</a></li><li class="chapter-item expanded "><a href="26.解密bytes对象的缓存池.html">26. 解密 bytes 对象的缓存池</a></li><li class="chapter-item expanded "><a href="27.详解bytearray对象的底层实现.html">27. 详解 bytearray 对象的底层实现</a></li><li class="chapter-item expanded "><a href="28.字符集和字符编码.html">28. 字符集和字符编码</a></li><li class="chapter-item expanded "><a href="29.Python是怎么存储字符串的？.html">29. Python 是怎么存储字符串的？</a></li><li class="chapter-item expanded "><a href="30.解密字符串的底层结构，它是怎么实现的？.html">30. 解密字符串的底层结构，它是怎么实现的？</a></li><li class="chapter-item expanded "><a href="31.字符串的intern机制是怎么一回事？.html">31. 字符串的 intern 机制是怎么一回事？</a></li><li class="chapter-item expanded "><a href="32.聊一聊字符串常见操作的源码实现.html">32. 聊一聊字符串常见操作的源码实现</a></li><li class="chapter-item expanded "><a href="33.列表是怎么实现的？解密列表的数据结构.html">33. 列表是怎么实现的？解密列表的数据结构</a></li><li class="chapter-item expanded "><a href="34.列表是怎么扩容的？.html">34. 列表是怎么扩容的？</a></li><li class="chapter-item expanded "><a href="35.解密列表的创建与销毁，以及缓存池长什么样子？.html">35. 解密列表的创建与销毁，以及缓存池长什么样子？</a></li><li class="chapter-item expanded "><a href="36.列表作为序列型对象都支持哪些操作，它们在底层是怎么实现的？.html">36. 列表作为序列型对象都支持哪些操作，它们在底层是怎么实现的？</a></li><li class="chapter-item expanded "><a href="37.列表都有哪些自定义方法，它们是怎么实现的？.html">37. 列表都有哪些自定义方法，它们是怎么实现的？</a></li><li class="chapter-item expanded "><a href="38.解密元组的实现原理.html">38. 解密元组的实现原理</a></li><li class="chapter-item expanded "><a href="39.聊一聊喜闻乐见的哈希表.html">39. 聊一聊喜闻乐见的哈希表</a></li><li class="chapter-item expanded "><a href="40.字典是怎么实现的，它的底层结构长什么样子？.html">40. 字典是怎么实现的，它的底层结构长什么样子？</a></li><li class="chapter-item expanded "><a href="41.什么是可哈希对象，它的哈希值是怎么计算的？.html">41. 什么是可哈希对象，它的哈希值是怎么计算的？</a></li><li class="chapter-item expanded "><a href="42.字典的key是怎么映射成索引的，索引冲突了又该怎么办？.html">42. 字典的 key 是怎么映射成索引的，索引冲突了又该怎么办？</a></li><li class="chapter-item expanded "><a href="43.哈希表是怎么删除元素的，能直接删除吗？.html">43. 哈希表是怎么删除元素的，能直接删除吗？</a></li><li class="chapter-item expanded "><a href="44.字典是怎么创建的，支持的操作又是如何实现的？.html">44. 字典是怎么创建的，支持的操作又是如何实现的？</a></li><li class="chapter-item expanded "><a href="45.字典的自定义方法是怎么实现的？.html">45. 字典的自定义方法是怎么实现的？</a></li><li class="chapter-item expanded "><a href="46.字典是怎么扩容的？它会经历哪些过程？.html">46. 字典是怎么扩容的？它会经历哪些过程？</a></li><li class="chapter-item expanded "><a href="47.身虽死，道未消，解密字典的缓存池.html">47. 身虽死，道未消，解密字典的缓存池</a></li><li class="chapter-item expanded "><a href="48.解密集合的实现原理.html">48. 解密集合的实现原理</a></li><li class="chapter-item expanded "><a href="49.集合支持的操作有哪些，它们是怎么实现的？.html">49. 集合支持的操作有哪些，它们是怎么实现的？</a></li><li class="chapter-item expanded "><a href="50.迭代器是怎么实现的？.html">50. 迭代器是怎么实现的？</a></li><li class="chapter-item expanded "><a href="51.Python源文件编译之后会得到什么，它的结构是怎样的？和字节码又有什么联系？.html">51. Python 源文件编译之后会得到什么，它的结构是怎样的？和字节码又有什么联系？</a></li><li class="chapter-item expanded "><a href="52.PyCodeObject拾遗.html">52. PyCodeObject 拾遗</a></li><li class="chapter-item expanded "><a href="53.一文让你搞懂pyc文件.html">53. 一文让你搞懂 pyc 文件</a></li><li class="chapter-item expanded "><a href="54.深度解密虚拟机的执行环境：栈帧对象.html">54. 深度解密虚拟机的执行环境：栈帧对象</a></li><li class="chapter-item expanded "><a href="55.名字空间：变量的容身之所.html">55. 名字空间：变量的容身之所</a></li><li class="chapter-item expanded "><a href="56.当查找一个变量时，虚拟机会进行哪些动作？.html" class="active">56. 当查找一个变量时，虚拟机会进行哪些动作？</a></li><li class="chapter-item expanded "><a href="57.虚拟机是怎么执行字节码的？背后都经历了哪些过程.html">57. 虚拟机是怎么执行字节码的？背后都经历了哪些过程</a></li><li class="chapter-item expanded "><a href="58.深入源码，进一步考察字节码的执行流程.html">58. 深入源码，进一步考察字节码的执行流程</a></li><li class="chapter-item expanded "><a href="59.局部变量是怎么实现静态查找的，它和local名字空间又有什么联系呢？.html">59. 局部变量是怎么实现静态查找的，它和 local 名字空间又有什么联系呢？</a></li><li class="chapter-item expanded "><a href="60.剖析字节码指令，以及Python赋值语句的原理.html">60. 剖析字节码指令，以及 Python 赋值语句的原理</a></li><li class="chapter-item expanded "><a href="61.流程控制语句if是怎么实现的？.html">61. 流程控制语句 if 是怎么实现的？</a></li><li class="chapter-item expanded "><a href="62.流程控制语句for、while是怎么实现的？.html">62. 流程控制语句 for、while 是怎么实现的？</a></li><li class="chapter-item expanded "><a href="63.异常是怎么实现的？虚拟机是如何将异常抛出去的？.html">63. 异常是怎么实现的？虚拟机是如何将异常抛出去的？</a></li><li class="chapter-item expanded "><a href="64.虚拟机是如何捕获异常的？.html">64. 虚拟机是如何捕获异常的？</a></li><li class="chapter-item expanded "><a href="65.函数在底层长什么样子？.html">65. 函数在底层长什么样子？</a></li><li class="chapter-item expanded "><a href="66.函数是怎么创建的，背后经历了哪些过程？.html">66. 函数是怎么创建的，背后经历了哪些过程？</a></li><li class="chapter-item expanded "><a href="67.函数在底层是如何调用的？.html">67. 函数在底层是如何调用的？</a></li><li class="chapter-item expanded "><a href="68.函数是如何解析位置参数的？.html">68. 函数是如何解析位置参数的？</a></li><li class="chapter-item expanded "><a href="69.函数是如何解析关键字参数的？.html">69. 函数是如何解析关键字参数的？</a></li><li class="chapter-item expanded "><a href="70.扩展位置参数和扩展关键字参数是如何解析的？.html">70. 扩展位置参数和扩展关键字参数是如何解析的？</a></li><li class="chapter-item expanded "><a href="71.闭包是怎么实现的？.html">71. 闭包是怎么实现的？</a></li><li class="chapter-item expanded "><a href="72.生成器是做什么的，为什么会有生成器？.html">72. 生成器是做什么的，为什么会有生成器？</a></li><li class="chapter-item expanded "><a href="73.源码解密生成器的实现原理.html">73. 源码解密生成器的实现原理</a></li><li class="chapter-item expanded "><a href="74.回顾Python的对象模型.html">74. 回顾 Python 的对象模型</a></li><li class="chapter-item expanded "><a href="75.class概念解析.html">75. class 概念解析</a></li><li class="chapter-item expanded "><a href="76.类型对象的初始化.html">76. 类型对象的初始化</a></li><li class="chapter-item expanded "><a href="77.自定义类对象的底层实现与metaclass.html">77. 自定义类对象的底层实现与 metaclass</a></li><li class="chapter-item expanded "><a href="78.彻底搞懂描述符.html">78. 彻底搞懂描述符</a></li><li class="chapter-item expanded "><a href="79.实例对象是如何创建的？.html">79. 实例对象是如何创建的？</a></li><li class="chapter-item expanded "><a href="80.实例对象的属性访问.html">80. 实例对象的属性访问</a></li><li class="chapter-item expanded "><a href="81.为什么实例在调用方法时会将自身传给self参数.html">81. 为什么实例在调用方法时会将自身传给 self 参数</a></li><li class="chapter-item expanded "><a href="82.模块是如何导入的？.html">82. 模块是如何导入的？</a></li><li class="chapter-item expanded "><a href="83.import机制的黑盒探测.html">83. import 机制的黑盒探测</a></li><li class="chapter-item expanded "><a href="84.import机制是怎么实现的？.html">84. import 机制是怎么实现的？</a></li><li class="chapter-item expanded "><a href="85.Python运行时环境的初始化，解释器在启动时都做了什么？.html">85. Python 运行时环境的初始化，解释器在启动时都做了什么？</a></li><li class="chapter-item expanded "><a href="86.激活Python虚拟机.html">86. 激活 Python 虚拟机</a></li><li class="chapter-item expanded "><a href="87.初识GIL、以及多个线程之间的调度机制.html">87. 初识 GIL、以及多个线程之间的调度机制</a></li><li class="chapter-item expanded "><a href="88.线程的创建、销毁、调度，以及GIL的实现原理.html">88. 线程的创建、销毁、调度，以及 GIL 的实现原理</a></li><li class="chapter-item expanded "><a href="89.解密map、filter、zip底层实现，对比列表解析式.html">89. 解密 map、filter、zip 底层实现，对比列表解析式</a></li><li class="chapter-item expanded "><a href="90.为什么要有协程，协程是如何实现的？.html">90. 为什么要有协程，协程是如何实现的？</a></li><li class="chapter-item expanded "><a href="91.什么是asyncio？如何基于单线程实现并发？事件循环又是怎么工作的？.html">91. 什么是 asyncio？如何基于单线程实现并发？事件循环又是怎么工作的？</a></li><li class="chapter-item expanded "><a href="92.协程、任务、future，以及事件循环.html">92. 协程、任务、future，以及事件循环</a></li><li class="chapter-item expanded "><a href="93.在asyncio中使用Socket.html">93. 在 asyncio 中使用 Socket</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">CPython3.8 源码探秘</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/satori1995/cpython-internal" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="楔子"><a class="header" href="#楔子">楔子</a></h2>
<p>上一篇文章我们介绍了名字空间，并且知道了全局变量都存在 global 名字空间中，往 global 空间添加一个键值对相当于定义一个全局变量。那么问题来了，如果往函数的 local 空间里面添加一个键值对，是不是也等价于创建了一个局部变量呢？</p>
<pre><code class="language-Python">def foo():
    locals()[&quot;name&quot;] = &quot;古明地觉&quot;
    try:
        print(name)
    except Exception as e:
        print(e)

foo()  # name 'name' is not defined
</code></pre>
<p>全局变量的创建是通过向字典添加键值对实现的，因为全局变量会一直变，需要使用字典来动态维护。</p>
<p>但对于函数来讲，内部的变量是通过静态方式存储和访问的，因为局部作用域中存在哪些变量在编译的时候就已经确定了，我们通过 PyCodeObject 的 co_varnames 即可获取内部都有哪些变量。</p>
<p>所以，虽然我们说变量查找遵循 LGB 规则，但函数内部的变量其实是静态访问的，不过完全可以按照 LGB 的方式理解。关于这方面的细节，后续还会细说。</p>
<blockquote>
<p>因此名字空间是 Python 的灵魂，它规定了变量的作用域，使得 Python 对变量的查找变得非常清晰。</p>
</blockquote>
<h2 id="legb-规则"><a class="header" href="#legb-规则">LEGB 规则</a></h2>
<p>LGB 是针对 Python2.2 之前的，而从 Python2.2 开始，由于引入了嵌套函数，所以内层函数在找不到某个变量时应该先去外层函数找，而不是直接就跑到 global 空间里面找，那么此时的规则就是 LEGB。</p>
<pre><code class="language-Python">x = 1

def foo():
    x = 2
    def bar():
        print(x)
    return bar

foo()()
&quot;&quot;&quot;
2
&quot;&quot;&quot;
</code></pre>
<p>调用了内层函数 bar，如果按照 LGB 的规则来查找的话，由于函数 bar 的作用域没有 a，那么应该到全局里面找，打印的结果是 1 才对。</p>
<p>但我们之前说了，作用域仅仅是由文本决定的，函数 bar 位于函数 foo 之内，所以函数 bar 定义的作用域内嵌于函数 foo 的作用域之内。换句话说，函数 foo 的作用域是函数 bar 的作用域的直接外围作用域。所以应该先从 foo 的作用域里面找，如果没有那么再去全局里面找，而作用域和名字空间是对应的，所以最终打印了 2。</p>
<p>另外在调用 foo() 的时候，会执行函数 foo 中的 <font color="blue">def bar():</font> 语句，这个时候解释器会将 a = 2 与函数 bar 捆绑在一起，然后返回，这个捆绑起来的整体就叫做闭包。</p>
<p><strong>所以：闭包 = 内层函数 + 引用的外层作用域。</strong></p>
<p>而这里显示的规则就是 LEGB，其中 E 表示 Enclosing，代表直接外围作用域。</p>
<h2 id="global-表达式"><a class="header" href="#global-表达式">global 表达式</a></h2>
<p>在初学 Python 时，估计很多人都会对下面的问题感到困惑。</p>
<pre><code class="language-Python">x = 1

def foo():
    print(x)

foo()
&quot;&quot;&quot;
1
&quot;&quot;&quot;
</code></pre>
<p>首先这段代码打印 1，这显然是没有问题的，不过下面问题来了。</p>
<pre><code class="language-Python">x = 1

def foo():
    print(x)
    x = 2

foo()
</code></pre>
<p>这段代码在执行 print(x) 的时候是会报错的，会抛出一个 UnboundLocalError: local variable 'x' referenced before assignment，意思是局部变量 x 在赋值之前就被使用了。</p>
<p>那么问题来了，在 print(x) 的下面加一个 x = 2，整体效果不应该是先打印全局变量 x，然后再创建一个局部变量 x 吗？为啥就报错了呢，相信肯定有人为此困惑。如果想弄明白这个错误的原因，需要深刻理解两点：</p>
<ul>
<li>函数中的变量是静态存储、静态访问的，内部有哪些变量在编译的时候就已经确定；</li>
<li>局部变量在整个作用域内都是可见的；</li>
</ul>
<p>在编译的时候，因为 <font color="blue">x = 2</font> 这条语句，所以知道函数中存在一个局部变量 x，那么查找的时候就会在当前局部作用域中查找，但还没来得及赋值，就 print(x) 了。换句话说，在打印 x 的时候，它还没有和某个具体的值进行绑定，所以报错：局部变量 x 在赋值之前就被使用了。</p>
<p>但如果没有 <font color="blue">x = 2</font> 这条语句则不会报错，因为知道局部作用域中不存在 x 这个变量，所以会找全局变量 x，从而打印 1。</p>
<p>更有趣的东西隐藏在字节码当中，我们可以通过反汇编来查看一下：</p>
<pre><code class="language-Python">import dis

x = 1

def foo():
    print(x)

dis.dis(foo)
&quot;&quot;&quot;
  6           0 LOAD_GLOBAL              0 (print)
              2 LOAD_GLOBAL              1 (x)
              4 CALL_FUNCTION            1
              6 POP_TOP
              8 LOAD_CONST               0 (None)
             10 RETURN_VALUE
&quot;&quot;&quot;

def bar():
    print(x)
    x = 2
    
dis.dis(bar)    
&quot;&quot;&quot;
 19           0 LOAD_GLOBAL              0 (print)
              2 LOAD_FAST                0 (x)
              4 CALL_FUNCTION            1
              6 POP_TOP

 20           8 LOAD_CONST               1 (2)
             10 STORE_FAST               0 (x)
             12 LOAD_CONST               0 (None)
             14 RETURN_VALUE
&quot;&quot;&quot;
</code></pre>
<p>第二列的序号代表字节码指令的偏移量，我们看偏移量为 2 的指令，函数 foo 对应的指令是 LOAD_GLOBAL，意思是在 global 空间中查找 x。而函数 bar 的指令是 LOAD_FAST，表示在数组中静态查找 x，但遗憾的是，此时 x 还没有和某个值进行绑定。</p>
<p>因此结果说明 Python 采用了静态作用域策略，在编译的时候就已经知道变量藏身于何处。而且这个例子也表明，一旦函数内有了对某个变量的赋值操作，它会在整个作用域内可见，因为编译时就已经确定。换句话说，会遮蔽外层作用域中相同的名字。</p>
<p>我们看一下函数 foo 和函数 bar 的符号表。</p>
<pre><code class="language-python">x = 1

def foo():
    print(x)


def bar():
    print(x)
    x = 2

print(foo.__code__.co_varnames)  # ()
print(bar.__code__.co_varnames)  # ('x',)
</code></pre>
<p>在编译的时候，就知道函数 bar 里面存在局部变量 x。</p>
<p>如果想修复这个错误，可以用之前说的 global 关键字，将变量 x 声明为全局的。</p>
<pre><code class="language-Python">x = 1

def bar():
    global x  # 表示变量 x 是全局变量
    print(x)
    x = 2

bar()  # 1
print(x)  # 2
</code></pre>
<p>但这样的话，会导致外部的全局变量被修改，如果不想出现这种情况，那么可以考虑直接获取全局名字空间。</p>
<pre><code class="language-Python">x = 1

def bar():
    print(globals()[&quot;x&quot;])
    x = 2

bar()  # 1
print(x)  # 1
</code></pre>
<p>这样结果就没问题了，同样的，类似的问题也会出现在嵌套函数中。</p>
<pre><code class="language-Python">def foo():
    x = 1
    def bar():
        print(x)
        x = 2
    return bar

foo()()
</code></pre>
<p>执行内层函数 bar 的时候，print(x) 也会出现 UnboundLocalError，如果想让它不报错，而是打印外层函数中的 x，该怎么做呢？Python 同样为我们准备了一个关键字：nonlocal。</p>
<pre><code class="language-Python">def foo():
    x = 1
    def bar():
        # 使用 nonlocal 的时候，必须是在内层函数里面
        nonlocal x
        print(x)
        x = 2
    return bar

foo()()  # 1
</code></pre>
<p>如果 bar 里面是 global x，那么表示 x 是全局变量，当 foo()() 执行完毕之后，会创建一个全局变量 <font color="blue">x = 2</font>。但这里不是 global，而是 nonlocal，表示 x 是外部作用域中的变量，因此会打印 foo 里面的变量 x。</p>
<p>当然啦，既然声明为 nonlocal，那么 foo 里面的 x 肯定会受到影响。</p>
<pre><code class="language-Python">import inspect

frame = None  

def foo():
    globals()[&quot;frame&quot;] = inspect.currentframe()
    x = 1
    def bar():
        nonlocal x
        # print(x)
        x = 2
    return bar

bar = foo()
# 打印 foo 的局部变量，此时变量 x 的值为 1
print(frame.f_locals)
&quot;&quot;&quot;
{'bar': &lt;function foo.&lt;locals&gt;.bar at 0x7fbe3b8664c0&gt;, 'x': 1}
&quot;&quot;&quot;
# 调用内层函数 bar
bar()
# 此时 foo 的局部变量 x 的值变成了 2
print(frame.f_locals)
&quot;&quot;&quot;
{'bar': &lt;function foo.&lt;locals&gt;.bar at 0x7fbe3b8664c0&gt;, 'x': 2}
&quot;&quot;&quot;
</code></pre>
<p>不过由于 foo 是一个函数，调用内层函数 bar 的时候，外层函数 foo 已经结束了，所以不管怎么修改它里面的变量，都无所谓了。</p>
<p>另外上面的函数只嵌套了两层，即使嵌套很多层也是可以的。</p>
<pre><code class="language-python">import inspect

frame = None

def a():
    def b():
        globals()[&quot;frame&quot;] = inspect.currentframe()
        x = 123
        def c():
            def d():
                def e():
                    def f():
                        nonlocal x
                        print(x)
                        x = 456
                    return f
                return e
            return d
        return c
    return b

b = a()
c = b()
d = c()
e = d()
f = e()
print(frame.f_locals)
&quot;&quot;&quot;
{'c': &lt;function a.&lt;locals&gt;.b.&lt;locals&gt;.c at 0x7fbe3b82d670&gt;, 'x': 123}
&quot;&quot;&quot;
# 调用函数 f 的时候，打印的是函数 b 里面的变量 x
# 当然，最后也会修改它
f()
&quot;&quot;&quot;
123
&quot;&quot;&quot;
# 可以看到 x 变成了 456
print(frame.f_locals)
&quot;&quot;&quot;
{'c': &lt;function a.&lt;locals&gt;.b.&lt;locals&gt;.c at 0x7fbe3b82d670&gt;, 'x': 456}
&quot;&quot;&quot;
</code></pre>
<p>不难发现，在嵌套多层的情况下，会采用就近原则。如果函数 d 里面也定义了变量 x，那么函数 f 里面的 nonlocal x 表示的就是函数 d 里面的局部变量 x。 </p>
<h2 id="属性查找"><a class="header" href="#属性查找">属性查找</a></h2>
<p>当我们访问某个变量时，会按照 LEGB 的规则进行查找，而属性查找也是类似的，本质上都是到名字空间中查找一个名字所引用的对象。但由于属性查找限定了范围，所以要更简单，比如 a.xxx，就是到 a 里面去找属性 xxx，这个规则是不受 LEGB 作用域限制的，就是到 a 里面查找，有就是有，没有就是没有。</p>
<pre><code class="language-Python">import numpy as np

# 在 np 指向的对象（模块）中查找 array 属性
print(np.array([1, 2, 3]))
&quot;&quot;&quot;
[1 2 3]
&quot;&quot;&quot;
# 本质上就是去 np 的属性字典中查找 key = &quot;array&quot; 对应的 value
print(np.__dict__[&quot;array&quot;]([11, 22, 33]))
&quot;&quot;&quot;
[11 22 33]
&quot;&quot;&quot;


class Girl:

    name = &quot;古明地觉&quot;
    age = 16

print(Girl.name, Girl.age)
&quot;&quot;&quot;
古明地觉 16
&quot;&quot;&quot;
print(Girl.__dict__[&quot;name&quot;], Girl.__dict__[&quot;age&quot;])
&quot;&quot;&quot;
古明地觉 16
&quot;&quot;&quot;
</code></pre>
<p>需要补充一点，我们说属性查找会按照 LEGB 规则，但这必须限制在自身所在的模块内，如果是多个模块就不行了。举个例子，假设有两个 py 文件，内容如下：</p>
<pre><code class="language-Python"># girl.py
print(name)

# main.py
name = &quot;古明地觉&quot;
from girl import name
</code></pre>
<p>关于模块的导入我们后续会详细说，总之执行 main.py 的时候报错了，提示<font color="blue">变量 name 没有被定义</font>，但问题是 main.py 里面定义了变量 name，为啥报错呢？</p>
<p>很明显，因为 girl.py 里面没有定义变量 name，所以导入 girl 的时候报错了。因此结论很清晰了，变量查找虽然是 LEGB 规则，但不会越过自身所在的模块。print(name) 在 girl.py 里面，而变量 name 定义在 main.py 里面，在导入时不可能跨过 girl.py 的作用域去访问 main.py 里的 name，因此在执行 <font color="blue">from girl import name</font> 的时候会抛出 NameError。</p>
<p><strong>虽然每个模块内部的作用域规则有点复杂，因为要遵循 LEGB；但模块与模块的作用域之间则划分得很清晰，就是相互独立。</strong></p>
<p>关于模块，我们后续会详细说。总之通过属性操作符 <font color="blue"><strong>.</strong></font> 的方式，本质上都是去指定的名字空间中查找对应的属性。</p>
<h2 id="属性空间"><a class="header" href="#属性空间">属性空间</a></h2>
<p>自定义的类里面如果没有 __slots__，那么这个类的实例对象会有一个属性字典，和名字空间的概念是等价的。</p>
<pre><code class="language-Python">class Girl:
    def __init__(self):
        self.name = &quot;古明地觉&quot;
        self.age = 16

g = Girl()
print(g.__dict__)  # {'name': '古明地觉', 'age': 16}

# 对于查找属性而言, 也是去属性字典中查找
print(g.name, g.__dict__[&quot;name&quot;])  # 古明地觉 古明地觉

# 同理设置属性, 也是更改对应的属性字典
g.__dict__[&quot;gender&quot;] = &quot;female&quot;
print(g.gender)  # female
</code></pre>
<p>当然模块也有属性字典，本质上和类的实例对象是一致的，因为模块本身就是一个实例对象。</p>
<pre><code class="language-Python">print(__builtins__.str)  # &lt;class 'str'&gt;
print(__builtins__.__dict__[&quot;str&quot;])  # &lt;class 'str'&gt;
</code></pre>
<p>另外这个 __builtins__ 位于 global 名字空间里面，然后获取 global 名字空间的 globals 又是一个内置函数，于是一个神奇的事情就出现了。</p>
<pre><code class="language-Python">print(globals()[&quot;__builtins__&quot;].globals()[&quot;__builtins__&quot;].
      globals()[&quot;__builtins__&quot;].globals()[&quot;__builtins__&quot;].
      globals()[&quot;__builtins__&quot;].globals()[&quot;__builtins__&quot;]
      )  # &lt;module 'builtins' (built-in)&gt;

print(globals()[&quot;__builtins__&quot;].globals()[&quot;__builtins__&quot;].
      globals()[&quot;__builtins__&quot;].globals()[&quot;__builtins__&quot;].
      globals()[&quot;__builtins__&quot;].globals()[&quot;__builtins__&quot;].list(&quot;abc&quot;)
      )  # ['a', 'b', 'c']
</code></pre>
<p>global 名字空间和 builtin 名字空间，都保存了指向彼此的指针，所以不管套娃多少次，都是可以的。</p>
<h2 id="小结"><a class="header" href="#小结">小结</a></h2>
<p>整个内容很好理解，关键的地方就在于局部变量，它是静态存储的，编译期间就已经确定。而在访问局部变量时，也是基于数组实现的静态查找，而不是使用字典。</p>
<p>关于 local 空间，以及如何使用数组实现静态查找，我们后面还会详细说。</p>
<hr />
<p> </p>
<p><strong>欢迎大家关注我的公众号：古明地觉的编程教室。</strong></p>
<p><img src="./images/qrcode_for_gh.jpg" alt="" /></p>
<p><strong>如果觉得文章对你有所帮助，也可以请作者吃个馒头，Thanks♪(･ω･)ﾉ。</strong></p>
<p><img src="./images/supports.png" alt="" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="55.名字空间：变量的容身之所.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="57.虚拟机是怎么执行字节码的？背后都经历了哪些过程.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="55.名字空间：变量的容身之所.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="57.虚拟机是怎么执行字节码的？背后都经历了哪些过程.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="theme/custom.js"></script>
    </body>
</html>
